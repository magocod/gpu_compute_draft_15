/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const HSA_VERSION_1_0: u32 = 1;
pub const HSA_AMD_INTERFACE_VERSION_MAJOR: u32 = 1;
pub const HSA_AMD_INTERFACE_VERSION_MINOR: u32 = 6;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " The function has been executed successfully."]
pub const hsa_status_t_HSA_STATUS_SUCCESS: hsa_status_t = 0;
#[doc = " A traversal over a list of elements has been interrupted by the\n application before completing."]
pub const hsa_status_t_HSA_STATUS_INFO_BREAK: hsa_status_t = 1;
#[doc = " A generic error has occurred."]
pub const hsa_status_t_HSA_STATUS_ERROR: hsa_status_t = 4096;
#[doc = " One of the actual arguments does not meet a precondition stated in the\n documentation of the corresponding formal argument."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ARGUMENT: hsa_status_t = 4097;
#[doc = " The requested queue creation is not valid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_QUEUE_CREATION: hsa_status_t = 4098;
#[doc = " The requested allocation is not valid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ALLOCATION: hsa_status_t = 4099;
#[doc = " The agent is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_AGENT: hsa_status_t = 4100;
#[doc = " The memory region is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_REGION: hsa_status_t = 4101;
#[doc = " The signal is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SIGNAL: hsa_status_t = 4102;
#[doc = " The queue is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_QUEUE: hsa_status_t = 4103;
#[doc = " The HSA runtime failed to allocate the necessary resources. This error\n may also occur when the HSA runtime needs to spawn threads or create\n internal OS-specific events."]
pub const hsa_status_t_HSA_STATUS_ERROR_OUT_OF_RESOURCES: hsa_status_t = 4104;
#[doc = " The AQL packet is malformed."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_PACKET_FORMAT: hsa_status_t = 4105;
#[doc = " An error has been detected while releasing a resource."]
pub const hsa_status_t_HSA_STATUS_ERROR_RESOURCE_FREE: hsa_status_t = 4106;
#[doc = " An API other than ::hsa_init has been invoked while the reference count\n of the HSA runtime is 0."]
pub const hsa_status_t_HSA_STATUS_ERROR_NOT_INITIALIZED: hsa_status_t = 4107;
#[doc = " The maximum reference count for the object has been reached."]
pub const hsa_status_t_HSA_STATUS_ERROR_REFCOUNT_OVERFLOW: hsa_status_t = 4108;
#[doc = " The arguments passed to a functions are not compatible."]
pub const hsa_status_t_HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS: hsa_status_t = 4109;
#[doc = " The index is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_INDEX: hsa_status_t = 4110;
#[doc = " The instruction set architecture is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ISA: hsa_status_t = 4111;
#[doc = " The instruction set architecture name is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_ISA_NAME: hsa_status_t = 4119;
#[doc = " The code object is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_OBJECT: hsa_status_t = 4112;
#[doc = " The executable is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_EXECUTABLE: hsa_status_t = 4113;
#[doc = " The executable is frozen."]
pub const hsa_status_t_HSA_STATUS_ERROR_FROZEN_EXECUTABLE: hsa_status_t = 4114;
#[doc = " There is no symbol with the given name."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SYMBOL_NAME: hsa_status_t = 4115;
#[doc = " The variable is already defined."]
pub const hsa_status_t_HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED: hsa_status_t = 4116;
#[doc = " The variable is undefined."]
pub const hsa_status_t_HSA_STATUS_ERROR_VARIABLE_UNDEFINED: hsa_status_t = 4117;
#[doc = " An HSAIL operation resulted in a hardware exception."]
pub const hsa_status_t_HSA_STATUS_ERROR_EXCEPTION: hsa_status_t = 4118;
#[doc = " The code object symbol is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_SYMBOL: hsa_status_t = 4120;
#[doc = " The executable symbol is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_EXECUTABLE_SYMBOL: hsa_status_t = 4121;
#[doc = " The file descriptor is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_FILE: hsa_status_t = 4128;
#[doc = " The code object reader is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CODE_OBJECT_READER: hsa_status_t = 4129;
#[doc = " The cache is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_CACHE: hsa_status_t = 4130;
#[doc = " The wavefront is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_WAVEFRONT: hsa_status_t = 4131;
#[doc = " The signal group is invalid."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_SIGNAL_GROUP: hsa_status_t = 4132;
#[doc = " The HSA runtime is not in the configuration state."]
pub const hsa_status_t_HSA_STATUS_ERROR_INVALID_RUNTIME_STATE: hsa_status_t = 4133;
#[doc = " The queue received an error that may require process termination."]
pub const hsa_status_t_HSA_STATUS_ERROR_FATAL: hsa_status_t = 4134;
#[doc = " @brief Status codes."]
pub type hsa_status_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Query additional information about a status code.\n\n @param[in] status Status code.\n\n @param[out] status_string A NUL-terminated string that describes the error\n status.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p status is an invalid\n status code, or @p status_string is NULL."]
    pub fn hsa_status_string(
        status: hsa_status_t,
        status_string: *mut *const ::std::os::raw::c_char,
    ) -> hsa_status_t;
}
#[doc = " @brief Three-dimensional coordinate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_dim3_s {
    #[doc = " X dimension."]
    pub x: u32,
    #[doc = " Y dimension."]
    pub y: u32,
    #[doc = " Z dimension."]
    pub z: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_dim3_s"][::std::mem::size_of::<hsa_dim3_s>() - 12usize];
    ["Alignment of hsa_dim3_s"][::std::mem::align_of::<hsa_dim3_s>() - 4usize];
    ["Offset of field: hsa_dim3_s::x"][::std::mem::offset_of!(hsa_dim3_s, x) - 0usize];
    ["Offset of field: hsa_dim3_s::y"][::std::mem::offset_of!(hsa_dim3_s, y) - 4usize];
    ["Offset of field: hsa_dim3_s::z"][::std::mem::offset_of!(hsa_dim3_s, z) - 8usize];
};
#[doc = " @brief Three-dimensional coordinate."]
pub type hsa_dim3_t = hsa_dim3_s;
#[doc = " Used to remove existing access"]
pub const hsa_access_permission_t_HSA_ACCESS_PERMISSION_NONE: hsa_access_permission_t = 0;
#[doc = " Read-only access."]
pub const hsa_access_permission_t_HSA_ACCESS_PERMISSION_RO: hsa_access_permission_t = 1;
#[doc = " Write-only access."]
pub const hsa_access_permission_t_HSA_ACCESS_PERMISSION_WO: hsa_access_permission_t = 2;
#[doc = " Read and write access."]
pub const hsa_access_permission_t_HSA_ACCESS_PERMISSION_RW: hsa_access_permission_t = 3;
#[doc = " @brief Access permissions."]
pub type hsa_access_permission_t = ::std::os::raw::c_uint;
#[doc = " @brief POSIX file descriptor."]
pub type hsa_file_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " @brief Initialize the HSA runtime.\n\n @details Initializes the HSA runtime if it is not already initialized, and\n increases the reference counter associated with the HSA runtime for the\n current process. Invocation of any HSA function other than ::hsa_init results\n in undefined behavior if the current HSA runtime reference counter is less\n than one.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_REFCOUNT_OVERFLOW The HSA runtime reference\n count reaches INT32_MAX."]
    pub fn hsa_init() -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Shut down the HSA runtime.\n\n @details Decreases the reference count of the HSA runtime instance. When the\n reference count reaches 0, the HSA runtime is no longer considered valid\n but the application might call ::hsa_init to initialize the HSA runtime\n again.\n\n Once the reference count of the HSA runtime reaches 0, all the resources\n associated with it (queues, signals, agent information, etc.) are\n considered invalid and any attempt to reference them in subsequent API calls\n results in undefined behavior. When the reference count reaches 0, the HSA\n runtime may release resources associated with it.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n"]
    pub fn hsa_shut_down() -> hsa_status_t;
}
#[doc = " The least significant byte is stored in the smallest address."]
pub const hsa_endianness_t_HSA_ENDIANNESS_LITTLE: hsa_endianness_t = 0;
#[doc = " The most significant byte is stored in the smallest address."]
pub const hsa_endianness_t_HSA_ENDIANNESS_BIG: hsa_endianness_t = 1;
#[doc = " @brief Endianness. A convention used to interpret the bytes making up a data\n word."]
pub type hsa_endianness_t = ::std::os::raw::c_uint;
#[doc = " Small machine model. Addresses use 32 bits."]
pub const hsa_machine_model_t_HSA_MACHINE_MODEL_SMALL: hsa_machine_model_t = 0;
#[doc = " Large machine model. Addresses use 64 bits."]
pub const hsa_machine_model_t_HSA_MACHINE_MODEL_LARGE: hsa_machine_model_t = 1;
#[doc = " @brief Machine model. A machine model determines the size of certain data\n types in HSA runtime and an agent."]
pub type hsa_machine_model_t = ::std::os::raw::c_uint;
#[doc = " Base profile."]
pub const hsa_profile_t_HSA_PROFILE_BASE: hsa_profile_t = 0;
#[doc = " Full profile."]
pub const hsa_profile_t_HSA_PROFILE_FULL: hsa_profile_t = 1;
#[doc = " @brief Profile. A profile indicates a particular level of feature\n support. For example, in the base profile the application must use the HSA\n runtime allocator to reserve shared virtual memory, while in the full profile\n any host pointer can be shared across all the agents."]
pub type hsa_profile_t = ::std::os::raw::c_uint;
#[doc = " Major version of the HSA runtime specification supported by the\n implementation. The type of this attribute is uint16_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_VERSION_MAJOR: hsa_system_info_t = 0;
#[doc = " Minor version of the HSA runtime specification supported by the\n implementation. The type of this attribute is uint16_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_VERSION_MINOR: hsa_system_info_t = 1;
#[doc = " Current timestamp. The value of this attribute monotonically increases at a\n constant rate. The type of this attribute is uint64_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_TIMESTAMP: hsa_system_info_t = 2;
#[doc = " Timestamp value increase rate, in Hz. The timestamp (clock) frequency is\n in the range 1-400MHz. The type of this attribute is uint64_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_TIMESTAMP_FREQUENCY: hsa_system_info_t = 3;
#[doc = " Maximum duration of a signal wait operation. Expressed as a count based on\n the timestamp frequency. The type of this attribute is uint64_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_SIGNAL_MAX_WAIT: hsa_system_info_t = 4;
#[doc = " Endianness of the system. The type of this attribute is ::hsa_endianness_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_ENDIANNESS: hsa_system_info_t = 5;
#[doc = " Machine model supported by the HSA runtime. The type of this attribute is\n ::hsa_machine_model_t."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_MACHINE_MODEL: hsa_system_info_t = 6;
#[doc = " Bit-mask indicating which extensions are supported by the\n implementation. An extension with an ID of @p i is supported if the bit at\n position @p i is set. The type of this attribute is uint8_t[128]."]
pub const hsa_system_info_t_HSA_SYSTEM_INFO_EXTENSIONS: hsa_system_info_t = 7;
#[doc = " String containing the ROCr build identifier."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_BUILD_VERSION: hsa_system_info_t = 512;
#[doc = " Returns true if hsa_amd_svm_* APIs are supported by the driver.  The type of\n this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_SVM_SUPPORTED: hsa_system_info_t = 513;
#[doc = " Returns true if all Agents have access to system allocated memory (such as\n that allocated by mmap, malloc, or new) by default.\n If false then system allocated memory may only be made SVM accessible to\n an Agent by declaration of accessibility with hsa_amd_svm_set_attributes.\n The type of this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_SVM_ACCESSIBLE_BY_DEFAULT: hsa_system_info_t = 514;
#[doc = " Returns true if mwaitx is enabled on this system\n The type of this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_MWAITX_ENABLED: hsa_system_info_t = 515;
#[doc = " Returns true if DMABUF APIs are supported by the driver.  The type of\n this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_DMABUF_SUPPORTED: hsa_system_info_t = 516;
#[doc = " Returns true if Virtual Memory APIs are supported by the driver.  The type of\n this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_VIRTUAL_MEM_API_SUPPORTED: hsa_system_info_t = 517;
#[doc = " Returns true if XNACK is enabled on this system.  The type of\n this attribute is bool."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_XNACK_ENABLED: hsa_system_info_t = 518;
#[doc = " Major version of the HSA runtime extension specification supported by the\n implementation. The type of this attribute is uint16_t."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_EXT_VERSION_MAJOR: hsa_system_info_t = 519;
#[doc = " Minor version of the HSA runtime extension specification supported by the\n implementation. The type of this attribute is uint16_t."]
pub const hsa_system_info_t_HSA_AMD_SYSTEM_INFO_EXT_VERSION_MINOR: hsa_system_info_t = 520;
#[doc = " @brief System attributes."]
pub type hsa_system_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of a system attribute.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n system attribute, or @p value is NULL."]
    pub fn hsa_system_get_info(
        attribute: hsa_system_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " Finalizer extension."]
pub const hsa_extension_t_HSA_EXTENSION_FINALIZER: hsa_extension_t = 0;
#[doc = " Images extension."]
pub const hsa_extension_t_HSA_EXTENSION_IMAGES: hsa_extension_t = 1;
#[doc = " Performance counter extension."]
pub const hsa_extension_t_HSA_EXTENSION_PERFORMANCE_COUNTERS: hsa_extension_t = 2;
#[doc = " Profiling events extension."]
pub const hsa_extension_t_HSA_EXTENSION_PROFILING_EVENTS: hsa_extension_t = 3;
#[doc = " Extension count."]
pub const hsa_extension_t_HSA_EXTENSION_STD_LAST: hsa_extension_t = 3;
#[doc = " First AMD extension number."]
pub const hsa_extension_t_HSA_AMD_FIRST_EXTENSION: hsa_extension_t = 512;
#[doc = " Profiler extension."]
pub const hsa_extension_t_HSA_EXTENSION_AMD_PROFILER: hsa_extension_t = 512;
#[doc = " Loader extension."]
pub const hsa_extension_t_HSA_EXTENSION_AMD_LOADER: hsa_extension_t = 513;
#[doc = " AqlProfile extension."]
pub const hsa_extension_t_HSA_EXTENSION_AMD_AQLPROFILE: hsa_extension_t = 514;
#[doc = " PC Sampling extension."]
pub const hsa_extension_t_HSA_EXTENSION_AMD_PC_SAMPLING: hsa_extension_t = 515;
#[doc = " Last AMD extension."]
pub const hsa_extension_t_HSA_AMD_LAST_EXTENSION: hsa_extension_t = 515;
#[doc = " @brief HSA extensions."]
pub type hsa_extension_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Query the name of a given extension.\n\n @param[in] extension Extension identifier. If the extension is not supported\n by the implementation (see ::HSA_SYSTEM_INFO_EXTENSIONS), the behavior\n is undefined.\n\n @param[out] name Pointer to a memory location where the HSA runtime stores\n the extension name. The extension name is a NUL-terminated string.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p name is NULL."]
    pub fn hsa_extension_get_name(
        extension: u16,
        name: *mut *const ::std::os::raw::c_char,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Query if a given version of an extension is supported by the HSA\n implementation.\n\n @param[in] extension Extension identifier.\n\n @param[in] version_major Major version number.\n\n @param[in] version_minor Minor version number.\n\n @param[out] result Pointer to a memory location where the HSA runtime stores\n the result of the check. The result is true if the specified version of the\n extension is supported, and false otherwise.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p result is NULL."]
    pub fn hsa_system_extension_supported(
        extension: u16,
        version_major: u16,
        version_minor: u16,
        result: *mut bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Query if a given version of an extension is supported by the HSA\n implementation. All minor versions from 0 up to the returned @p version_minor\n must be supported by the implementation.\n\n @param[in] extension Extension identifier.\n\n @param[in] version_major Major version number.\n\n @param[out] version_minor Minor version number.\n\n @param[out] result Pointer to a memory location where the HSA runtime stores\n the result of the check. The result is true if the specified version of the\n extension is supported, and false otherwise.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p version_minor is NULL, or @p result is NULL."]
    pub fn hsa_system_major_extension_supported(
        extension: u16,
        version_major: u16,
        version_minor: *mut u16,
        result: *mut bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Retrieve the function pointers corresponding to a given version of an\n extension. Portable applications are expected to invoke the extension API\n using the returned function pointers\n\n @details The application is responsible for verifying that the given version\n of the extension is supported by the HSA implementation (see\n ::hsa_system_extension_supported). If the given combination of extension,\n major version, and minor version is not supported by the implementation, the\n behavior is undefined.\n\n @param[in] extension Extension identifier.\n\n @param[in] version_major Major version number for which to retrieve the\n function pointer table.\n\n @param[in] version_minor Minor version number for which to retrieve the\n function pointer table.\n\n @param[out] table Pointer to an application-allocated function pointer table\n that is populated by the HSA runtime. Must not be NULL. The memory associated\n with table can be reused or freed after the function returns.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p table is NULL."]
    pub fn hsa_system_get_extension_table(
        extension: u16,
        version_major: u16,
        version_minor: u16,
        table: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the function pointers corresponding to a given major version\n of an extension. Portable applications are expected to invoke the extension\n API using the returned function pointers.\n\n @details The application is responsible for verifying that the given major\n version of the extension is supported by the HSA implementation (see\n ::hsa_system_major_extension_supported). If the given combination of extension\n and major version is not supported by the implementation, the behavior is\n undefined. Additionally if the length doesn't allow space for a full minor\n version, it is implementation defined if only some of the function pointers for\n that minor version get written.\n\n @param[in] extension Extension identifier.\n\n @param[in] version_major Major version number for which to retrieve the\n function pointer table.\n\n @param[in] table_length Size in bytes of the function pointer table to be\n populated. The implementation will not write more than this many bytes to the\n table.\n\n @param[out] table Pointer to an application-allocated function pointer table\n that is populated by the HSA runtime. Must not be NULL. The memory associated\n with table can be reused or freed after the function returns.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p table is NULL."]
    pub fn hsa_system_get_major_extension_table(
        extension: u16,
        version_major: u16,
        table_length: usize,
        table: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " @brief Struct containing an opaque handle to an agent, a device that participates in\n the HSA memory model. An agent can submit AQL packets for execution, and\n may also accept AQL packets for execution (agent dispatch packets or kernel\n dispatch packets launching HSAIL-derived binaries)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_agent_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_agent_s"][::std::mem::size_of::<hsa_agent_s>() - 8usize];
    ["Alignment of hsa_agent_s"][::std::mem::align_of::<hsa_agent_s>() - 8usize];
    ["Offset of field: hsa_agent_s::handle"][::std::mem::offset_of!(hsa_agent_s, handle) - 0usize];
};
#[doc = " @brief Struct containing an opaque handle to an agent, a device that participates in\n the HSA memory model. An agent can submit AQL packets for execution, and\n may also accept AQL packets for execution (agent dispatch packets or kernel\n dispatch packets launching HSAIL-derived binaries)."]
pub type hsa_agent_t = hsa_agent_s;
#[doc = " The agent supports AQL packets of kernel dispatch type. If this\n feature is enabled, the agent is also a kernel agent."]
pub const hsa_agent_feature_t_HSA_AGENT_FEATURE_KERNEL_DISPATCH: hsa_agent_feature_t = 1;
#[doc = " The agent supports AQL packets of agent dispatch type."]
pub const hsa_agent_feature_t_HSA_AGENT_FEATURE_AGENT_DISPATCH: hsa_agent_feature_t = 2;
#[doc = " @brief Agent features."]
pub type hsa_agent_feature_t = ::std::os::raw::c_uint;
#[doc = " CPU device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_CPU: hsa_device_type_t = 0;
#[doc = " GPU device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_GPU: hsa_device_type_t = 1;
#[doc = " DSP device."]
pub const hsa_device_type_t_HSA_DEVICE_TYPE_DSP: hsa_device_type_t = 2;
#[doc = " @brief Hardware device type."]
pub type hsa_device_type_t = ::std::os::raw::c_uint;
#[doc = " Use a default floating-point rounding mode specified elsewhere."]
pub const hsa_default_float_rounding_mode_t_HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT:
    hsa_default_float_rounding_mode_t = 0;
#[doc = " Operations that specify the default floating-point mode are rounded to zero\n by default."]
pub const hsa_default_float_rounding_mode_t_HSA_DEFAULT_FLOAT_ROUNDING_MODE_ZERO:
    hsa_default_float_rounding_mode_t = 1;
#[doc = " Operations that specify the default floating-point mode are rounded to the\n nearest representable number and that ties should be broken by selecting\n the value with an even least significant bit."]
pub const hsa_default_float_rounding_mode_t_HSA_DEFAULT_FLOAT_ROUNDING_MODE_NEAR:
    hsa_default_float_rounding_mode_t = 2;
#[doc = " @brief Default floating-point rounding mode."]
pub type hsa_default_float_rounding_mode_t = ::std::os::raw::c_uint;
#[doc = " Agent name. The type of this attribute is a NUL-terminated char[64]. The\n name must be at most 63 characters long (not including the NUL terminator)\n and all array elements not used for the name must be NUL."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_NAME: hsa_agent_info_t = 0;
#[doc = " Name of vendor. The type of this attribute is a NUL-terminated char[64].\n The name must be at most 63 characters long (not including the NUL\n terminator) and all array elements not used for the name must be NUL."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_VENDOR_NAME: hsa_agent_info_t = 1;
#[doc = " Agent capability. The type of this attribute is ::hsa_agent_feature_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_FEATURE: hsa_agent_info_t = 2;
#[doc = " @deprecated Query ::HSA_ISA_INFO_MACHINE_MODELS for a given intruction set\n architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Machine model supported by the agent. The type of this attribute is\n ::hsa_machine_model_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_MACHINE_MODEL: hsa_agent_info_t = 3;
#[doc = " @deprecated Query ::HSA_ISA_INFO_PROFILES for a given intruction set\n architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Profile supported by the agent. The type of this attribute is\n ::hsa_profile_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_PROFILE: hsa_agent_info_t = 4;
#[doc = " @deprecated Query ::HSA_ISA_INFO_DEFAULT_FLOAT_ROUNDING_MODES for a given\n intruction set architecture supported by the agent instead.  If more than\n one ISA is supported by the agent, the returned value corresponds to the\n first ISA enumerated by ::hsa_agent_iterate_isas.\n\n Default floating-point rounding mode. The type of this attribute is\n ::hsa_default_float_rounding_mode_t, but the value\n ::HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT is not allowed."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_DEFAULT_FLOAT_ROUNDING_MODE: hsa_agent_info_t = 5;
#[doc = " @deprecated Query ::HSA_ISA_INFO_BASE_PROFILE_DEFAULT_FLOAT_ROUNDING_MODES\n for a given intruction set architecture supported by the agent instead.  If\n more than one ISA is supported by the agent, the returned value corresponds\n to the first ISA enumerated by ::hsa_agent_iterate_isas.\n\n A bit-mask of ::hsa_default_float_rounding_mode_t values, representing the\n default floating-point rounding modes supported by the agent in the Base\n profile. The type of this attribute is uint32_t. The default floating-point\n rounding mode (::HSA_AGENT_INFO_DEFAULT_FLOAT_ROUNDING_MODE) bit must not\n be set."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_BASE_PROFILE_DEFAULT_FLOAT_ROUNDING_MODES:
    hsa_agent_info_t = 23;
#[doc = " @deprecated Query ::HSA_ISA_INFO_FAST_F16_OPERATION for a given intruction\n set architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Flag indicating that the f16 HSAIL operation is at least as fast as the\n f32 operation in the current agent. The value of this attribute is\n undefined if the agent is not a kernel agent. The type of this\n attribute is bool."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_FAST_F16_OPERATION: hsa_agent_info_t = 24;
#[doc = " @deprecated Query ::HSA_WAVEFRONT_INFO_SIZE for a given wavefront and\n intruction set architecture supported by the agent instead.  If more than\n one ISA is supported by the agent, the returned value corresponds to the\n first ISA enumerated by ::hsa_agent_iterate_isas and the first wavefront\n enumerated by ::hsa_isa_iterate_wavefronts for that ISA.\n\n Number of work-items in a wavefront. Must be a power of 2 in the range\n [1,256]. The value of this attribute is undefined if the agent is not\n a kernel agent. The type of this attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_WAVEFRONT_SIZE: hsa_agent_info_t = 6;
#[doc = " @deprecated Query ::HSA_ISA_INFO_WORKGROUP_MAX_DIM for a given intruction\n set architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Maximum number of work-items of each dimension of a work-group.  Each\n maximum must be greater than 0. No maximum can exceed the value of\n ::HSA_AGENT_INFO_WORKGROUP_MAX_SIZE. The value of this attribute is\n undefined if the agent is not a kernel agent. The type of this\n attribute is uint16_t[3]."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_WORKGROUP_MAX_DIM: hsa_agent_info_t = 7;
#[doc = " @deprecated Query ::HSA_ISA_INFO_WORKGROUP_MAX_SIZE for a given intruction\n set architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Maximum total number of work-items in a work-group. The value of this\n attribute is undefined if the agent is not a kernel agent. The type\n of this attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_WORKGROUP_MAX_SIZE: hsa_agent_info_t = 8;
#[doc = " @deprecated Query ::HSA_ISA_INFO_GRID_MAX_DIM for a given intruction set\n architecture supported by the agent instead.\n\n Maximum number of work-items of each dimension of a grid. Each maximum must\n be greater than 0, and must not be smaller than the corresponding value in\n ::HSA_AGENT_INFO_WORKGROUP_MAX_DIM. No maximum can exceed the value of\n ::HSA_AGENT_INFO_GRID_MAX_SIZE. The value of this attribute is undefined\n if the agent is not a kernel agent. The type of this attribute is\n ::hsa_dim3_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_GRID_MAX_DIM: hsa_agent_info_t = 9;
#[doc = " @deprecated Query ::HSA_ISA_INFO_GRID_MAX_SIZE for a given intruction set\n architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Maximum total number of work-items in a grid. The value of this attribute\n is undefined if the agent is not a kernel agent. The type of this\n attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_GRID_MAX_SIZE: hsa_agent_info_t = 10;
#[doc = " @deprecated Query ::HSA_ISA_INFO_FBARRIER_MAX_SIZE for a given intruction\n set architecture supported by the agent instead.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Maximum number of fbarriers per work-group. Must be at least 32. The value\n of this attribute is undefined if the agent is not a kernel agent. The\n type of this attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_FBARRIER_MAX_SIZE: hsa_agent_info_t = 11;
#[doc = " @deprecated The maximum number of queues is not statically determined.\n\n Maximum number of queues that can be active (created but not destroyed) at\n one time in the agent. The type of this attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_QUEUES_MAX: hsa_agent_info_t = 12;
#[doc = " Minimum number of packets that a queue created in the agent\n can hold. Must be a power of 2 greater than 0. Must not exceed\n the value of ::HSA_AGENT_INFO_QUEUE_MAX_SIZE. The type of this\n attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_QUEUE_MIN_SIZE: hsa_agent_info_t = 13;
#[doc = " Maximum number of packets that a queue created in the agent can\n hold. Must be a power of 2 greater than 0. The type of this attribute\n is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_QUEUE_MAX_SIZE: hsa_agent_info_t = 14;
#[doc = " Type of a queue created in the agent. The type of this attribute is\n ::hsa_queue_type32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_QUEUE_TYPE: hsa_agent_info_t = 15;
#[doc = " @deprecated NUMA information is not exposed anywhere else in the API.\n\n Identifier of the NUMA node associated with the agent. The type of this\n attribute is uint32_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_NODE: hsa_agent_info_t = 16;
#[doc = " Type of hardware device associated with the agent. The type of this\n attribute is ::hsa_device_type_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_DEVICE: hsa_agent_info_t = 17;
#[doc = " @deprecated Query ::hsa_agent_iterate_caches to retrieve information about\n the caches present in a given agent.\n\n Array of data cache sizes (L1..L4). Each size is expressed in bytes. A size\n of 0 for a particular level indicates that there is no cache information\n for that level. The type of this attribute is uint32_t[4]."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_CACHE_SIZE: hsa_agent_info_t = 18;
#[doc = " @deprecated An agent may support multiple instruction set\n architectures. See ::hsa_agent_iterate_isas.  If more than one ISA is\n supported by the agent, the returned value corresponds to the first ISA\n enumerated by ::hsa_agent_iterate_isas.\n\n Instruction set architecture of the agent. The type of this attribute\n is ::hsa_isa_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_ISA: hsa_agent_info_t = 19;
#[doc = " Bit-mask indicating which extensions are supported by the agent. An\n extension with an ID of @p i is supported if the bit at position @p i is\n set. The type of this attribute is uint8_t[128]."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_EXTENSIONS: hsa_agent_info_t = 20;
#[doc = " Major version of the HSA runtime specification supported by the\n agent. The type of this attribute is uint16_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_VERSION_MAJOR: hsa_agent_info_t = 21;
#[doc = " Minor version of the HSA runtime specification supported by the\n agent. The type of this attribute is uint16_t."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_VERSION_MINOR: hsa_agent_info_t = 22;
#[doc = " This enum does not have a fixed underlying type, thus in C++ post D2338:\n If the enumeration type does not have a fixed underlying type, the value is\n unchanged if the original value is within the range of the enumeration\n values (9.7.1 [dcl.enum]), and otherwise, the behavior is\n undefined.\n Thus increase the range of this enum to encompass vendor extensions."]
pub const hsa_agent_info_t_HSA_AGENT_INFO_LAST: hsa_agent_info_t = 2147483647;
#[doc = " @brief Agent attributes."]
pub type hsa_agent_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute for a given agent.\n\n @param[in] agent A valid agent.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n agent attribute, or @p value is NULL."]
    pub fn hsa_agent_get_info(
        agent: hsa_agent_t,
        attribute: hsa_agent_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the available agents, and invoke an\n application-defined callback on every iteration.\n\n @param[in] callback Callback to be invoked once per agent. The HSA\n runtime passes two arguments to the callback: the agent and the\n application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n ::hsa_iterate_agents returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_iterate_agents(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                agent: hsa_agent_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " If a hardware exception is detected, a work-item signals an exception."]
pub const hsa_exception_policy_t_HSA_EXCEPTION_POLICY_BREAK: hsa_exception_policy_t = 1;
#[doc = " If a hardware exception is detected, a hardware status bit is set."]
pub const hsa_exception_policy_t_HSA_EXCEPTION_POLICY_DETECT: hsa_exception_policy_t = 2;
#[doc = " @brief Exception policies applied in the presence of hardware exceptions."]
pub type hsa_exception_policy_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @deprecated Use ::hsa_isa_get_exception_policies for a given intruction set\n architecture supported by the agent instead. If more than one ISA is\n supported by the agent, this function uses the first value returned by\n ::hsa_agent_iterate_isas.\n\n @brief Retrieve the exception policy support for a given combination of\n agent and profile\n\n @param[in] agent Agent.\n\n @param[in] profile Profile.\n\n @param[out] mask Pointer to a memory location where the HSA runtime stores a\n mask of ::hsa_exception_policy_t values. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p profile is not a valid\n profile, or @p mask is NULL.\n"]
    pub fn hsa_agent_get_exception_policies(
        agent: hsa_agent_t,
        profile: hsa_profile_t,
        mask: *mut u16,
    ) -> hsa_status_t;
}
#[doc = " @brief Cache handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_cache_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_cache_s"][::std::mem::size_of::<hsa_cache_s>() - 8usize];
    ["Alignment of hsa_cache_s"][::std::mem::align_of::<hsa_cache_s>() - 8usize];
    ["Offset of field: hsa_cache_s::handle"][::std::mem::offset_of!(hsa_cache_s, handle) - 0usize];
};
#[doc = " @brief Cache handle."]
pub type hsa_cache_t = hsa_cache_s;
#[doc = " The length of the cache name in bytes, not including the NUL terminator.\n The type of this attribute is uint32_t."]
pub const hsa_cache_info_t_HSA_CACHE_INFO_NAME_LENGTH: hsa_cache_info_t = 0;
#[doc = " Human-readable description.  The type of this attribute is a NUL-terminated\n character array with the length equal to the value of\n ::HSA_CACHE_INFO_NAME_LENGTH attribute."]
pub const hsa_cache_info_t_HSA_CACHE_INFO_NAME: hsa_cache_info_t = 1;
#[doc = " Cache level. A L1 cache must return a value of 1, a L2 must return a value\n of 2, and so on.  The type of this attribute is uint8_t."]
pub const hsa_cache_info_t_HSA_CACHE_INFO_LEVEL: hsa_cache_info_t = 2;
#[doc = " Cache size, in bytes. A value of 0 indicates that there is no size\n information available. The type of this attribute is uint32_t."]
pub const hsa_cache_info_t_HSA_CACHE_INFO_SIZE: hsa_cache_info_t = 3;
#[doc = " @brief Cache attributes."]
pub type hsa_cache_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute for a given cache object.\n\n @param[in] cache Cache.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CACHE The cache is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n instruction set architecture attribute, or @p value is\n NULL."]
    pub fn hsa_cache_get_info(
        cache: hsa_cache_t,
        attribute: hsa_cache_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the memory caches of a given agent, and\n invoke an application-defined callback on every iteration.\n\n @details Caches are visited in ascending order according to the value of the\n ::HSA_CACHE_INFO_LEVEL attribute.\n\n @param[in] agent A valid agent.\n\n @param[in] callback Callback to be invoked once per cache that is present in\n the agent.  The HSA runtime passes two arguments to the callback: the cache\n and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n that value is returned.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_agent_iterate_caches(
        agent: hsa_agent_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cache: hsa_cache_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Query if a given version of an extension is supported by an agent\n\n @param[in] extension Extension identifier.\n\n @param[in] agent Agent.\n\n @param[in] version_major Major version number.\n\n @param[in] version_minor Minor version number.\n\n @param[out] result Pointer to a memory location where the HSA runtime stores\n the result of the check. The result is true if the specified version of the\n extension is supported, and false otherwise. The result must be false if\n ::hsa_system_extension_supported returns false for the same extension\n version.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p result is NULL."]
    pub fn hsa_agent_extension_supported(
        extension: u16,
        agent: hsa_agent_t,
        version_major: u16,
        version_minor: u16,
        result: *mut bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Query if a given version of an extension is supported by an agent. All\n minor versions from 0 up to the returned @p version_minor must be supported.\n\n @param[in] extension Extension identifier.\n\n @param[in] agent Agent.\n\n @param[in] version_major Major version number.\n\n @param[out] version_minor Minor version number.\n\n @param[out] result Pointer to a memory location where the HSA runtime stores\n the result of the check. The result is true if the specified version of the\n extension is supported, and false otherwise. The result must be false if\n ::hsa_system_extension_supported returns false for the same extension\n version.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p extension is not a valid\n extension, or @p version_minor is NULL, or @p result is NULL."]
    pub fn hsa_agent_major_extension_supported(
        extension: u16,
        agent: hsa_agent_t,
        version_major: u16,
        version_minor: *mut u16,
        result: *mut bool,
    ) -> hsa_status_t;
}
#[doc = " @brief Signal handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_signal_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal. The value 0 is reserved."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_signal_s"][::std::mem::size_of::<hsa_signal_s>() - 8usize];
    ["Alignment of hsa_signal_s"][::std::mem::align_of::<hsa_signal_s>() - 8usize];
    ["Offset of field: hsa_signal_s::handle"]
        [::std::mem::offset_of!(hsa_signal_s, handle) - 0usize];
};
#[doc = " @brief Signal handle."]
pub type hsa_signal_t = hsa_signal_s;
pub type hsa_signal_value_t = i64;
unsafe extern "C" {
    #[doc = " @brief Create a signal.\n\n @param[in] initial_value Initial value of the signal.\n\n @param[in] num_consumers Size of @p consumers. A value of 0 indicates that\n any agent might wait on the signal.\n\n @param[in] consumers List of agents that might consume (wait on) the\n signal. If @p num_consumers is 0, this argument is ignored; otherwise, the\n HSA runtime might use the list to optimize the handling of the signal\n object. If an agent not listed in @p consumers waits on the returned\n signal, the behavior is undefined. The memory associated with @p consumers\n can be reused or freed after the function returns.\n\n @param[out] signal Pointer to a memory location where the HSA runtime will\n store the newly created signal handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p signal is NULL, @p\n num_consumers is greater than 0 but @p consumers is NULL, or @p consumers\n contains duplicates."]
    pub fn hsa_signal_create(
        initial_value: hsa_signal_value_t,
        num_consumers: u32,
        consumers: *const hsa_agent_t,
        signal: *mut hsa_signal_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a signal previous created by ::hsa_signal_create.\n\n @param[in] signal Signal.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL @p signal is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The handle in @p signal is 0."]
    pub fn hsa_signal_destroy(signal: hsa_signal_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Atomically read the current value of a signal.\n\n @param[in] signal Signal.\n\n @return Value of the signal."]
    pub fn hsa_signal_load_scacquire(signal: hsa_signal_t) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_load_scacquire"]
    pub fn hsa_signal_load_relaxed(signal: hsa_signal_t) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_load_scacquire.\n\n @copydoc hsa_signal_load_scacquire"]
    pub fn hsa_signal_load_acquire(signal: hsa_signal_t) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the value of a signal.\n\n @details If the value of the signal is changed, all the agents waiting\n on @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal.\n\n @param[in] value New signal value."]
    pub fn hsa_signal_store_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_store_relaxed"]
    pub fn hsa_signal_store_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_store_screlease.\n\n @copydoc hsa_signal_store_screlease"]
    pub fn hsa_signal_store_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the value of a signal without necessarily notifying the\n the agents waiting on it.\n\n @details The agents waiting on @p signal may not wake up even when the new\n value satisfies their wait condition. If the application wants to update the\n signal and there is no need to notify any agent, invoking this function can\n be more efficient than calling the non-silent counterpart.\n\n @param[in] signal Signal.\n\n @param[in] value New signal value."]
    pub fn hsa_signal_silent_store_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_silent_store_relaxed"]
    pub fn hsa_signal_silent_store_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the value of a signal and return its previous value.\n\n @details If the value of the signal is changed, all the agents waiting\n on @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value New value.\n\n @return Value of the signal prior to the exchange.\n"]
    pub fn hsa_signal_exchange_scacq_screl(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_exchange_scacq_screl.\n\n @copydoc hsa_signal_exchange_scacq_screl"]
    pub fn hsa_signal_exchange_acq_rel(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_exchange_scacq_screl"]
    pub fn hsa_signal_exchange_scacquire(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_exchange_scacquire.\n\n @copydoc hsa_signal_exchange_scacquire"]
    pub fn hsa_signal_exchange_acquire(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_exchange_scacq_screl"]
    pub fn hsa_signal_exchange_relaxed(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_exchange_scacq_screl"]
    pub fn hsa_signal_exchange_screlease(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_exchange_screlease.\n\n @copydoc hsa_signal_exchange_screlease"]
    pub fn hsa_signal_exchange_release(
        signal: hsa_signal_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the value of a signal if the observed value is equal to\n the expected value. The observed value is returned regardless of whether the\n replacement was done.\n\n @details If the value of the signal is changed, all the agents waiting\n on @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue\n doorbell signal, the behavior is undefined.\n\n @param[in] expected Value to compare with.\n\n @param[in] value New value.\n\n @return Observed value of the signal.\n"]
    pub fn hsa_signal_cas_scacq_screl(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_cas_scacq_screl.\n\n @copydoc hsa_signal_cas_scacq_screl"]
    pub fn hsa_signal_cas_acq_rel(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_cas_scacq_screl"]
    pub fn hsa_signal_cas_scacquire(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_cas_scacquire.\n\n @copydoc hsa_signal_cas_scacquire"]
    pub fn hsa_signal_cas_acquire(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_cas_scacq_screl"]
    pub fn hsa_signal_cas_relaxed(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_cas_scacq_screl"]
    pub fn hsa_signal_cas_screlease(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_cas_screlease.\n\n @copydoc hsa_signal_cas_screlease"]
    pub fn hsa_signal_cas_release(
        signal: hsa_signal_t,
        expected: hsa_signal_value_t,
        value: hsa_signal_value_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @brief Atomically increment the value of a signal by a given amount.\n\n @details If the value of the signal is changed, all the agents waiting on\n @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value Value to add to the value of the signal.\n"]
    pub fn hsa_signal_add_scacq_screl(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_add_scacq_screl.\n\n @copydoc hsa_signal_add_scacq_screl"]
    pub fn hsa_signal_add_acq_rel(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_add_scacq_screl"]
    pub fn hsa_signal_add_scacquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_add_scacquire.\n\n @copydoc hsa_signal_add_scacquire"]
    pub fn hsa_signal_add_acquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_add_scacq_screl"]
    pub fn hsa_signal_add_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_add_scacq_screl"]
    pub fn hsa_signal_add_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_add_screlease.\n\n @copydoc hsa_signal_add_screlease"]
    pub fn hsa_signal_add_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically decrement the value of a signal by a given amount.\n\n @details If the value of the signal is changed, all the agents waiting on\n @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value Value to subtract from the value of the signal.\n"]
    pub fn hsa_signal_subtract_scacq_screl(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_subtract_scacq_screl.\n\n @copydoc hsa_signal_subtract_scacq_screl"]
    pub fn hsa_signal_subtract_acq_rel(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_subtract_scacq_screl"]
    pub fn hsa_signal_subtract_scacquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_subtract_scacquire.\n\n @copydoc hsa_signal_subtract_scacquire"]
    pub fn hsa_signal_subtract_acquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_subtract_scacq_screl"]
    pub fn hsa_signal_subtract_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_subtract_scacq_screl"]
    pub fn hsa_signal_subtract_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_subtract_screlease.\n\n @copydoc hsa_signal_subtract_screlease"]
    pub fn hsa_signal_subtract_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically perform a bitwise AND operation between the value of a\n signal and a given value.\n\n @details If the value of the signal is changed, all the agents waiting on\n @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value Value to AND with the value of the signal.\n"]
    pub fn hsa_signal_and_scacq_screl(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_and_scacq_screl.\n\n @copydoc hsa_signal_and_scacq_screl"]
    pub fn hsa_signal_and_acq_rel(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_and_scacq_screl"]
    pub fn hsa_signal_and_scacquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_and_scacquire.\n\n @copydoc hsa_signal_and_scacquire"]
    pub fn hsa_signal_and_acquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_and_scacq_screl"]
    pub fn hsa_signal_and_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_and_scacq_screl"]
    pub fn hsa_signal_and_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_and_screlease.\n\n @copydoc hsa_signal_and_screlease"]
    pub fn hsa_signal_and_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically perform a bitwise OR operation between the value of a\n signal and a given value.\n\n @details If the value of the signal is changed, all the agents waiting on\n @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value Value to OR with the value of the signal."]
    pub fn hsa_signal_or_scacq_screl(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_or_scacq_screl.\n\n @copydoc hsa_signal_or_scacq_screl"]
    pub fn hsa_signal_or_acq_rel(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_or_scacq_screl"]
    pub fn hsa_signal_or_scacquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_or_scacquire.\n\n @copydoc hsa_signal_or_scacquire"]
    pub fn hsa_signal_or_acquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_or_scacq_screl"]
    pub fn hsa_signal_or_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_or_scacq_screl"]
    pub fn hsa_signal_or_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_or_screlease.\n\n @copydoc hsa_signal_or_screlease"]
    pub fn hsa_signal_or_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @brief Atomically perform a bitwise XOR operation between the value of a\n signal and a given value.\n\n @details If the value of the signal is changed, all the agents waiting on\n @p signal for which @p value satisfies their wait condition are awakened.\n\n @param[in] signal Signal. If @p signal is a queue doorbell signal, the\n behavior is undefined.\n\n @param[in] value Value to XOR with the value of the signal.\n"]
    pub fn hsa_signal_xor_scacq_screl(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_xor_scacq_screl.\n\n @copydoc hsa_signal_xor_scacq_screl"]
    pub fn hsa_signal_xor_acq_rel(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_xor_scacq_screl"]
    pub fn hsa_signal_xor_scacquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_xor_scacquire.\n\n @copydoc hsa_signal_xor_scacquire"]
    pub fn hsa_signal_xor_acquire(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_xor_scacq_screl"]
    pub fn hsa_signal_xor_relaxed(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_xor_scacq_screl"]
    pub fn hsa_signal_xor_screlease(signal: hsa_signal_t, value: hsa_signal_value_t);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_xor_screlease.\n\n @copydoc hsa_signal_xor_screlease"]
    pub fn hsa_signal_xor_release(signal: hsa_signal_t, value: hsa_signal_value_t);
}
#[doc = " The two operands are equal."]
pub const hsa_signal_condition_t_HSA_SIGNAL_CONDITION_EQ: hsa_signal_condition_t = 0;
#[doc = " The two operands are not equal."]
pub const hsa_signal_condition_t_HSA_SIGNAL_CONDITION_NE: hsa_signal_condition_t = 1;
#[doc = " The first operand is less than the second operand."]
pub const hsa_signal_condition_t_HSA_SIGNAL_CONDITION_LT: hsa_signal_condition_t = 2;
#[doc = " The first operand is greater than or equal to the second operand."]
pub const hsa_signal_condition_t_HSA_SIGNAL_CONDITION_GTE: hsa_signal_condition_t = 3;
#[doc = " @brief Wait condition operator."]
pub type hsa_signal_condition_t = ::std::os::raw::c_uint;
#[doc = " The application thread may be rescheduled while waiting on the signal."]
pub const hsa_wait_state_t_HSA_WAIT_STATE_BLOCKED: hsa_wait_state_t = 0;
#[doc = " The application thread stays active while waiting on a signal."]
pub const hsa_wait_state_t_HSA_WAIT_STATE_ACTIVE: hsa_wait_state_t = 1;
#[doc = " @brief State of the application thread during a signal wait."]
pub type hsa_wait_state_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Wait until a signal value satisfies a specified condition, or a\n certain amount of time has elapsed.\n\n @details A wait operation can spuriously resume at any time sooner than the\n timeout (for example, due to system or other external factors) even when the\n condition has not been met.\n\n The function is guaranteed to return if the signal value satisfies the\n condition at some point in time during the wait, but the value returned to\n the application might not satisfy the condition. The application must ensure\n that signals are used in such way that wait wakeup conditions are not\n invalidated before dependent threads have woken up.\n\n When the wait operation internally loads the value of the passed signal, it\n uses the memory order indicated in the function name.\n\n @param[in] signal Signal.\n\n @param[in] condition Condition used to compare the signal value with @p\n compare_value.\n\n @param[in] compare_value Value to compare with.\n\n @param[in] timeout_hint Maximum duration of the wait.  Specified in the same\n unit as the system timestamp. The operation might block for a shorter or\n longer time even if the condition is not met. A value of UINT64_MAX indicates\n no maximum.\n\n @param[in] wait_state_hint Hint used by the application to indicate the\n preferred waiting state. The actual waiting state is ultimately decided by\n HSA runtime and may not match the provided hint. A value of\n ::HSA_WAIT_STATE_ACTIVE may improve the latency of response to a signal\n update by avoiding rescheduling overhead.\n\n @return Observed value of the signal, which might not satisfy the specified\n condition."]
    pub fn hsa_signal_wait_scacquire(
        signal: hsa_signal_t,
        condition: hsa_signal_condition_t,
        compare_value: hsa_signal_value_t,
        timeout_hint: u64,
        wait_state_hint: hsa_wait_state_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_wait_scacquire"]
    pub fn hsa_signal_wait_relaxed(
        signal: hsa_signal_t,
        condition: hsa_signal_condition_t,
        compare_value: hsa_signal_value_t,
        timeout_hint: u64,
        wait_state_hint: hsa_wait_state_t,
    ) -> hsa_signal_value_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_signal_wait_scacquire.\n\n @copydoc hsa_signal_wait_scacquire"]
    pub fn hsa_signal_wait_acquire(
        signal: hsa_signal_t,
        condition: hsa_signal_condition_t,
        compare_value: hsa_signal_value_t,
        timeout_hint: u64,
        wait_state_hint: hsa_wait_state_t,
    ) -> hsa_signal_value_t;
}
#[doc = " @brief Group of signals."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_signal_group_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_signal_group_s"][::std::mem::size_of::<hsa_signal_group_s>() - 8usize];
    ["Alignment of hsa_signal_group_s"][::std::mem::align_of::<hsa_signal_group_s>() - 8usize];
    ["Offset of field: hsa_signal_group_s::handle"]
        [::std::mem::offset_of!(hsa_signal_group_s, handle) - 0usize];
};
#[doc = " @brief Group of signals."]
pub type hsa_signal_group_t = hsa_signal_group_s;
unsafe extern "C" {
    #[doc = " @brief Create a signal group.\n\n @param[in] num_signals Number of elements in @p signals. Must not be 0.\n\n @param[in] signals List of signals in the group. The list must not contain\n any repeated elements. Must not be NULL.\n\n @param[in] num_consumers Number of elements in @p consumers. Must not be 0.\n\n @param[in] consumers List of agents that might consume (wait on) the signal\n group. The list must not contain repeated elements, and must be a subset of\n the set of agents that are allowed to wait on all the signals in the\n group. If an agent not listed in @p consumers waits on the returned group,\n the behavior is undefined. The memory associated with @p consumers can be\n reused or freed after the function returns. Must not be NULL.\n\n @param[out] signal_group Pointer to newly created signal group. Must not be\n NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_signals is 0, @p signals\n is NULL, @p num_consumers is 0, @p consumers is NULL, or @p signal_group is\n NULL."]
    pub fn hsa_signal_group_create(
        num_signals: u32,
        signals: *const hsa_signal_t,
        num_consumers: u32,
        consumers: *const hsa_agent_t,
        signal_group: *mut hsa_signal_group_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a signal group previous created by ::hsa_signal_group_create.\n\n @param[in] signal_group Signal group.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL_GROUP @p signal_group is invalid."]
    pub fn hsa_signal_group_destroy(signal_group: hsa_signal_group_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Wait until the value of at least one of the signals in a signal group\n satisfies its associated condition.\n\n @details The function is guaranteed to return if the value of at least one of\n the signals in the group satisfies its associated condition at some point in\n time during the wait, but the signal value returned to the application may no\n longer satisfy the condition. The application must ensure that signals in the\n group are used in such way that wait wakeup conditions are not invalidated\n before dependent threads have woken up.\n\n When this operation internally loads the value of the passed signal, it uses\n the memory order indicated in the function name.\n\n @param[in] signal_group Signal group.\n\n @param[in] conditions List of conditions. Each condition, and the value at\n the same index in @p compare_values, is used to compare the value of the\n signal at that index in @p signal_group (the signal passed by the application\n to ::hsa_signal_group_create at that particular index). The size of @p\n conditions must not be smaller than the number of signals in @p signal_group;\n any extra elements are ignored. Must not be NULL.\n\n @param[in] compare_values List of comparison values.  The size of @p\n compare_values must not be smaller than the number of signals in @p\n signal_group; any extra elements are ignored. Must not be NULL.\n\n @param[in] wait_state_hint Hint used by the application to indicate the\n preferred waiting state. The actual waiting state is decided by the HSA runtime\n and may not match the provided hint. A value of ::HSA_WAIT_STATE_ACTIVE may\n improve the latency of response to a signal update by avoiding rescheduling\n overhead.\n\n @param[out] signal Signal in the group that satisfied the associated\n condition. If several signals satisfied their condition, the function can\n return any of those signals. Must not be NULL.\n\n @param[out] value Observed value for @p signal, which might no longer satisfy\n the specified condition. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL_GROUP @p signal_group is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p conditions is NULL, @p\n compare_values is NULL, @p signal is NULL, or @p value is NULL."]
    pub fn hsa_signal_group_wait_any_scacquire(
        signal_group: hsa_signal_group_t,
        conditions: *const hsa_signal_condition_t,
        compare_values: *const hsa_signal_value_t,
        wait_state_hint: hsa_wait_state_t,
        signal: *mut hsa_signal_t,
        value: *mut hsa_signal_value_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_signal_group_wait_any_scacquire"]
    pub fn hsa_signal_group_wait_any_relaxed(
        signal_group: hsa_signal_group_t,
        conditions: *const hsa_signal_condition_t,
        compare_values: *const hsa_signal_value_t,
        wait_state_hint: hsa_wait_state_t,
        signal: *mut hsa_signal_t,
        value: *mut hsa_signal_value_t,
    ) -> hsa_status_t;
}
#[doc = " @brief A memory region represents a block of virtual memory with certain\n properties. For example, the HSA runtime represents fine-grained memory in\n the global segment using a region. A region might be associated with more\n than one agent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_region_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_region_s"][::std::mem::size_of::<hsa_region_s>() - 8usize];
    ["Alignment of hsa_region_s"][::std::mem::align_of::<hsa_region_s>() - 8usize];
    ["Offset of field: hsa_region_s::handle"]
        [::std::mem::offset_of!(hsa_region_s, handle) - 0usize];
};
#[doc = " @brief A memory region represents a block of virtual memory with certain\n properties. For example, the HSA runtime represents fine-grained memory in\n the global segment using a region. A region might be associated with more\n than one agent."]
pub type hsa_region_t = hsa_region_s;
#[doc = " Queue supports multiple producers. Use of multiproducer queue mechanics is\n required."]
pub const hsa_queue_type_t_HSA_QUEUE_TYPE_MULTI: hsa_queue_type_t = 0;
#[doc = " Queue only supports a single producer. In some scenarios, the application\n may want to limit the submission of AQL packets to a single agent. Queues\n that support a single producer may be more efficient than queues supporting\n multiple producers. Use of multiproducer queue mechanics is not supported."]
pub const hsa_queue_type_t_HSA_QUEUE_TYPE_SINGLE: hsa_queue_type_t = 1;
#[doc = " Queue supports multiple producers and cooperative dispatches. Cooperative\n dispatches are able to use GWS synchronization. Queues of this type may be\n limited in number. The runtime may return the same queue to serve multiple\n ::hsa_queue_create calls when this type is given. Callers must inspect the\n returned queue to discover queue size. Queues of this type are reference\n counted and require a matching number of ::hsa_queue_destroy calls to\n release. Use of multiproducer queue mechanics is required. See\n ::HSA_AMD_AGENT_INFO_COOPERATIVE_QUEUES to query agent support for this\n type."]
pub const hsa_queue_type_t_HSA_QUEUE_TYPE_COOPERATIVE: hsa_queue_type_t = 2;
#[doc = " @brief Queue type. Intended to be used for dynamic queue protocol\n determination."]
pub type hsa_queue_type_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_queue_type_t constants."]
pub type hsa_queue_type32_t = u32;
#[doc = " Queue supports kernel dispatch packets."]
pub const hsa_queue_feature_t_HSA_QUEUE_FEATURE_KERNEL_DISPATCH: hsa_queue_feature_t = 1;
#[doc = " Queue supports agent dispatch packets."]
pub const hsa_queue_feature_t_HSA_QUEUE_FEATURE_AGENT_DISPATCH: hsa_queue_feature_t = 2;
#[doc = " @brief Queue features."]
pub type hsa_queue_feature_t = ::std::os::raw::c_uint;
#[doc = " @brief User mode queue.\n\n @details The queue structure is read-only and allocated by the HSA runtime,\n but agents can directly modify the contents of the buffer pointed by @a\n base_address, or use HSA runtime APIs to access the doorbell signal.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_queue_s {
    #[doc = " Queue type."]
    pub type_: hsa_queue_type32_t,
    #[doc = " Queue features mask. This is a bit-field of ::hsa_queue_feature_t\n values. Applications should ignore any unknown set bits."]
    pub features: u32,
    pub base_address: *mut ::std::os::raw::c_void,
    #[doc = " Signal object used by the application to indicate the ID of a packet that\n is ready to be processed. The HSA runtime manages the doorbell signal. If\n the application tries to replace or destroy this signal, the behavior is\n undefined.\n\n If @a type is ::HSA_QUEUE_TYPE_SINGLE, the doorbell signal value must be\n updated in a monotonically increasing fashion. If @a type is\n ::HSA_QUEUE_TYPE_MULTI, the doorbell signal value can be updated with any\n value."]
    pub doorbell_signal: hsa_signal_t,
    #[doc = " Maximum number of packets the queue can hold. Must be a power of 2."]
    pub size: u32,
    #[doc = " Reserved. Must be 0."]
    pub reserved1: u32,
    #[doc = " Queue identifier, which is unique over the lifetime of the application."]
    pub id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_queue_s"][::std::mem::size_of::<hsa_queue_s>() - 40usize];
    ["Alignment of hsa_queue_s"][::std::mem::align_of::<hsa_queue_s>() - 8usize];
    ["Offset of field: hsa_queue_s::type_"][::std::mem::offset_of!(hsa_queue_s, type_) - 0usize];
    ["Offset of field: hsa_queue_s::features"]
        [::std::mem::offset_of!(hsa_queue_s, features) - 4usize];
    ["Offset of field: hsa_queue_s::base_address"]
        [::std::mem::offset_of!(hsa_queue_s, base_address) - 8usize];
    ["Offset of field: hsa_queue_s::doorbell_signal"]
        [::std::mem::offset_of!(hsa_queue_s, doorbell_signal) - 16usize];
    ["Offset of field: hsa_queue_s::size"][::std::mem::offset_of!(hsa_queue_s, size) - 24usize];
    ["Offset of field: hsa_queue_s::reserved1"]
        [::std::mem::offset_of!(hsa_queue_s, reserved1) - 28usize];
    ["Offset of field: hsa_queue_s::id"][::std::mem::offset_of!(hsa_queue_s, id) - 32usize];
};
#[doc = " @brief User mode queue.\n\n @details The queue structure is read-only and allocated by the HSA runtime,\n but agents can directly modify the contents of the buffer pointed by @a\n base_address, or use HSA runtime APIs to access the doorbell signal.\n"]
pub type hsa_queue_t = hsa_queue_s;
unsafe extern "C" {
    #[doc = " @brief Create a user mode queue.\n\n @details The HSA runtime creates the queue structure, the underlying packet\n buffer, the completion signal, and the write and read indexes. The initial\n value of the write and read indexes is 0. The type of every packet in the\n buffer is initialized to ::HSA_PACKET_TYPE_INVALID.\n\n The application should only rely on the error code returned to determine if\n the queue is valid.\n\n @param[in] agent Agent where to create the queue.\n\n @param[in] size Number of packets the queue is expected to\n hold. Must be a power of 2 between 1 and the value of\n ::HSA_AGENT_INFO_QUEUE_MAX_SIZE in @p agent. The size of the newly\n created queue is the maximum of @p size and the value of\n ::HSA_AGENT_INFO_QUEUE_MIN_SIZE in @p agent.\n\n @param[in] type Type of the queue, a bitwise OR of hsa_queue_type_t values.\n If the value of ::HSA_AGENT_INFO_QUEUE_TYPE in @p agent is ::HSA_QUEUE_TYPE_SINGLE,\n then @p type must also be ::HSA_QUEUE_TYPE_SINGLE.\n\n @param[in] callback Callback invoked by the HSA runtime for every\n asynchronous event related to the newly created queue. May be NULL. The HSA\n runtime passes three arguments to the callback: a code identifying the event\n that triggered the invocation, a pointer to the queue where the event\n originated, and the application data.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @param[in] private_segment_size Hint indicating the maximum\n expected private segment usage per work-item, in bytes. There may\n be performance degradation if the application places a kernel\n dispatch packet in the queue and the corresponding private segment\n usage exceeds @p private_segment_size. If the application does not\n want to specify any particular value for this argument, @p\n private_segment_size must be UINT32_MAX. If the queue does not\n support kernel dispatch packets, this argument is ignored.\n\n @param[in] group_segment_size Hint indicating the maximum expected\n group segment usage per work-group, in bytes. There may be\n performance degradation if the application places a kernel dispatch\n packet in the queue and the corresponding group segment usage\n exceeds @p group_segment_size. If the application does not want to\n specify any particular value for this argument, @p\n group_segment_size must be UINT32_MAX. If the queue does not\n support kernel dispatch packets, this argument is ignored.\n\n @param[out] queue Memory location where the HSA runtime stores a pointer to\n the newly created queue.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE_CREATION @p agent does not\n support queues of the given type.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is not a power of two,\n @p size is 0, @p type is an invalid queue type, or @p queue is NULL.\n"]
    pub fn hsa_queue_create(
        agent: hsa_agent_t,
        size: u32,
        type_: hsa_queue_type32_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                status: hsa_status_t,
                source: *mut hsa_queue_t,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
        private_segment_size: u32,
        group_segment_size: u32,
        queue: *mut *mut hsa_queue_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Create a queue for which the application or a kernel is responsible\n for processing the AQL packets.\n\n @details The application can use this function to create queues where AQL\n packets are not parsed by the packet processor associated with an agent,\n but rather by a unit of execution running on that agent (for example, a\n thread in the host application).\n\n The application is responsible for ensuring that all the producers and\n consumers of the resulting queue can access the provided doorbell signal\n and memory region. The application is also responsible for ensuring that the\n unit of execution processing the queue packets supports the indicated\n features (AQL packet types).\n\n When the queue is created, the HSA runtime allocates the packet buffer using\n @p region, and the write and read indexes. The initial value of the write and\n read indexes is 0, and the type of every packet in the buffer is initialized\n to ::HSA_PACKET_TYPE_INVALID. The value of the @e size, @e type, @e features,\n and @e doorbell_signal fields in the returned queue match the values passed\n by the application.\n\n @param[in] region Memory region that the HSA runtime should use to allocate\n the AQL packet buffer and any other queue metadata.\n\n @param[in] size Number of packets the queue is expected to hold. Must be a\n power of 2 greater than 0.\n\n @param[in] type Queue type.\n\n @param[in] features Supported queue features. This is a bit-field of\n ::hsa_queue_feature_t values.\n\n @param[in] doorbell_signal Doorbell signal that the HSA runtime must\n associate with the returned queue. The signal handle must not be 0.\n\n @param[out] queue Memory location where the HSA runtime stores a pointer to\n the newly created queue. The application should not rely on the value\n returned for this argument but only in the status code to determine if the\n queue is valid. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is not a power of two, @p\n size is 0, @p type is an invalid queue type, the doorbell signal handle is\n 0, or @p queue is NULL.\n"]
    pub fn hsa_soft_queue_create(
        region: hsa_region_t,
        size: u32,
        type_: hsa_queue_type32_t,
        features: u32,
        doorbell_signal: hsa_signal_t,
        queue: *mut *mut hsa_queue_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a user mode queue.\n\n @details When a queue is destroyed, the state of the AQL packets that have\n not been yet fully processed (their completion phase has not finished)\n becomes undefined. It is the responsibility of the application to ensure that\n all pending queue operations are finished if their results are required.\n\n The resources allocated by the HSA runtime during queue creation (queue\n structure, ring buffer, doorbell signal) are released.  The queue should not\n be accessed after being destroyed.\n\n @param[in] queue Pointer to a queue created using ::hsa_queue_create.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE The queue is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p queue is NULL."]
    pub fn hsa_queue_destroy(queue: *mut hsa_queue_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Inactivate a queue.\n\n @details Inactivating the queue aborts any pending executions and prevent any\n new packets from being processed. Any more packets written to the queue once\n it is inactivated will be ignored by the packet processor.\n\n @param[in] queue Pointer to a queue.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE The queue is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p queue is NULL."]
    pub fn hsa_queue_inactivate(queue: *mut hsa_queue_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_load_read_index_scacquire.\n\n @copydoc hsa_queue_load_read_index_scacquire"]
    pub fn hsa_queue_load_read_index_acquire(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically load the read index of a queue.\n\n @param[in] queue Pointer to a queue.\n\n @return Read index of the queue pointed by @p queue."]
    pub fn hsa_queue_load_read_index_scacquire(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_load_read_index_scacquire"]
    pub fn hsa_queue_load_read_index_relaxed(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_load_write_index_scacquire.\n\n @copydoc hsa_queue_load_write_index_scacquire"]
    pub fn hsa_queue_load_write_index_acquire(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically load the write index of a queue.\n\n @param[in] queue Pointer to a queue.\n\n @return Write index of the queue pointed by @p queue."]
    pub fn hsa_queue_load_write_index_scacquire(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_load_write_index_scacquire"]
    pub fn hsa_queue_load_write_index_relaxed(queue: *const hsa_queue_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the write index of a queue.\n\n @details It is recommended that the application uses this function to update\n the write index when there is a single agent submitting work to the queue\n (the queue type is ::HSA_QUEUE_TYPE_SINGLE).\n\n @param[in] queue Pointer to a queue.\n\n @param[in] value Value to assign to the write index.\n"]
    pub fn hsa_queue_store_write_index_relaxed(queue: *const hsa_queue_t, value: u64);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_store_write_index_screlease.\n\n @copydoc hsa_queue_store_write_index_screlease"]
    pub fn hsa_queue_store_write_index_release(queue: *const hsa_queue_t, value: u64);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_store_write_index_relaxed"]
    pub fn hsa_queue_store_write_index_screlease(queue: *const hsa_queue_t, value: u64);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_cas_write_index_scacq_screl.\n\n @copydoc hsa_queue_cas_write_index_scacq_screl"]
    pub fn hsa_queue_cas_write_index_acq_rel(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the write index of a queue if the observed value is\n equal to the expected value. The application can inspect the returned value\n to determine if the replacement was done.\n\n @param[in] queue Pointer to a queue.\n\n @param[in] expected Expected value.\n\n @param[in] value Value to assign to the write index if @p expected matches\n the observed write index. Must be greater than @p expected.\n\n @return Previous value of the write index."]
    pub fn hsa_queue_cas_write_index_scacq_screl(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_cas_write_index_scacquire.\n\n @copydoc hsa_queue_cas_write_index_scacquire"]
    pub fn hsa_queue_cas_write_index_acquire(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_cas_write_index_scacq_screl"]
    pub fn hsa_queue_cas_write_index_scacquire(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_cas_write_index_scacq_screl"]
    pub fn hsa_queue_cas_write_index_relaxed(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_cas_write_index_screlease.\n\n @copydoc hsa_queue_cas_write_index_screlease"]
    pub fn hsa_queue_cas_write_index_release(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_cas_write_index_scacq_screl"]
    pub fn hsa_queue_cas_write_index_screlease(
        queue: *const hsa_queue_t,
        expected: u64,
        value: u64,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_add_write_index_scacq_screl.\n\n @copydoc hsa_queue_add_write_index_scacq_screl"]
    pub fn hsa_queue_add_write_index_acq_rel(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically increment the write index of a queue by an offset.\n\n @param[in] queue Pointer to a queue.\n\n @param[in] value Value to add to the write index.\n\n @return Previous value of the write index."]
    pub fn hsa_queue_add_write_index_scacq_screl(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_add_write_index_scacquire.\n\n @copydoc hsa_queue_add_write_index_scacquire"]
    pub fn hsa_queue_add_write_index_acquire(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_add_write_index_scacq_screl"]
    pub fn hsa_queue_add_write_index_scacquire(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_add_write_index_scacq_screl"]
    pub fn hsa_queue_add_write_index_relaxed(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_add_write_index_screlease.\n\n @copydoc hsa_queue_add_write_index_screlease"]
    pub fn hsa_queue_add_write_index_release(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_add_write_index_scacq_screl"]
    pub fn hsa_queue_add_write_index_screlease(queue: *const hsa_queue_t, value: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically set the read index of a queue.\n\n @details Modifications of the read index are not allowed and result in\n undefined behavior if the queue is associated with an agent for which\n only the corresponding packet processor is permitted to update the read\n index.\n\n @param[in] queue Pointer to a queue.\n\n @param[in] value Value to assign to the read index.\n"]
    pub fn hsa_queue_store_read_index_relaxed(queue: *const hsa_queue_t, value: u64);
}
unsafe extern "C" {
    #[doc = " @deprecated Renamed as ::hsa_queue_store_read_index_screlease.\n\n @copydoc hsa_queue_store_read_index_screlease"]
    pub fn hsa_queue_store_read_index_release(queue: *const hsa_queue_t, value: u64);
}
unsafe extern "C" {
    #[doc = " @copydoc hsa_queue_store_read_index_relaxed"]
    pub fn hsa_queue_store_read_index_screlease(queue: *const hsa_queue_t, value: u64);
}
#[doc = " Vendor-specific packet."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_VENDOR_SPECIFIC: hsa_packet_type_t = 0;
#[doc = " The packet has been processed in the past, but has not been reassigned to\n the packet processor. A packet processor must not process a packet of this\n type. All queues support this packet type."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_INVALID: hsa_packet_type_t = 1;
#[doc = " Packet used by agents for dispatching jobs to kernel agents. Not all\n queues support packets of this type (see ::hsa_queue_feature_t)."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_KERNEL_DISPATCH: hsa_packet_type_t = 2;
#[doc = " Packet used by agents to delay processing of subsequent packets, and to\n express complex dependencies between multiple packets. All queues support\n this packet type."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_BARRIER_AND: hsa_packet_type_t = 3;
#[doc = " Packet used by agents for dispatching jobs to agents.  Not all\n queues support packets of this type (see ::hsa_queue_feature_t)."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_AGENT_DISPATCH: hsa_packet_type_t = 4;
#[doc = " Packet used by agents to delay processing of subsequent packets, and to\n express complex dependencies between multiple packets. All queues support\n this packet type."]
pub const hsa_packet_type_t_HSA_PACKET_TYPE_BARRIER_OR: hsa_packet_type_t = 5;
#[doc = " @brief Packet type."]
pub type hsa_packet_type_t = ::std::os::raw::c_uint;
#[doc = " No scope (no fence is applied). The packet relies on external fences to\n ensure visibility of memory updates."]
pub const hsa_fence_scope_t_HSA_FENCE_SCOPE_NONE: hsa_fence_scope_t = 0;
#[doc = " The fence is applied with agent scope for the global segment."]
pub const hsa_fence_scope_t_HSA_FENCE_SCOPE_AGENT: hsa_fence_scope_t = 1;
#[doc = " The fence is applied across both agent and system scope for the global\n segment."]
pub const hsa_fence_scope_t_HSA_FENCE_SCOPE_SYSTEM: hsa_fence_scope_t = 2;
#[doc = " @brief Scope of the memory fence operation associated with a packet."]
pub type hsa_fence_scope_t = ::std::os::raw::c_uint;
#[doc = " Packet type. The value of this sub-field must be one of\n ::hsa_packet_type_t. If the type is ::HSA_PACKET_TYPE_VENDOR_SPECIFIC, the\n packet layout is vendor-specific."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_TYPE: hsa_packet_header_t = 0;
#[doc = " Barrier bit. If the barrier bit is set, the processing of the current\n packet only launches when all preceding packets (within the same queue) are\n complete."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_BARRIER: hsa_packet_header_t = 8;
#[doc = " Acquire fence scope. The value of this sub-field determines the scope and\n type of the memory fence operation applied before the packet enters the\n active phase. An acquire fence ensures that any subsequent global segment\n or image loads by any unit of execution that belongs to a dispatch that has\n not yet entered the active phase on any queue of the same kernel agent,\n sees any data previously released at the scopes specified by the acquire\n fence. The value of this sub-field must be one of ::hsa_fence_scope_t."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_SCACQUIRE_FENCE_SCOPE: hsa_packet_header_t = 9;
#[doc = " @deprecated Renamed as ::HSA_PACKET_HEADER_SCACQUIRE_FENCE_SCOPE."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE: hsa_packet_header_t = 9;
#[doc = " Release fence scope, The value of this sub-field determines the scope and\n type of the memory fence operation applied after kernel completion but\n before the packet is completed. A release fence makes any global segment or\n image data that was stored by any unit of execution that belonged to a\n dispatch that has completed the active phase on any queue of the same\n kernel agent visible in all the scopes specified by the release fence. The\n value of this sub-field must be one of ::hsa_fence_scope_t."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_SCRELEASE_FENCE_SCOPE: hsa_packet_header_t = 11;
#[doc = " @deprecated Renamed as ::HSA_PACKET_HEADER_SCRELEASE_FENCE_SCOPE."]
pub const hsa_packet_header_t_HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE: hsa_packet_header_t = 11;
#[doc = " @brief Sub-fields of the @a header field that is present in any AQL\n packet. The offset (with respect to the address of @a header) of a sub-field\n is identical to its enumeration constant. The width of each sub-field is\n determined by the corresponding value in ::hsa_packet_header_width_t. The\n offset and the width are expressed in bits."]
pub type hsa_packet_header_t = ::std::os::raw::c_uint;
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_TYPE: hsa_packet_header_width_t = 8;
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_BARRIER: hsa_packet_header_width_t = 1;
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_SCACQUIRE_FENCE_SCOPE:
    hsa_packet_header_width_t = 2;
#[doc = " @deprecated Use HSA_PACKET_HEADER_WIDTH_SCACQUIRE_FENCE_SCOPE."]
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_ACQUIRE_FENCE_SCOPE:
    hsa_packet_header_width_t = 2;
#[doc = " @deprecated Use HSA_PACKET_HEADER_WIDTH_SCACQUIRE_FENCE_SCOPE."]
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_SCRELEASE_FENCE_SCOPE:
    hsa_packet_header_width_t = 2;
#[doc = " @deprecated Use HSA_PACKET_HEADER_WIDTH_SCRELEASE_FENCE_SCOPE."]
pub const hsa_packet_header_width_t_HSA_PACKET_HEADER_WIDTH_RELEASE_FENCE_SCOPE:
    hsa_packet_header_width_t = 2;
#[doc = " @brief Width (in bits) of the sub-fields in ::hsa_packet_header_t."]
pub type hsa_packet_header_width_t = ::std::os::raw::c_uint;
#[doc = " Number of dimensions of the grid. Valid values are 1, 2, or 3.\n"]
pub const hsa_kernel_dispatch_packet_setup_t_HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS:
    hsa_kernel_dispatch_packet_setup_t = 0;
#[doc = " @brief Sub-fields of the kernel dispatch packet @a setup field. The offset\n (with respect to the address of @a setup) of a sub-field is identical to its\n enumeration constant. The width of each sub-field is determined by the\n corresponding value in ::hsa_kernel_dispatch_packet_setup_width_t. The\n offset and the width are expressed in bits."]
pub type hsa_kernel_dispatch_packet_setup_t = ::std::os::raw::c_uint;
pub const hsa_kernel_dispatch_packet_setup_width_t_HSA_KERNEL_DISPATCH_PACKET_SETUP_WIDTH_DIMENSIONS : hsa_kernel_dispatch_packet_setup_width_t = 2 ;
#[doc = " @brief Width (in bits) of the sub-fields in\n ::hsa_kernel_dispatch_packet_setup_t."]
pub type hsa_kernel_dispatch_packet_setup_width_t = ::std::os::raw::c_uint;
#[doc = " @brief AQL kernel dispatch packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_kernel_dispatch_packet_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = " Dispatch setup parameters. Used to configure kernel dispatch parameters\n such as the number of dimensions in the grid. The parameters are described\n by ::hsa_kernel_dispatch_packet_setup_t."]
    pub setup: u16,
    #[doc = " X dimension of work-group, in work-items. Must be greater than 0."]
    pub workgroup_size_x: u16,
    #[doc = " Y dimension of work-group, in work-items. Must be greater than\n 0. If the grid has 1 dimension, the only valid value is 1."]
    pub workgroup_size_y: u16,
    #[doc = " Z dimension of work-group, in work-items. Must be greater than\n 0. If the grid has 1 or 2 dimensions, the only valid value is 1."]
    pub workgroup_size_z: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u16,
    #[doc = " X dimension of grid, in work-items. Must be greater than 0. Must\n not be smaller than @a workgroup_size_x."]
    pub grid_size_x: u32,
    #[doc = " Y dimension of grid, in work-items. Must be greater than 0. If the grid has\n 1 dimension, the only valid value is 1. Must not be smaller than @a\n workgroup_size_y."]
    pub grid_size_y: u32,
    #[doc = " Z dimension of grid, in work-items. Must be greater than 0. If the grid has\n 1 or 2 dimensions, the only valid value is 1. Must not be smaller than @a\n workgroup_size_z."]
    pub grid_size_z: u32,
    #[doc = " Size in bytes of private memory allocation request (per work-item)."]
    pub private_segment_size: u32,
    #[doc = " Size in bytes of group memory allocation request (per work-group). Must not\n be less than the sum of the group memory used by the kernel (and the\n functions it calls directly or indirectly) and the dynamically allocated\n group segment variables."]
    pub group_segment_size: u32,
    #[doc = " Opaque handle to a code object that includes an implementation-defined\n executable code for the kernel."]
    pub kernel_object: u64,
    pub kernarg_address: *mut ::std::os::raw::c_void,
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_kernel_dispatch_packet_s"]
        [::std::mem::size_of::<hsa_kernel_dispatch_packet_s>() - 64usize];
    ["Alignment of hsa_kernel_dispatch_packet_s"]
        [::std::mem::align_of::<hsa_kernel_dispatch_packet_s>() - 8usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::header"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, header) - 0usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::setup"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, setup) - 2usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::workgroup_size_x"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, workgroup_size_x) - 4usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::workgroup_size_y"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, workgroup_size_y) - 6usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::workgroup_size_z"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, workgroup_size_z) - 8usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::reserved0"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, reserved0) - 10usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::grid_size_x"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, grid_size_x) - 12usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::grid_size_y"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, grid_size_y) - 16usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::grid_size_z"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, grid_size_z) - 20usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::private_segment_size"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, private_segment_size) - 24usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::group_segment_size"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, group_segment_size) - 28usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::kernel_object"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, kernel_object) - 32usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::kernarg_address"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, kernarg_address) - 40usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::reserved2"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, reserved2) - 48usize];
    ["Offset of field: hsa_kernel_dispatch_packet_s::completion_signal"]
        [::std::mem::offset_of!(hsa_kernel_dispatch_packet_s, completion_signal) - 56usize];
};
#[doc = " @brief AQL kernel dispatch packet"]
pub type hsa_kernel_dispatch_packet_t = hsa_kernel_dispatch_packet_s;
#[doc = " @brief Agent dispatch packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_agent_dispatch_packet_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = " Application-defined function to be performed by the destination agent."]
    pub type_: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u32,
    pub return_address: *mut ::std::os::raw::c_void,
    #[doc = " Function arguments."]
    pub arg: [u64; 4usize],
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_agent_dispatch_packet_s"]
        [::std::mem::size_of::<hsa_agent_dispatch_packet_s>() - 64usize];
    ["Alignment of hsa_agent_dispatch_packet_s"]
        [::std::mem::align_of::<hsa_agent_dispatch_packet_s>() - 8usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::header"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, header) - 0usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::type_"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, type_) - 2usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::reserved0"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, reserved0) - 4usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::return_address"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, return_address) - 8usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::arg"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, arg) - 16usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::reserved2"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, reserved2) - 48usize];
    ["Offset of field: hsa_agent_dispatch_packet_s::completion_signal"]
        [::std::mem::offset_of!(hsa_agent_dispatch_packet_s, completion_signal) - 56usize];
};
#[doc = " @brief Agent dispatch packet."]
pub type hsa_agent_dispatch_packet_t = hsa_agent_dispatch_packet_s;
#[doc = " @brief Barrier-AND packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_barrier_and_packet_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved1: u32,
    #[doc = " Array of dependent signal objects. Signals with a handle value of 0 are\n allowed and are interpreted by the packet processor as satisfied\n dependencies."]
    pub dep_signal: [hsa_signal_t; 5usize],
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_barrier_and_packet_s"]
        [::std::mem::size_of::<hsa_barrier_and_packet_s>() - 64usize];
    ["Alignment of hsa_barrier_and_packet_s"]
        [::std::mem::align_of::<hsa_barrier_and_packet_s>() - 8usize];
    ["Offset of field: hsa_barrier_and_packet_s::header"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, header) - 0usize];
    ["Offset of field: hsa_barrier_and_packet_s::reserved0"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, reserved0) - 2usize];
    ["Offset of field: hsa_barrier_and_packet_s::reserved1"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, reserved1) - 4usize];
    ["Offset of field: hsa_barrier_and_packet_s::dep_signal"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, dep_signal) - 8usize];
    ["Offset of field: hsa_barrier_and_packet_s::reserved2"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, reserved2) - 48usize];
    ["Offset of field: hsa_barrier_and_packet_s::completion_signal"]
        [::std::mem::offset_of!(hsa_barrier_and_packet_s, completion_signal) - 56usize];
};
#[doc = " @brief Barrier-AND packet."]
pub type hsa_barrier_and_packet_t = hsa_barrier_and_packet_s;
#[doc = " @brief Barrier-OR packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_barrier_or_packet_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u16,
    #[doc = " Reserved. Must be 0."]
    pub reserved1: u32,
    #[doc = " Array of dependent signal objects. Signals with a handle value of 0 are\n allowed and are interpreted by the packet processor as dependencies not\n satisfied."]
    pub dep_signal: [hsa_signal_t; 5usize],
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_barrier_or_packet_s"][::std::mem::size_of::<hsa_barrier_or_packet_s>() - 64usize];
    ["Alignment of hsa_barrier_or_packet_s"]
        [::std::mem::align_of::<hsa_barrier_or_packet_s>() - 8usize];
    ["Offset of field: hsa_barrier_or_packet_s::header"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, header) - 0usize];
    ["Offset of field: hsa_barrier_or_packet_s::reserved0"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, reserved0) - 2usize];
    ["Offset of field: hsa_barrier_or_packet_s::reserved1"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, reserved1) - 4usize];
    ["Offset of field: hsa_barrier_or_packet_s::dep_signal"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, dep_signal) - 8usize];
    ["Offset of field: hsa_barrier_or_packet_s::reserved2"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, reserved2) - 48usize];
    ["Offset of field: hsa_barrier_or_packet_s::completion_signal"]
        [::std::mem::offset_of!(hsa_barrier_or_packet_s, completion_signal) - 56usize];
};
#[doc = " @brief Barrier-OR packet."]
pub type hsa_barrier_or_packet_t = hsa_barrier_or_packet_s;
#[doc = " Global segment. Used to hold data that is shared by all agents."]
pub const hsa_region_segment_t_HSA_REGION_SEGMENT_GLOBAL: hsa_region_segment_t = 0;
#[doc = " Read-only segment. Used to hold data that remains constant during the\n execution of a kernel."]
pub const hsa_region_segment_t_HSA_REGION_SEGMENT_READONLY: hsa_region_segment_t = 1;
#[doc = " Private segment. Used to hold data that is local to a single work-item."]
pub const hsa_region_segment_t_HSA_REGION_SEGMENT_PRIVATE: hsa_region_segment_t = 2;
#[doc = " Group segment. Used to hold data that is shared by the work-items of a\n work-group."]
pub const hsa_region_segment_t_HSA_REGION_SEGMENT_GROUP: hsa_region_segment_t = 3;
#[doc = " Kernarg segment. Used to store kernel arguments."]
pub const hsa_region_segment_t_HSA_REGION_SEGMENT_KERNARG: hsa_region_segment_t = 4;
#[doc = " @brief Memory segments associated with a region."]
pub type hsa_region_segment_t = ::std::os::raw::c_uint;
#[doc = " The application can use memory in the region to store kernel arguments, and\n provide the values for the kernarg segment of a kernel dispatch. If this\n flag is set, then ::HSA_REGION_GLOBAL_FLAG_FINE_GRAINED must be set."]
pub const hsa_region_global_flag_t_HSA_REGION_GLOBAL_FLAG_KERNARG: hsa_region_global_flag_t = 1;
#[doc = " Updates to memory in this region are immediately visible to all the\n agents under the terms of the HSA memory model. If this\n flag is set, then ::HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED must not be set."]
pub const hsa_region_global_flag_t_HSA_REGION_GLOBAL_FLAG_FINE_GRAINED: hsa_region_global_flag_t =
    2;
#[doc = " Updates to memory in this region can be performed by a single agent at\n a time. If a different agent in the system is allowed to access the\n region, the application must explicitely invoke ::hsa_memory_assign_agent\n in order to transfer ownership to that agent for a particular buffer."]
pub const hsa_region_global_flag_t_HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED: hsa_region_global_flag_t =
    4;
#[doc = " Updates to memory in this region have extended scope, where the device-scope atomics\n to this memory type act as system-scope with respect to all variables located in\n memory regions of this type.\n Note: On non-compliant systems, the application may still be responsible for performing\n device-specific actions necessary to achieve system-scope coherence."]
pub const hsa_region_global_flag_t_HSA_REGION_GLOBAL_FLAG_EXTENDED_SCOPE_FINE_GRAINED:
    hsa_region_global_flag_t = 8;
#[doc = " @brief Global region flags."]
pub type hsa_region_global_flag_t = ::std::os::raw::c_uint;
#[doc = " Segment where memory in the region can be used. The type of this\n attribute is ::hsa_region_segment_t."]
pub const hsa_region_info_t_HSA_REGION_INFO_SEGMENT: hsa_region_info_t = 0;
#[doc = " Flag mask. The value of this attribute is undefined if the value of\n ::HSA_REGION_INFO_SEGMENT is not ::HSA_REGION_SEGMENT_GLOBAL. The type of\n this attribute is uint32_t, a bit-field of ::hsa_region_global_flag_t\n values."]
pub const hsa_region_info_t_HSA_REGION_INFO_GLOBAL_FLAGS: hsa_region_info_t = 1;
#[doc = " Size of this region, in bytes. The type of this attribute is size_t."]
pub const hsa_region_info_t_HSA_REGION_INFO_SIZE: hsa_region_info_t = 2;
#[doc = " Maximum allocation size in this region, in bytes. Must not exceed the value\n of ::HSA_REGION_INFO_SIZE. The type of this attribute is size_t.\n\n If the region is in the global or readonly segments, this is the maximum\n size that the application can pass to ::hsa_memory_allocate.\n\n If the region is in the group segment, this is the maximum size (per\n work-group) that can be requested for a given kernel dispatch. If the\n region is in the private segment, this is the maximum size (per work-item)\n that can be requested for a specific kernel dispatch, and must be at least\n 256 bytes."]
pub const hsa_region_info_t_HSA_REGION_INFO_ALLOC_MAX_SIZE: hsa_region_info_t = 4;
#[doc = " Maximum size (per work-group) of private memory that can be requested for a\n specific kernel dispatch. Must be at least 65536 bytes. The type of this\n attribute is uint32_t. The value of this attribute is undefined if the\n region is not in the private segment."]
pub const hsa_region_info_t_HSA_REGION_INFO_ALLOC_MAX_PRIVATE_WORKGROUP_SIZE: hsa_region_info_t = 8;
#[doc = " Indicates whether memory in this region can be allocated using\n ::hsa_memory_allocate. The type of this attribute is bool.\n\n The value of this flag is always false for regions in the group and private\n segments."]
pub const hsa_region_info_t_HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED: hsa_region_info_t = 5;
#[doc = " Allocation granularity of buffers allocated by ::hsa_memory_allocate in\n this region. The size of a buffer allocated in this region is a multiple of\n the value of this attribute. The value of this attribute is only defined if\n ::HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED is true for this region. The type\n of this attribute is size_t."]
pub const hsa_region_info_t_HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE: hsa_region_info_t = 6;
#[doc = " Alignment of buffers allocated by ::hsa_memory_allocate in this region. The\n value of this attribute is only defined if\n ::HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED is true for this region, and must be\n a power of 2. The type of this attribute is size_t."]
pub const hsa_region_info_t_HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT: hsa_region_info_t = 7;
#[doc = " @brief Attributes of a memory region."]
pub type hsa_region_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute of a region.\n\n @param[in] region A valid region.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to a application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_REGION The region is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n region attribute, or @p value is NULL."]
    pub fn hsa_region_get_info(
        region: hsa_region_t,
        attribute: hsa_region_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the memory regions associated with a given agent, and\n invoke an application-defined callback on every iteration.\n\n @param[in] agent A valid agent.\n\n @param[in] callback Callback to be invoked once per region that is\n accessible from the agent.  The HSA runtime passes two arguments to the\n callback, the region and the application data.  If @p callback returns a\n status other than ::HSA_STATUS_SUCCESS for a particular iteration, the\n traversal stops and ::hsa_agent_iterate_regions returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_agent_iterate_regions(
        agent: hsa_agent_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                region: hsa_region_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a block of memory in a given region.\n\n @param[in] region Region where to allocate memory from. The region must have\n the ::HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED flag set.\n\n @param[in] size Allocation size, in bytes. Must not be zero. This value is\n rounded up to the nearest multiple of ::HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE\n in @p region.\n\n @param[out] ptr Pointer to the location where to store the base address of\n the allocated block. The returned base address is aligned to the value of\n ::HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT in @p region. If the allocation\n fails, the returned value is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_REGION The region is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION The host is not allowed to\n allocate memory in @p region, or @p size is greater than the value of\n HSA_REGION_INFO_ALLOC_MAX_SIZE in @p region.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL, or @p size is 0."]
    pub fn hsa_memory_allocate(
        region: hsa_region_t,
        size: usize,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Deallocate a block of memory previously allocated using\n ::hsa_memory_allocate.\n\n @param[in] ptr Pointer to a memory block. If @p ptr does not match a value\n previously returned by ::hsa_memory_allocate, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized."]
    pub fn hsa_memory_free(ptr: *mut ::std::os::raw::c_void) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Copy a block of memory from the location pointed to by @p src to the\n memory block pointed to by @p dst.\n\n @param[out] dst Buffer where the content is to be copied. If @p dst is in\n coarse-grained memory, the copied data is only visible to the agent currently\n assigned (::hsa_memory_assign_agent) to @p dst.\n\n @param[in] src A valid pointer to the source of data to be copied. The source\n buffer must not overlap with the destination buffer. If the source buffer is\n in coarse-grained memory then it must be assigned to an agent, from which the\n data will be retrieved.\n\n @param[in] size Number of bytes to copy. If @p size is 0, no copy is\n performed and the function returns success. Copying a number of bytes larger\n than the size of the buffers pointed by @p dst or @p src results in undefined\n behavior.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The source or destination\n pointers are NULL."]
    pub fn hsa_memory_copy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Change the ownership of a global, coarse-grained buffer.\n\n @details The contents of a coarse-grained buffer are visible to an agent\n only after ownership has been explicitely transferred to that agent. Once the\n operation completes, the previous owner cannot longer access the data in the\n buffer.\n\n An implementation of the HSA runtime is allowed, but not required, to change\n the physical location of the buffer when ownership is transferred to a\n different agent. In general the application must not assume this\n behavior. The virtual location (address) of the passed buffer is never\n modified.\n\n @param[in] ptr Base address of a global buffer. The pointer must match an\n address previously returned by ::hsa_memory_allocate. The size of the buffer\n affected by the ownership change is identical to the size of that previous\n allocation. If @p ptr points to a fine-grained global buffer, no operation is\n performed and the function returns success. If @p ptr does not point to\n global memory, the behavior is undefined.\n\n @param[in] agent Agent that becomes the owner of the buffer. The\n application is responsible for ensuring that @p agent has access to the\n region that contains the buffer. It is allowed to change ownership to an\n agent that is already the owner of the buffer, with the same or different\n access permissions.\n\n @param[in] access Access permissions requested for the new owner.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL, or @p access is\n not a valid access value."]
    pub fn hsa_memory_assign_agent(
        ptr: *mut ::std::os::raw::c_void,
        agent: hsa_agent_t,
        access: hsa_access_permission_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Register a global, fine-grained buffer.\n\n @details Registering a buffer serves as an indication to the HSA runtime that\n the memory might be accessed from a kernel agent other than the\n host. Registration is a performance hint that allows the HSA runtime\n implementation to know which buffers will be accessed by some of the kernel\n agents ahead of time.\n\n Registration is only recommended for buffers in the global segment that have\n not been allocated using the HSA allocator (::hsa_memory_allocate), but an OS\n allocator instead. Registering an OS-allocated buffer in the base profile is\n equivalent to a no-op.\n\n Registrations should not overlap.\n\n @param[in] ptr A buffer in global, fine-grained memory. If a NULL pointer is\n passed, no operation is performed. If the buffer has been allocated using\n ::hsa_memory_allocate, or has already been registered, no operation is\n performed.\n\n @param[in] size Requested registration size in bytes. A size of 0 is\n only allowed if @p ptr is NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is 0 but @p ptr\n is not NULL."]
    pub fn hsa_memory_register(ptr: *mut ::std::os::raw::c_void, size: usize) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Deregister memory previously registered using ::hsa_memory_register.\n\n @details If the memory interval being deregistered does not match a previous\n registration (start and end addresses), the behavior is undefined.\n\n @param[in] ptr A pointer to the base of the buffer to be deregistered. If\n a NULL pointer is passed, no operation is performed.\n\n @param[in] size Size of the buffer to be deregistered.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n"]
    pub fn hsa_memory_deregister(ptr: *mut ::std::os::raw::c_void, size: usize) -> hsa_status_t;
}
#[doc = " @brief Instruction set architecture."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_isa_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_isa_s"][::std::mem::size_of::<hsa_isa_s>() - 8usize];
    ["Alignment of hsa_isa_s"][::std::mem::align_of::<hsa_isa_s>() - 8usize];
    ["Offset of field: hsa_isa_s::handle"][::std::mem::offset_of!(hsa_isa_s, handle) - 0usize];
};
#[doc = " @brief Instruction set architecture."]
pub type hsa_isa_t = hsa_isa_s;
unsafe extern "C" {
    #[doc = " @brief Retrieve a reference to an instruction set architecture handle out of\n a symbolic name.\n\n @param[in] name Vendor-specific name associated with a a particular\n instruction set architecture. @p name must start with the vendor name and a\n colon (for example, \"AMD:\"). The rest of the name is vendor-specific. Must be\n a NUL-terminated string.\n\n @param[out] isa Memory location where the HSA runtime stores the ISA handle\n corresponding to the given name. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA_NAME The given name does not\n correspond to any instruction set architecture.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p name is NULL, or @p isa is\n NULL."]
    pub fn hsa_isa_from_name(
        name: *const ::std::os::raw::c_char,
        isa: *mut hsa_isa_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the instruction sets supported by the given agent, and\n invoke an application-defined callback on every iteration. The iterator is\n deterministic: if an agent supports several instruction set architectures,\n they are traversed in the same order in every invocation of this function.\n\n @param[in] agent A valid agent.\n\n @param[in] callback Callback to be invoked once per instruction set\n architecture.  The HSA runtime passes two arguments to the callback: the\n ISA and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n that status value is returned.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_agent_iterate_isas(
        agent: hsa_agent_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(isa: hsa_isa_t, data: *mut ::std::os::raw::c_void) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " The length of the ISA name in bytes, not including the NUL terminator. The\n type of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_NAME_LENGTH: hsa_isa_info_t = 0;
#[doc = " Human-readable description.  The type of this attribute is character array\n with the length equal to the value of ::HSA_ISA_INFO_NAME_LENGTH attribute."]
pub const hsa_isa_info_t_HSA_ISA_INFO_NAME: hsa_isa_info_t = 1;
#[doc = " @deprecated\n\n Number of call conventions supported by the instruction set architecture.\n Must be greater than zero. The type of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_CALL_CONVENTION_COUNT: hsa_isa_info_t = 2;
#[doc = " @deprecated\n\n Number of work-items in a wavefront for a given call convention. Must be a\n power of 2 in the range [1,256]. The type of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_CALL_CONVENTION_INFO_WAVEFRONT_SIZE: hsa_isa_info_t = 3;
#[doc = " @deprecated\n\n Number of wavefronts per compute unit for a given call convention. In\n practice, other factors (for example, the amount of group memory used by a\n work-group) may further limit the number of wavefronts per compute\n unit. The type of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_CALL_CONVENTION_INFO_WAVEFRONTS_PER_COMPUTE_UNIT:
    hsa_isa_info_t = 4;
#[doc = " Machine models supported by the instruction set architecture. The type of\n this attribute is a bool[2]. If the ISA supports the small machine model,\n the element at index ::HSA_MACHINE_MODEL_SMALL is true. If the ISA supports\n the large model, the element at index ::HSA_MACHINE_MODEL_LARGE is true."]
pub const hsa_isa_info_t_HSA_ISA_INFO_MACHINE_MODELS: hsa_isa_info_t = 5;
#[doc = " Profiles supported by the instruction set architecture. The type of this\n attribute is a bool[2]. If the ISA supports the base profile, the element\n at index ::HSA_PROFILE_BASE is true. If the ISA supports the full profile,\n the element at index ::HSA_PROFILE_FULL is true."]
pub const hsa_isa_info_t_HSA_ISA_INFO_PROFILES: hsa_isa_info_t = 6;
#[doc = " Default floating-point rounding modes supported by the instruction set\n architecture. The type of this attribute is a bool[3]. The value at a given\n index is true if the corresponding rounding mode in\n ::hsa_default_float_rounding_mode_t is supported. At least one default mode\n has to be supported.\n\n If the default mode is supported, then\n ::HSA_ISA_INFO_BASE_PROFILE_DEFAULT_FLOAT_ROUNDING_MODES must report that\n both the zero and the near roundings modes are supported."]
pub const hsa_isa_info_t_HSA_ISA_INFO_DEFAULT_FLOAT_ROUNDING_MODES: hsa_isa_info_t = 7;
#[doc = " Default floating-point rounding modes supported by the instruction set\n architecture in the Base profile. The type of this attribute is a\n bool[3]. The value at a given index is true if the corresponding rounding\n mode in ::hsa_default_float_rounding_mode_t is supported. The value at\n index HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT must be false.  At least one\n of the values at indexes ::HSA_DEFAULT_FLOAT_ROUNDING_MODE_ZERO or\n HSA_DEFAULT_FLOAT_ROUNDING_MODE_NEAR must be true."]
pub const hsa_isa_info_t_HSA_ISA_INFO_BASE_PROFILE_DEFAULT_FLOAT_ROUNDING_MODES: hsa_isa_info_t = 8;
#[doc = " Flag indicating that the f16 HSAIL operation is at least as fast as the\n f32 operation in the instruction set architecture. The type of this\n attribute is bool."]
pub const hsa_isa_info_t_HSA_ISA_INFO_FAST_F16_OPERATION: hsa_isa_info_t = 9;
#[doc = " Maximum number of work-items of each dimension of a work-group.  Each\n maximum must be greater than 0. No maximum can exceed the value of\n ::HSA_ISA_INFO_WORKGROUP_MAX_SIZE. The type of this attribute is\n uint16_t[3]."]
pub const hsa_isa_info_t_HSA_ISA_INFO_WORKGROUP_MAX_DIM: hsa_isa_info_t = 12;
#[doc = " Maximum total number of work-items in a work-group. The type\n of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_WORKGROUP_MAX_SIZE: hsa_isa_info_t = 13;
#[doc = " Maximum number of work-items of each dimension of a grid. Each maximum must\n be greater than 0, and must not be smaller than the corresponding value in\n ::HSA_ISA_INFO_WORKGROUP_MAX_DIM. No maximum can exceed the value of\n ::HSA_ISA_INFO_GRID_MAX_SIZE. The type of this attribute is\n ::hsa_dim3_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_GRID_MAX_DIM: hsa_isa_info_t = 14;
#[doc = " Maximum total number of work-items in a grid. The type of this\n attribute is uint64_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_GRID_MAX_SIZE: hsa_isa_info_t = 16;
#[doc = " Maximum number of fbarriers per work-group. Must be at least 32. The\n type of this attribute is uint32_t."]
pub const hsa_isa_info_t_HSA_ISA_INFO_FBARRIER_MAX_SIZE: hsa_isa_info_t = 17;
#[doc = " @brief Instruction set architecture attributes."]
pub type hsa_isa_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @deprecated The concept of call convention has been deprecated. If the\n application wants to query the value of an attribute for a given instruction\n set architecture, use ::hsa_isa_get_info_alt instead. If the application\n wants to query an attribute that is specific to a given combination of ISA\n and wavefront, use ::hsa_wavefront_get_info.\n\n @brief Get the current value of an attribute for a given instruction set\n architecture (ISA).\n\n @param[in] isa A valid instruction set architecture.\n\n @param[in] attribute Attribute to query.\n\n @param[in] index Call convention index. Used only for call convention\n attributes, otherwise ignored. Must have a value between 0 (inclusive) and\n the value of the attribute ::HSA_ISA_INFO_CALL_CONVENTION_COUNT (not\n inclusive) in @p isa.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA The instruction set architecture is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_INDEX The index is out of range.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n instruction set architecture attribute, or @p value is\n NULL."]
    pub fn hsa_isa_get_info(
        isa: hsa_isa_t,
        attribute: hsa_isa_info_t,
        index: u32,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute for a given instruction set\n architecture (ISA).\n\n @param[in] isa A valid instruction set architecture.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA The instruction set architecture is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n instruction set architecture attribute, or @p value is\n NULL."]
    pub fn hsa_isa_get_info_alt(
        isa: hsa_isa_t,
        attribute: hsa_isa_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the exception policy support for a given combination of\n instruction set architecture and profile.\n\n @param[in] isa A valid instruction set architecture.\n\n @param[in] profile Profile.\n\n @param[out] mask Pointer to a memory location where the HSA runtime stores a\n mask of ::hsa_exception_policy_t values. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA The instruction set architecture is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p profile is not a valid\n profile, or @p mask is NULL."]
    pub fn hsa_isa_get_exception_policies(
        isa: hsa_isa_t,
        profile: hsa_profile_t,
        mask: *mut u16,
    ) -> hsa_status_t;
}
#[doc = " 16-bit floating-point type."]
pub const hsa_fp_type_t_HSA_FP_TYPE_16: hsa_fp_type_t = 1;
#[doc = " 32-bit floating-point type."]
pub const hsa_fp_type_t_HSA_FP_TYPE_32: hsa_fp_type_t = 2;
#[doc = " 64-bit floating-point type."]
pub const hsa_fp_type_t_HSA_FP_TYPE_64: hsa_fp_type_t = 4;
#[doc = " @brief Floating-point types."]
pub type hsa_fp_type_t = ::std::os::raw::c_uint;
#[doc = " Flush to zero."]
pub const hsa_flush_mode_t_HSA_FLUSH_MODE_FTZ: hsa_flush_mode_t = 1;
#[doc = " Do not flush to zero."]
pub const hsa_flush_mode_t_HSA_FLUSH_MODE_NON_FTZ: hsa_flush_mode_t = 2;
#[doc = " @brief Flush to zero modes."]
pub type hsa_flush_mode_t = ::std::os::raw::c_uint;
#[doc = " Single round method."]
pub const hsa_round_method_t_HSA_ROUND_METHOD_SINGLE: hsa_round_method_t = 1;
#[doc = " Double round method."]
pub const hsa_round_method_t_HSA_ROUND_METHOD_DOUBLE: hsa_round_method_t = 2;
#[doc = " @brief Round methods."]
pub type hsa_round_method_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Retrieve the round method (single or double) used to implement the\n floating-point multiply add instruction (mad) for a given combination of\n instruction set architecture, floating-point type, and flush to zero\n modifier.\n\n @param[in] isa Instruction set architecture.\n\n @param[in] fp_type Floating-point type.\n\n @param[in] flush_mode Flush to zero modifier.\n\n @param[out] round_method Pointer to a memory location where the HSA\n runtime stores the round method used by the implementation. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA The instruction set architecture is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p fp_type is not a valid\n floating-point type, or @p flush_mode is not a valid flush to zero modifier,\n or @p round_method is NULL."]
    pub fn hsa_isa_get_round_method(
        isa: hsa_isa_t,
        fp_type: hsa_fp_type_t,
        flush_mode: hsa_flush_mode_t,
        round_method: *mut hsa_round_method_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Wavefront handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_wavefront_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_wavefront_s"][::std::mem::size_of::<hsa_wavefront_s>() - 8usize];
    ["Alignment of hsa_wavefront_s"][::std::mem::align_of::<hsa_wavefront_s>() - 8usize];
    ["Offset of field: hsa_wavefront_s::handle"]
        [::std::mem::offset_of!(hsa_wavefront_s, handle) - 0usize];
};
#[doc = " @brief Wavefront handle"]
pub type hsa_wavefront_t = hsa_wavefront_s;
#[doc = " Number of work-items in the wavefront. Must be a power of 2 in the range\n [1,256]. The type of this attribute is uint32_t."]
pub const hsa_wavefront_info_t_HSA_WAVEFRONT_INFO_SIZE: hsa_wavefront_info_t = 0;
#[doc = " @brief Wavefront attributes."]
pub type hsa_wavefront_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of a wavefront attribute.\n\n @param[in] wavefront A wavefront.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_WAVEFRONT The wavefront is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n wavefront attribute, or @p value is NULL."]
    pub fn hsa_wavefront_get_info(
        wavefront: hsa_wavefront_t,
        attribute: hsa_wavefront_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the different wavefronts supported by an instruction set\n architecture, and invoke an application-defined callback on every iteration.\n\n @param[in] isa Instruction set architecture.\n\n @param[in] callback Callback to be invoked once per wavefront that is\n supported by the agent. The HSA runtime passes two arguments to the callback:\n the wavefront handle and the application data.  If @p callback returns a\n status other than ::HSA_STATUS_SUCCESS for a particular iteration, the\n traversal stops and that value is returned.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA The instruction set architecture is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_isa_iterate_wavefronts(
        isa: hsa_isa_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                wavefront: hsa_wavefront_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated Use ::hsa_agent_iterate_isas to query which instructions set\n architectures are supported by a given agent.\n\n @brief Check if the instruction set architecture of a code object can be\n executed on an agent associated with another architecture.\n\n @param[in] code_object_isa Instruction set architecture associated with a\n code object.\n\n @param[in] agent_isa Instruction set architecture associated with an agent.\n\n @param[out] result Pointer to a memory location where the HSA runtime stores\n the result of the check. If the two architectures are compatible, the result\n is true; if they are incompatible, the result is false.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ISA @p code_object_isa or @p agent_isa are\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p result is NULL."]
    pub fn hsa_isa_compatible(
        code_object_isa: hsa_isa_t,
        agent_isa: hsa_isa_t,
        result: *mut bool,
    ) -> hsa_status_t;
}
#[doc = " @brief Code object reader handle. A code object reader is used to\n load a code object from file (when created using\n ::hsa_code_object_reader_create_from_file), or from memory (if created using\n ::hsa_code_object_reader_create_from_memory)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_code_object_reader_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_code_object_reader_s"]
        [::std::mem::size_of::<hsa_code_object_reader_s>() - 8usize];
    ["Alignment of hsa_code_object_reader_s"]
        [::std::mem::align_of::<hsa_code_object_reader_s>() - 8usize];
    ["Offset of field: hsa_code_object_reader_s::handle"]
        [::std::mem::offset_of!(hsa_code_object_reader_s, handle) - 0usize];
};
#[doc = " @brief Code object reader handle. A code object reader is used to\n load a code object from file (when created using\n ::hsa_code_object_reader_create_from_file), or from memory (if created using\n ::hsa_code_object_reader_create_from_memory)."]
pub type hsa_code_object_reader_t = hsa_code_object_reader_s;
unsafe extern "C" {
    #[doc = " @brief Create a code object reader to operate on a file.\n\n @param[in] file File descriptor. The file must have been opened by\n application with at least read permissions prior calling this function. The\n file must contain a vendor-specific code object.\n\n The file is owned and managed by the application; the lifetime of the file\n descriptor must exceed that of any associated code object reader.\n\n @param[out] code_object_reader Memory location to store the newly created\n code object reader handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_FILE @p file is invalid.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p code_object_reader is NULL."]
    pub fn hsa_code_object_reader_create_from_file(
        file: hsa_file_t,
        code_object_reader: *mut hsa_code_object_reader_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Create a code object reader to operate on memory.\n\n @param[in] code_object Memory buffer that contains a vendor-specific code\n object. The buffer is owned and managed by the application; the lifetime of\n the buffer must exceed that of any associated code object reader.\n\n @param[in] size Size of the buffer pointed to by @p code_object. Must not be\n 0.\n\n @param[out] code_object_reader Memory location to store newly created code\n object reader handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p code_object is NULL, @p size\n is zero, or @p code_object_reader is NULL."]
    pub fn hsa_code_object_reader_create_from_memory(
        code_object: *const ::std::os::raw::c_void,
        size: usize,
        code_object_reader: *mut hsa_code_object_reader_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a code object reader.\n\n @details The code object reader handle becomes invalid after completion of\n this function. Any file or memory used to create the code object read is not\n closed, removed, or deallocated by this function.\n\n @param[in] code_object_reader Code object reader to destroy.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT_READER @p code_object_reader\n is invalid."]
    pub fn hsa_code_object_reader_destroy(
        code_object_reader: hsa_code_object_reader_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Struct containing an opaque handle to an executable, which contains\n ISA for finalized kernels and indirect functions together with the allocated\n global or readonly segment variables they reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_executable_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_executable_s"][::std::mem::size_of::<hsa_executable_s>() - 8usize];
    ["Alignment of hsa_executable_s"][::std::mem::align_of::<hsa_executable_s>() - 8usize];
    ["Offset of field: hsa_executable_s::handle"]
        [::std::mem::offset_of!(hsa_executable_s, handle) - 0usize];
};
#[doc = " @brief Struct containing an opaque handle to an executable, which contains\n ISA for finalized kernels and indirect functions together with the allocated\n global or readonly segment variables they reference."]
pub type hsa_executable_t = hsa_executable_s;
#[doc = " Executable state, which allows the user to load code objects and define\n external variables. Variable addresses, kernel code handles, and\n indirect function code handles are not available in query operations until\n the executable is frozen (zero always returned)."]
pub const hsa_executable_state_t_HSA_EXECUTABLE_STATE_UNFROZEN: hsa_executable_state_t = 0;
#[doc = " Executable state, which allows the user to query variable addresses,\n kernel code handles, and indirect function code handles using query\n operations. Loading new code objects, as well as defining external\n variables, is not allowed in this state."]
pub const hsa_executable_state_t_HSA_EXECUTABLE_STATE_FROZEN: hsa_executable_state_t = 1;
#[doc = " @brief Executable state."]
pub type hsa_executable_state_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @deprecated Use ::hsa_executable_create_alt instead, which allows the\n application to specify the default floating-point rounding mode of the\n executable and assumes an unfrozen initial state.\n\n @brief Create an empty executable.\n\n @param[in] profile Profile used in the executable.\n\n @param[in] executable_state Executable state. If the state is\n ::HSA_EXECUTABLE_STATE_FROZEN, the resulting executable is useless because no\n code objects can be loaded, and no variables can be defined.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] executable Memory location where the HSA runtime stores the newly\n created executable handle.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p profile is invalid, or\n @p executable is NULL."]
    pub fn hsa_executable_create(
        profile: hsa_profile_t,
        executable_state: hsa_executable_state_t,
        options: *const ::std::os::raw::c_char,
        executable: *mut hsa_executable_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Create an empty executable.\n\n @param[in] profile Profile used in the executable.\n\n @param[in] default_float_rounding_mode Default floating-point rounding mode\n used in the executable. Allowed rounding modes are near and zero (default is\n not allowed).\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] executable Memory location where the HSA runtime stores newly\n created executable handle. The initial state of the executable is\n ::HSA_EXECUTABLE_STATE_UNFROZEN.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p profile is invalid, or\n @p executable is NULL."]
    pub fn hsa_executable_create_alt(
        profile: hsa_profile_t,
        default_float_rounding_mode: hsa_default_float_rounding_mode_t,
        options: *const ::std::os::raw::c_char,
        executable: *mut hsa_executable_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy an executable.\n\n @details An executable handle becomes invalid after the executable has been\n destroyed. Code object handles that were loaded into this executable are\n still valid after the executable has been destroyed, and can be used as\n intended. Resources allocated outside and associated with this executable\n (such as external global or readonly variables) can be released after the\n executable has been destroyed.\n\n Executable should not be destroyed while kernels are in flight.\n\n @param[in] executable Executable.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid."]
    pub fn hsa_executable_destroy(executable: hsa_executable_t) -> hsa_status_t;
}
#[doc = " @brief Loaded code object handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_loaded_code_object_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_loaded_code_object_s"]
        [::std::mem::size_of::<hsa_loaded_code_object_s>() - 8usize];
    ["Alignment of hsa_loaded_code_object_s"]
        [::std::mem::align_of::<hsa_loaded_code_object_s>() - 8usize];
    ["Offset of field: hsa_loaded_code_object_s::handle"]
        [::std::mem::offset_of!(hsa_loaded_code_object_s, handle) - 0usize];
};
#[doc = " @brief Loaded code object handle."]
pub type hsa_loaded_code_object_t = hsa_loaded_code_object_s;
unsafe extern "C" {
    #[doc = " @brief Load a program code object into an executable.\n\n @details A program code object contains information about resources that are\n accessible by all kernel agents that run the executable, and can be loaded\n at most once into an executable.\n\n If the program code object uses extensions, the implementation must support\n them for this operation to return successfully.\n\n @param[in] executable Executable.\n\n @param[in] code_object_reader A code object reader that holds the program\n code object to load. If a code object reader is destroyed before all the\n associated executables are destroyed, the behavior is undefined.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] loaded_code_object Pointer to a memory location where the HSA\n runtime stores the loaded code object handle. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE The executable is frozen.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT_READER @p code_object_reader\n is invalid.\n\n @retval ::HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS The program code object is\n not compatible with the executable or the implementation (for example, the\n code object uses an extension that is not supported by the implementation)."]
    pub fn hsa_executable_load_program_code_object(
        executable: hsa_executable_t,
        code_object_reader: hsa_code_object_reader_t,
        options: *const ::std::os::raw::c_char,
        loaded_code_object: *mut hsa_loaded_code_object_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Load an agent code object into an executable.\n\n @details The agent code object contains all defined agent\n allocation variables, functions, indirect functions, and kernels in a given\n program for a given instruction set architecture.\n\n Any module linkage declaration must have been defined either by a define\n variable or by loading a code object that has a symbol with module linkage\n definition.\n\n The default floating-point rounding mode of the code object associated with\n @p code_object_reader must match that of the executable\n (::HSA_EXECUTABLE_INFO_DEFAULT_FLOAT_ROUNDING_MODE), or be default (in which\n case the value of ::HSA_EXECUTABLE_INFO_DEFAULT_FLOAT_ROUNDING_MODE is used).\n If the agent code object uses extensions, the implementation and the agent\n must support them for this operation to return successfully.\n\n @param[in] executable Executable.\n\n @param[in] agent Agent to load code object for. A code object can be loaded\n into an executable at most once for a given agent. The instruction set\n architecture of the code object must be supported by the agent.\n\n @param[in] code_object_reader A code object reader that holds the code object\n to load. If a code object reader is destroyed before all the associated\n executables are destroyed, the behavior is undefined.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] loaded_code_object Pointer to a memory location where the HSA\n runtime stores the loaded code object handle. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE The executable is frozen.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT_READER @p code_object_reader\n is invalid.\n\n @retval ::HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS The code object read by @p\n code_object_reader is not compatible with the agent (for example, the agent\n does not support the instruction set architecture of the code object), the\n executable (for example, there is a default floating-point mode mismatch\n between the two), or the implementation."]
    pub fn hsa_executable_load_agent_code_object(
        executable: hsa_executable_t,
        agent: hsa_agent_t,
        code_object_reader: hsa_code_object_reader_t,
        options: *const ::std::os::raw::c_char,
        loaded_code_object: *mut hsa_loaded_code_object_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Freeze the executable.\n\n @details No modifications to executable can be made after freezing: no code\n objects can be loaded to the executable, and no external variables can be\n defined. Freezing the executable does not prevent querying the executable's\n attributes. The application must define all the external variables in an\n executable before freezing it.\n\n @param[in] executable Executable.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_VARIABLE_UNDEFINED One or more variables are\n undefined in the executable.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE @p executable is already frozen."]
    pub fn hsa_executable_freeze(
        executable: hsa_executable_t,
        options: *const ::std::os::raw::c_char,
    ) -> hsa_status_t;
}
#[doc = " Profile this executable is created for. The type of this attribute is\n ::hsa_profile_t."]
pub const hsa_executable_info_t_HSA_EXECUTABLE_INFO_PROFILE: hsa_executable_info_t = 1;
#[doc = " Executable state. The type of this attribute is ::hsa_executable_state_t."]
pub const hsa_executable_info_t_HSA_EXECUTABLE_INFO_STATE: hsa_executable_info_t = 2;
#[doc = " Default floating-point rounding mode specified when executable was created.\n The type of this attribute is ::hsa_default_float_rounding_mode_t."]
pub const hsa_executable_info_t_HSA_EXECUTABLE_INFO_DEFAULT_FLOAT_ROUNDING_MODE:
    hsa_executable_info_t = 3;
#[doc = " @brief Executable attributes."]
pub type hsa_executable_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute for a given executable.\n\n @param[in] executable Executable.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n executable attribute, or @p value is NULL."]
    pub fn hsa_executable_get_info(
        executable: hsa_executable_t,
        attribute: hsa_executable_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Define an external global variable with program allocation.\n\n @details This function allows the application to provide the definition\n of a variable in the global segment memory with program allocation. The\n variable must be defined before loading a code object into an executable.\n In addition, code objects loaded must not define the variable.\n\n @param[in] executable Executable. Must not be in frozen state.\n\n @param[in] variable_name Name of the variable. The Programmer's Reference\n Manual describes the standard name mangling scheme.\n\n @param[in] address Address where the variable is defined. This address must\n be in global memory and can be read and written by any agent in the\n system. The application cannot deallocate the buffer pointed by @p address\n before @p executable is destroyed.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED The variable is\n already defined.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no variable with the\n @p variable_name.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE @p executable is frozen.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p variable_name is NULL."]
    pub fn hsa_executable_global_variable_define(
        executable: hsa_executable_t,
        variable_name: *const ::std::os::raw::c_char,
        address: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Define an external global variable with agent allocation.\n\n @details This function allows the application to provide the definition\n of a variable in the global segment memory with agent allocation. The\n variable must be defined before loading a code object into an executable.\n In addition, code objects loaded must not define the variable.\n\n @param[in] executable Executable. Must not be in frozen state.\n\n @param[in] agent Agent for which the variable is being defined.\n\n @param[in] variable_name Name of the variable. The Programmer's Reference\n Manual describes the standard name mangling scheme.\n\n @param[in] address Address where the variable is defined. This address must\n have been previously allocated using ::hsa_memory_allocate in a global region\n that is only visible to @p agent. The application cannot deallocate the\n buffer pointed by @p address before @p executable is destroyed.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT @p agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED The variable is\n already defined.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no variable with the\n @p variable_name.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE @p executable is frozen.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p variable_name is NULL."]
    pub fn hsa_executable_agent_global_variable_define(
        executable: hsa_executable_t,
        agent: hsa_agent_t,
        variable_name: *const ::std::os::raw::c_char,
        address: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Define an external readonly variable.\n\n @details This function allows the application to provide the definition\n of a variable in the readonly segment memory. The variable must be defined\n before loading a code object into an executable. In addition, code objects\n loaded must not define the variable.\n\n @param[in] executable Executable. Must not be in frozen state.\n\n @param[in] agent Agent for which the variable is being defined.\n\n @param[in] variable_name Name of the variable. The Programmer's Reference\n Manual describes the standard name mangling scheme.\n\n @param[in] address Address where the variable is defined. This address must\n have been previously allocated using ::hsa_memory_allocate in a readonly\n region associated with @p agent. The application cannot deallocate the buffer\n pointed by @p address before @p executable is destroyed.\n\n @param[in] address Address where the variable is defined. The buffer pointed\n by @p address is owned by the application, and cannot be deallocated before\n @p executable is destroyed.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE Executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT @p agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED The variable is\n already defined.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no variable with the\n @p variable_name.\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE @p executable is frozen.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p variable_name is NULL."]
    pub fn hsa_executable_readonly_variable_define(
        executable: hsa_executable_t,
        agent: hsa_agent_t,
        variable_name: *const ::std::os::raw::c_char,
        address: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Validate an executable. Checks that all code objects have matching\n machine model, profile, and default floating-point rounding mode. Checks that\n all declarations have definitions. Checks declaration-definition\n compatibility (see the HSA Programming Reference Manual for compatibility\n rules). Invoking this function is equivalent to invoking\n ::hsa_executable_validate_alt with no options.\n\n @param[in] executable Executable. Must be in frozen state.\n\n @param[out] result Memory location where the HSA runtime stores the\n validation result. If the executable passes validation, the result is 0.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE @p executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p result is NULL."]
    pub fn hsa_executable_validate(executable: hsa_executable_t, result: *mut u32) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Validate an executable. Checks that all code objects have matching\n machine model, profile, and default floating-point rounding mode. Checks that\n all declarations have definitions. Checks declaration-definition\n compatibility (see the HSA Programming Reference Manual for compatibility\n rules).\n\n @param[in] executable Executable. Must be in frozen state.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] result Memory location where the HSA runtime stores the\n validation result. If the executable passes validation, the result is 0.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE @p executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p result is NULL."]
    pub fn hsa_executable_validate_alt(
        executable: hsa_executable_t,
        options: *const ::std::os::raw::c_char,
        result: *mut u32,
    ) -> hsa_status_t;
}
#[doc = " @brief Executable symbol handle.\n\n The lifetime of an executable object symbol matches that of the executable\n associated with it. An operation on a symbol whose associated executable has\n been destroyed results in undefined behavior."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_executable_symbol_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_executable_symbol_s"][::std::mem::size_of::<hsa_executable_symbol_s>() - 8usize];
    ["Alignment of hsa_executable_symbol_s"]
        [::std::mem::align_of::<hsa_executable_symbol_s>() - 8usize];
    ["Offset of field: hsa_executable_symbol_s::handle"]
        [::std::mem::offset_of!(hsa_executable_symbol_s, handle) - 0usize];
};
#[doc = " @brief Executable symbol handle.\n\n The lifetime of an executable object symbol matches that of the executable\n associated with it. An operation on a symbol whose associated executable has\n been destroyed results in undefined behavior."]
pub type hsa_executable_symbol_t = hsa_executable_symbol_s;
unsafe extern "C" {
    #[doc = " @deprecated Use ::hsa_executable_get_symbol_by_name instead.\n\n @brief Get the symbol handle for a given a symbol name.\n\n @param[in] executable Executable.\n\n @param[in] module_name Module name. Must be NULL if the symbol has\n program linkage.\n\n @param[in] symbol_name Symbol name.\n\n @param[in] agent Agent associated with the symbol. If the symbol is\n independent of any agent (for example, a variable with program\n allocation), this argument is ignored.\n\n @param[in] call_convention Call convention associated with the symbol. If the\n symbol does not correspond to an indirect function, this argument is ignored.\n\n @param[out] symbol Memory location where the HSA runtime stores the symbol\n handle.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no symbol with a name\n that matches @p symbol_name.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p symbol_name is NULL, or\n @p symbol is NULL."]
    pub fn hsa_executable_get_symbol(
        executable: hsa_executable_t,
        module_name: *const ::std::os::raw::c_char,
        symbol_name: *const ::std::os::raw::c_char,
        agent: hsa_agent_t,
        call_convention: i32,
        symbol: *mut hsa_executable_symbol_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the symbol handle corresponding to a given a symbol name.\n\n @param[in] executable Executable.\n\n @param[in] symbol_name Symbol name. Must be a NUL-terminated character\n array. The Programmer's Reference Manual describes the standard name mangling\n scheme.\n\n @param[in] agent Pointer to the agent for which the symbol with the given\n name is defined. If the symbol corresponding to the given name has program\n allocation, @p agent must be NULL.\n\n @param[out] symbol Memory location where the HSA runtime stores the symbol\n handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no symbol with a name\n that matches @p symbol_name.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p symbol_name is NULL, or @p\n symbol is NULL."]
    pub fn hsa_executable_get_symbol_by_name(
        executable: hsa_executable_t,
        symbol_name: *const ::std::os::raw::c_char,
        agent: *const hsa_agent_t,
        symbol: *mut hsa_executable_symbol_t,
    ) -> hsa_status_t;
}
#[doc = " Variable."]
pub const hsa_symbol_kind_t_HSA_SYMBOL_KIND_VARIABLE: hsa_symbol_kind_t = 0;
#[doc = " Kernel."]
pub const hsa_symbol_kind_t_HSA_SYMBOL_KIND_KERNEL: hsa_symbol_kind_t = 1;
#[doc = " Indirect function."]
pub const hsa_symbol_kind_t_HSA_SYMBOL_KIND_INDIRECT_FUNCTION: hsa_symbol_kind_t = 2;
#[doc = " @brief Symbol type."]
pub type hsa_symbol_kind_t = ::std::os::raw::c_uint;
#[doc = " Module linkage."]
pub const hsa_symbol_linkage_t_HSA_SYMBOL_LINKAGE_MODULE: hsa_symbol_linkage_t = 0;
#[doc = " Program linkage."]
pub const hsa_symbol_linkage_t_HSA_SYMBOL_LINKAGE_PROGRAM: hsa_symbol_linkage_t = 1;
#[doc = " @brief Linkage type of a symbol."]
pub type hsa_symbol_linkage_t = ::std::os::raw::c_uint;
#[doc = " Agent allocation."]
pub const hsa_variable_allocation_t_HSA_VARIABLE_ALLOCATION_AGENT: hsa_variable_allocation_t = 0;
#[doc = " Program allocation."]
pub const hsa_variable_allocation_t_HSA_VARIABLE_ALLOCATION_PROGRAM: hsa_variable_allocation_t = 1;
#[doc = " @brief Allocation type of a variable."]
pub type hsa_variable_allocation_t = ::std::os::raw::c_uint;
#[doc = " Global memory segment."]
pub const hsa_variable_segment_t_HSA_VARIABLE_SEGMENT_GLOBAL: hsa_variable_segment_t = 0;
#[doc = " Readonly memory segment."]
pub const hsa_variable_segment_t_HSA_VARIABLE_SEGMENT_READONLY: hsa_variable_segment_t = 1;
#[doc = " @brief Memory segment associated with a variable."]
pub type hsa_variable_segment_t = ::std::os::raw::c_uint;
#[doc = " The kind of the symbol. The type of this attribute is ::hsa_symbol_kind_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_TYPE:
    hsa_executable_symbol_info_t = 0;
#[doc = " The length of the symbol name in bytes, not including the NUL terminator.\n The type of this attribute is uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH:
    hsa_executable_symbol_info_t = 1;
#[doc = " The name of the symbol. The type of this attribute is character array with\n the length equal to the value of ::HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH\n attribute."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_NAME:
    hsa_executable_symbol_info_t = 2;
#[doc = " @deprecated\n\n The length of the module name in bytes (not including the NUL terminator)\n to which this symbol belongs if this symbol has module linkage, otherwise 0\n is returned. The type of this attribute is uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_MODULE_NAME_LENGTH:
    hsa_executable_symbol_info_t = 3;
#[doc = " @deprecated\n\n The module name to which this symbol belongs if this symbol has module\n linkage, otherwise an empty string is returned. The type of this attribute\n is character array with the length equal to the value of\n ::HSA_EXECUTABLE_SYMBOL_INFO_MODULE_NAME_LENGTH attribute."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_MODULE_NAME:
    hsa_executable_symbol_info_t = 4;
#[doc = " @deprecated\n\n Agent associated with this symbol. If the symbol is a variable, the\n value of this attribute is only defined if\n ::HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ALLOCATION is\n ::HSA_VARIABLE_ALLOCATION_AGENT. The type of this attribute is hsa_agent_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_AGENT:
    hsa_executable_symbol_info_t = 20;
#[doc = " The address of the variable. The value of this attribute is undefined if\n the symbol is not a variable. The type of this attribute is uint64_t.\n\n If executable's state is ::HSA_EXECUTABLE_STATE_UNFROZEN, then 0 is\n returned."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS:
    hsa_executable_symbol_info_t = 21;
#[doc = " The linkage kind of the symbol. The type of this attribute is\n ::hsa_symbol_linkage_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_LINKAGE:
    hsa_executable_symbol_info_t = 5;
#[doc = " Indicates whether the symbol corresponds to a definition. The type of this\n attribute is bool."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_IS_DEFINITION:
    hsa_executable_symbol_info_t = 17;
#[doc = " @deprecated\n\n The allocation kind of the variable. The value of this attribute is\n undefined if the symbol is not a variable.  The type of this attribute is\n ::hsa_variable_allocation_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ALLOCATION:
    hsa_executable_symbol_info_t = 6;
#[doc = " @deprecated\n\n The segment kind of the variable. The value of this attribute is undefined\n if the symbol is not a variable. The type of this attribute is\n ::hsa_variable_segment_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SEGMENT:
    hsa_executable_symbol_info_t = 7;
#[doc = " @deprecated\n\n Alignment of the symbol in memory. The value of this attribute is undefined\n if the symbol is not a variable. The type of this attribute is uint32_t.\n\n The current alignment of the variable in memory may be greater than the\n value specified in the source program variable declaration."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ALIGNMENT:
    hsa_executable_symbol_info_t = 8;
#[doc = " @deprecated\n\n Size of the variable. The value of this attribute is undefined if\n the symbol is not a variable. The type of this attribute is uint32_t.\n\n A value of 0 is returned if the variable is an external variable and has an\n unknown dimension."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE:
    hsa_executable_symbol_info_t = 9;
#[doc = " @deprecated\n\n Indicates whether the variable is constant. The value of this attribute is\n undefined if the symbol is not a variable. The type of this attribute is\n bool."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_IS_CONST:
    hsa_executable_symbol_info_t = 10;
#[doc = " Kernel object handle, used in the kernel dispatch packet. The value of this\n attribute is undefined if the symbol is not a kernel. The type of this\n attribute is uint64_t.\n\n If the state of the executable is ::HSA_EXECUTABLE_STATE_UNFROZEN, then 0\n is returned."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT:
    hsa_executable_symbol_info_t = 22;
#[doc = " Size of kernarg segment memory that is required to hold the values of the\n kernel arguments, in bytes. Must be a multiple of 16. The value of this\n attribute is undefined if the symbol is not a kernel. The type of this\n attribute is uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE:
    hsa_executable_symbol_info_t = 11;
#[doc = " Alignment (in bytes) of the buffer used to pass arguments to the kernel,\n which is the maximum of 16 and the maximum alignment of any of the kernel\n arguments. The value of this attribute is undefined if the symbol is not a\n kernel. The type of this attribute is uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_ALIGNMENT : hsa_executable_symbol_info_t = 12 ;
#[doc = " Size of static group segment memory required by the kernel (per\n work-group), in bytes. The value of this attribute is undefined\n if the symbol is not a kernel. The type of this attribute is uint32_t.\n\n The reported amount does not include any dynamically allocated group\n segment memory that may be requested by the application when a kernel is\n dispatched."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE:
    hsa_executable_symbol_info_t = 13;
#[doc = " Size of static private, spill, and arg segment memory required by\n this kernel (per work-item), in bytes. The value of this attribute is\n undefined if the symbol is not a kernel. The type of this attribute is\n uint32_t.\n\n If the value of ::HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK is\n true, the kernel may use more private memory than the reported value, and\n the application must add the dynamic call stack usage to @a\n private_segment_size when populating a kernel dispatch packet."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE:
    hsa_executable_symbol_info_t = 14;
#[doc = " Dynamic callstack flag. The value of this attribute is undefined if the\n symbol is not a kernel. The type of this attribute is bool.\n\n If this flag is set (the value is true), the kernel uses a dynamically\n sized call stack. This can happen if recursive calls, calls to indirect\n functions, or the HSAIL alloca instruction are present in the kernel."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK:
    hsa_executable_symbol_info_t = 15;
#[doc = " @deprecated\n\n Call convention of the kernel. The value of this attribute is undefined if\n the symbol is not a kernel. The type of this attribute is uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_CALL_CONVENTION:
    hsa_executable_symbol_info_t = 18;
#[doc = " Indirect function object handle. The value of this attribute is undefined\n if the symbol is not an indirect function, or the associated agent does\n not support the Full Profile. The type of this attribute depends on the\n machine model: the type is uint32_t for small machine model, and uint64_t\n for large model.\n\n If the state of the executable is ::HSA_EXECUTABLE_STATE_UNFROZEN, then 0\n is returned."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_INDIRECT_FUNCTION_OBJECT:
    hsa_executable_symbol_info_t = 23;
#[doc = " @deprecated\n\n Call convention of the indirect function. The value of this attribute is\n undefined if the symbol is not an indirect function, or the associated\n agent does not support the Full Profile. The type of this attribute is\n uint32_t."]
pub const hsa_executable_symbol_info_t_HSA_EXECUTABLE_SYMBOL_INFO_INDIRECT_FUNCTION_CALL_CONVENTION : hsa_executable_symbol_info_t = 16 ;
#[doc = " @brief Executable symbol attributes."]
pub type hsa_executable_symbol_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute for a given executable symbol.\n\n @param[in] executable_symbol Executable symbol.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE_SYMBOL The executable symbol is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n executable symbol attribute, or @p value is NULL."]
    pub fn hsa_executable_symbol_get_info(
        executable_symbol: hsa_executable_symbol_t,
        attribute: hsa_executable_symbol_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Iterate over the symbols in a executable, and invoke an\n application-defined callback on every iteration.\n\n @param[in] executable Executable.\n\n @param[in] callback Callback to be invoked once per executable symbol. The\n HSA runtime passes three arguments to the callback: the executable, a symbol,\n and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n ::hsa_executable_iterate_symbols returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_executable_iterate_symbols(
        executable: hsa_executable_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                exec: hsa_executable_t,
                symbol: hsa_executable_symbol_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the kernels, indirect functions, and agent allocation\n variables in an executable for a given agent, and invoke an application-\n defined callback on every iteration.\n\n @param[in] executable Executable.\n\n @param[in] agent Agent.\n\n @param[in] callback Callback to be invoked once per executable symbol. The\n HSA runtime passes three arguments to the callback: the executable, a symbol,\n and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n ::hsa_executable_iterate_symbols returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_executable_iterate_agent_symbols(
        executable: hsa_executable_t,
        agent: hsa_agent_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                exec: hsa_executable_t,
                agent: hsa_agent_t,
                symbol: hsa_executable_symbol_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the program allocation variables in an executable, and\n invoke an application-defined callback on every iteration.\n\n @param[in] executable Executable.\n\n @param[in] callback Callback to be invoked once per executable symbol. The\n HSA runtime passes three arguments to the callback: the executable, a symbol,\n and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n ::hsa_executable_iterate_symbols returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_executable_iterate_program_symbols(
        executable: hsa_executable_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                exec: hsa_executable_t,
                symbol: hsa_executable_symbol_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " @deprecated\n\n @brief Struct containing an opaque handle to a code object, which contains\n ISA for finalized kernels and indirect functions together with information\n about the global or readonly segment variables they reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_code_object_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_code_object_s"][::std::mem::size_of::<hsa_code_object_s>() - 8usize];
    ["Alignment of hsa_code_object_s"][::std::mem::align_of::<hsa_code_object_s>() - 8usize];
    ["Offset of field: hsa_code_object_s::handle"]
        [::std::mem::offset_of!(hsa_code_object_s, handle) - 0usize];
};
#[doc = " @deprecated\n\n @brief Struct containing an opaque handle to a code object, which contains\n ISA for finalized kernels and indirect functions together with information\n about the global or readonly segment variables they reference."]
pub type hsa_code_object_t = hsa_code_object_s;
#[doc = " @deprecated\n\n @brief Application data handle that is passed to the serialization\n and deserialization functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_callback_data_s {
    #[doc = " Opaque handle."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_callback_data_s"][::std::mem::size_of::<hsa_callback_data_s>() - 8usize];
    ["Alignment of hsa_callback_data_s"][::std::mem::align_of::<hsa_callback_data_s>() - 8usize];
    ["Offset of field: hsa_callback_data_s::handle"]
        [::std::mem::offset_of!(hsa_callback_data_s, handle) - 0usize];
};
#[doc = " @deprecated\n\n @brief Application data handle that is passed to the serialization\n and deserialization functions."]
pub type hsa_callback_data_t = hsa_callback_data_s;
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Serialize a code object. Can be used for offline finalization,\n install-time finalization, disk code caching, etc.\n\n @param[in] code_object Code object.\n\n @param[in] alloc_callback Callback function for memory allocation. Must not\n be NULL. The HSA runtime passes three arguments to the callback: the\n allocation size, the application data, and a pointer to a memory location\n where the application stores the allocation result. The HSA runtime invokes\n @p alloc_callback once to allocate a buffer that contains the serialized\n version of @p code_object.  If the callback returns a status code other than\n ::HSA_STATUS_SUCCESS, this function returns the same code.\n\n @param[in] callback_data Application data that is passed to @p\n alloc_callback. May be NULL.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] serialized_code_object Memory location where the HSA runtime\n stores a pointer to the serialized code object. Must not be NULL.\n\n @param[out] serialized_code_object_size Memory location where the HSA runtime\n stores the size (in bytes) of @p serialized_code_object. The returned value\n matches the allocation size passed by the HSA runtime to @p\n alloc_callback. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p alloc_callback, @p\n serialized_code_object, or @p serialized_code_object_size are NULL."]
    pub fn hsa_code_object_serialize(
        code_object: hsa_code_object_t,
        alloc_callback: ::std::option::Option<
            unsafe extern "C" fn(
                size: usize,
                data: hsa_callback_data_t,
                address: *mut *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        callback_data: hsa_callback_data_t,
        options: *const ::std::os::raw::c_char,
        serialized_code_object: *mut *mut ::std::os::raw::c_void,
        serialized_code_object_size: *mut usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Deserialize a code object.\n\n @param[in] serialized_code_object A serialized code object. Must not be NULL.\n\n @param[in] serialized_code_object_size The size (in bytes) of @p\n serialized_code_object. Must not be 0.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @param[out] code_object Memory location where the HSA runtime stores the\n deserialized code object.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p serialized_code_object, or @p\n code_object are NULL, or @p serialized_code_object_size is 0."]
    pub fn hsa_code_object_deserialize(
        serialized_code_object: *mut ::std::os::raw::c_void,
        serialized_code_object_size: usize,
        options: *const ::std::os::raw::c_char,
        code_object: *mut hsa_code_object_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Destroy a code object.\n\n @details The lifetime of a code object must exceed that of any executable\n where it has been loaded. If an executable that loaded @p code_object has not\n been destroyed, the behavior is undefined.\n\n @param[in] code_object Code object. The handle becomes invalid after it has\n been destroyed.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid."]
    pub fn hsa_code_object_destroy(code_object: hsa_code_object_t) -> hsa_status_t;
}
#[doc = " Produces code object that contains ISA for all kernels and indirect\n functions in HSA source."]
pub const hsa_code_object_type_t_HSA_CODE_OBJECT_TYPE_PROGRAM: hsa_code_object_type_t = 0;
#[doc = " @deprecated\n\n @brief Code object type."]
pub type hsa_code_object_type_t = ::std::os::raw::c_uint;
#[doc = " The version of the code object. The type of this attribute is a\n NUL-terminated char[64]. The name must be at most 63 characters long (not\n including the NUL terminator) and all array elements not used for the name\n must be NUL."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_VERSION: hsa_code_object_info_t = 0;
#[doc = " Type of code object. The type of this attribute is\n ::hsa_code_object_type_t."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_TYPE: hsa_code_object_info_t = 1;
#[doc = " Instruction set architecture this code object is produced for. The type of\n this attribute is ::hsa_isa_t."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_ISA: hsa_code_object_info_t = 2;
#[doc = " Machine model this code object is produced for. The type of this attribute\n is ::hsa_machine_model_t."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_MACHINE_MODEL: hsa_code_object_info_t = 3;
#[doc = " Profile this code object is produced for. The type of this attribute is\n ::hsa_profile_t."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_PROFILE: hsa_code_object_info_t = 4;
#[doc = " Default floating-point rounding mode used when the code object is\n produced. The type of this attribute is\n ::hsa_default_float_rounding_mode_t."]
pub const hsa_code_object_info_t_HSA_CODE_OBJECT_INFO_DEFAULT_FLOAT_ROUNDING_MODE:
    hsa_code_object_info_t = 5;
#[doc = " @deprecated\n\n @brief Code object attributes."]
pub type hsa_code_object_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Get the current value of an attribute for a given code object.\n\n @param[in] code_object Code object.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n code object attribute, or @p value is NULL."]
    pub fn hsa_code_object_get_info(
        code_object: hsa_code_object_t,
        attribute: hsa_code_object_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Load code object into the executable.\n\n @details Every global or readonly variable that is external must be defined\n before loading the code object. An internal global or readonly variable is\n allocated once the code object, that is being loaded, references this\n variable and this variable is not allocated.\n\n Any module linkage declaration must have been defined either by a define\n variable or by loading a code object that has a symbol with module linkage\n definition.\n\n @param[in] executable Executable.\n\n @param[in] agent Agent to load code object for. The agent must support the\n default floating-point rounding mode used by @p code_object.\n\n @param[in] code_object Code object to load.  The lifetime of the code object\n must exceed that of the executable: if @p code_object is destroyed before @p\n executable, the behavior is undefined.\n\n @param[in] options Standard and vendor-specific options. Unknown options are\n ignored. A standard option begins with the \"-hsa_\" prefix. Options beginning\n with the \"-hsa_ext_<extension_name>_\" prefix are reserved for extensions. A\n vendor-specific option begins with the \"-<vendor_name>_\" prefix. Must be a\n NUL-terminated string. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to\n allocate the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_EXECUTABLE The executable is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS @p agent is not compatible\n with @p code_object (for example, @p agent does not support the default\n floating-point rounding mode specified by @p code_object), or @p code_object\n is not compatible with @p executable (for example, @p code_object and @p\n executable have different machine models or profiles).\n\n @retval ::HSA_STATUS_ERROR_FROZEN_EXECUTABLE @p executable is frozen."]
    pub fn hsa_executable_load_code_object(
        executable: hsa_executable_t,
        agent: hsa_agent_t,
        code_object: hsa_code_object_t,
        options: *const ::std::os::raw::c_char,
    ) -> hsa_status_t;
}
#[doc = " @deprecated\n\n @brief Code object symbol handle.\n\n The lifetime of a code object symbol matches that of the code object\n associated with it. An operation on a symbol whose associated code object has\n been destroyed results in undefined behavior."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_code_symbol_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_code_symbol_s"][::std::mem::size_of::<hsa_code_symbol_s>() - 8usize];
    ["Alignment of hsa_code_symbol_s"][::std::mem::align_of::<hsa_code_symbol_s>() - 8usize];
    ["Offset of field: hsa_code_symbol_s::handle"]
        [::std::mem::offset_of!(hsa_code_symbol_s, handle) - 0usize];
};
#[doc = " @deprecated\n\n @brief Code object symbol handle.\n\n The lifetime of a code object symbol matches that of the code object\n associated with it. An operation on a symbol whose associated code object has\n been destroyed results in undefined behavior."]
pub type hsa_code_symbol_t = hsa_code_symbol_s;
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Get the symbol handle within a code object for a given a symbol name.\n\n @param[in] code_object Code object.\n\n @param[in] symbol_name Symbol name.\n\n @param[out] symbol Memory location where the HSA runtime stores the symbol\n handle.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no symbol with a name\n that matches @p symbol_name.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p symbol_name is NULL, or\n @p symbol is NULL."]
    pub fn hsa_code_object_get_symbol(
        code_object: hsa_code_object_t,
        symbol_name: *const ::std::os::raw::c_char,
        symbol: *mut hsa_code_symbol_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Get the symbol handle within a code object for a given a symbol name.\n\n @param[in] code_object Code object.\n\n @param[in] module_name Module name. Must be NULL if the symbol has\n program linkage.\n\n @param[in] symbol_name Symbol name.\n\n @param[out] symbol Memory location where the HSA runtime stores the symbol\n handle.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SYMBOL_NAME There is no symbol with a name\n that matches @p symbol_name.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p symbol_name is NULL, or\n @p symbol is NULL."]
    pub fn hsa_code_object_get_symbol_from_name(
        code_object: hsa_code_object_t,
        module_name: *const ::std::os::raw::c_char,
        symbol_name: *const ::std::os::raw::c_char,
        symbol: *mut hsa_code_symbol_t,
    ) -> hsa_status_t;
}
#[doc = " The type of the symbol. The type of this attribute is ::hsa_symbol_kind_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_TYPE: hsa_code_symbol_info_t = 0;
#[doc = " The length of the symbol name in bytes, not including the NUL terminator.\n The type of this attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_NAME_LENGTH: hsa_code_symbol_info_t = 1;
#[doc = " The name of the symbol. The type of this attribute is character array with\n the length equal to the value of ::HSA_CODE_SYMBOL_INFO_NAME_LENGTH\n attribute."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_NAME: hsa_code_symbol_info_t = 2;
#[doc = " The length of the module name in bytes (not including the NUL terminator)\n to which this symbol belongs if this symbol has module linkage, otherwise 0\n is returned. The type of this attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_MODULE_NAME_LENGTH: hsa_code_symbol_info_t =
    3;
#[doc = " The module name to which this symbol belongs if this symbol has module\n linkage, otherwise an empty string is returned. The type of this attribute\n is character array with the length equal to the value of\n ::HSA_CODE_SYMBOL_INFO_MODULE_NAME_LENGTH attribute."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_MODULE_NAME: hsa_code_symbol_info_t = 4;
#[doc = " The linkage kind of the symbol. The type of this attribute is\n ::hsa_symbol_linkage_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_LINKAGE: hsa_code_symbol_info_t = 5;
#[doc = " Indicates whether the symbol corresponds to a definition. The type of this\n attribute is bool."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_IS_DEFINITION: hsa_code_symbol_info_t = 17;
#[doc = " The allocation kind of the variable. The value of this attribute is\n undefined if the symbol is not a variable. The type of this attribute is\n ::hsa_variable_allocation_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_VARIABLE_ALLOCATION: hsa_code_symbol_info_t =
    6;
#[doc = " The segment kind of the variable. The value of this attribute is\n undefined if the symbol is not a variable. The type of this attribute is\n ::hsa_variable_segment_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_VARIABLE_SEGMENT: hsa_code_symbol_info_t = 7;
#[doc = " Alignment of the symbol in memory. The value of this attribute is undefined\n if the symbol is not a variable. The type of this attribute is uint32_t.\n\n The current alignment of the variable in memory may be greater than the\n value specified in the source program variable declaration."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_VARIABLE_ALIGNMENT: hsa_code_symbol_info_t =
    8;
#[doc = " Size of the variable. The value of this attribute is undefined if the\n symbol is not a variable. The type of this attribute is uint32_t.\n\n A size of 0 is returned if the variable is an external variable and has an\n unknown dimension."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_VARIABLE_SIZE: hsa_code_symbol_info_t = 9;
#[doc = " Indicates whether the variable is constant. The value of this attribute is\n undefined if the symbol is not a variable. The type of this attribute is\n bool."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_VARIABLE_IS_CONST: hsa_code_symbol_info_t =
    10;
#[doc = " Size of kernarg segment memory that is required to hold the values of the\n kernel arguments, in bytes. Must be a multiple of 16. The value of this\n attribute is undefined if the symbol is not a kernel. The type of this\n attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE:
    hsa_code_symbol_info_t = 11;
#[doc = " Alignment (in bytes) of the buffer used to pass arguments to the kernel,\n which is the maximum of 16 and the maximum alignment of any of the kernel\n arguments. The value of this attribute is undefined if the symbol is not a\n kernel. The type of this attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_ALIGNMENT:
    hsa_code_symbol_info_t = 12;
#[doc = " Size of static group segment memory required by the kernel (per\n work-group), in bytes. The value of this attribute is undefined\n if the symbol is not a kernel. The type of this attribute is uint32_t.\n\n The reported amount does not include any dynamically allocated group\n segment memory that may be requested by the application when a kernel is\n dispatched."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE:
    hsa_code_symbol_info_t = 13;
#[doc = " Size of static private, spill, and arg segment memory required by\n this kernel (per work-item), in bytes. The value of this attribute is\n undefined if the symbol is not a kernel. The type of this attribute is\n uint32_t.\n\n If the value of ::HSA_CODE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK is true,\n the kernel may use more private memory than the reported value, and the\n application must add the dynamic call stack usage to @a\n private_segment_size when populating a kernel dispatch packet."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE:
    hsa_code_symbol_info_t = 14;
#[doc = " Dynamic callstack flag. The value of this attribute is undefined if the\n symbol is not a kernel. The type of this attribute is bool.\n\n If this flag is set (the value is true), the kernel uses a dynamically\n sized call stack. This can happen if recursive calls, calls to indirect\n functions, or the HSAIL alloca instruction are present in the kernel."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK:
    hsa_code_symbol_info_t = 15;
#[doc = " Call convention of the kernel. The value of this attribute is undefined if\n the symbol is not a kernel. The type of this attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_CALL_CONVENTION:
    hsa_code_symbol_info_t = 18;
#[doc = " Call convention of the indirect function. The value of this attribute is\n undefined if the symbol is not an indirect function. The type of this\n attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_INDIRECT_FUNCTION_CALL_CONVENTION:
    hsa_code_symbol_info_t = 16;
#[doc = " Wavefront size used by the kernel. The value of this attribute is either\n 32 or 64. The type of this attribute is uint32_t."]
pub const hsa_code_symbol_info_t_HSA_CODE_SYMBOL_INFO_KERNEL_WAVEFRONT_SIZE:
    hsa_code_symbol_info_t = 19;
#[doc = " @deprecated\n\n @brief Code object symbol attributes."]
pub type hsa_code_symbol_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Get the current value of an attribute for a given code symbol.\n\n @param[in] code_symbol Code symbol.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_SYMBOL The code symbol is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p attribute is an invalid\n code symbol attribute, or @p value is NULL."]
    pub fn hsa_code_symbol_get_info(
        code_symbol: hsa_code_symbol_t,
        attribute: hsa_code_symbol_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @deprecated\n\n @brief Iterate over the symbols in a code object, and invoke an\n application-defined callback on every iteration.\n\n @param[in] code_object Code object.\n\n @param[in] callback Callback to be invoked once per code object symbol. The\n HSA runtime passes three arguments to the callback: the code object, a\n symbol, and the application data.  If @p callback returns a status other than\n ::HSA_STATUS_SUCCESS for a particular iteration, the traversal stops and\n ::hsa_code_object_iterate_symbols returns that status value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_CODE_OBJECT @p code_object is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_code_object_iterate_symbols(
        code_object: hsa_code_object_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                code_object: hsa_code_object_t,
                symbol: hsa_code_symbol_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " Image format is not supported."]
pub const HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED: _bindgen_ty_1 = 12288;
#[doc = " Image size is not supported."]
pub const HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED: _bindgen_ty_1 = 12289;
#[doc = " Image pitch is not supported or invalid."]
pub const HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED: _bindgen_ty_1 = 12290;
#[doc = " Sampler descriptor is not supported or invalid."]
pub const HSA_EXT_STATUS_ERROR_SAMPLER_DESCRIPTOR_UNSUPPORTED: _bindgen_ty_1 = 12291;
#[doc = " @brief Enumeration constants added to ::hsa_status_t by this extension.\n\n @remark Additions to hsa_status_t"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Maximum number of elements in 1D images. Must be at least 16384. The type\n of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS: _bindgen_ty_2 = 12288;
#[doc = " Maximum number of elements in 1DA images. Must be at least 16384. The type\n of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_IMAGE_1DA_MAX_ELEMENTS: _bindgen_ty_2 = 12289;
#[doc = " Maximum number of elements in 1DB images. Must be at least 65536. The type\n of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_IMAGE_1DB_MAX_ELEMENTS: _bindgen_ty_2 = 12290;
#[doc = " Maximum dimensions (width, height) of 2D images, in image elements. The X\n and Y maximums must be at least 16384. The type of this attribute is\n size_t[2]."]
pub const HSA_EXT_AGENT_INFO_IMAGE_2D_MAX_ELEMENTS: _bindgen_ty_2 = 12291;
#[doc = " Maximum dimensions (width, height) of 2DA images, in image elements. The X\n and Y maximums must be at least 16384. The type of this attribute is\n size_t[2]."]
pub const HSA_EXT_AGENT_INFO_IMAGE_2DA_MAX_ELEMENTS: _bindgen_ty_2 = 12292;
#[doc = " Maximum dimensions (width, height) of 2DDEPTH images, in image\n elements. The X and Y maximums must be at least 16384. The type of this\n attribute is size_t[2]."]
pub const HSA_EXT_AGENT_INFO_IMAGE_2DDEPTH_MAX_ELEMENTS: _bindgen_ty_2 = 12293;
#[doc = " Maximum dimensions (width, height) of 2DADEPTH images, in image\n elements. The X and Y maximums must be at least 16384. The type of this\n attribute is size_t[2]."]
pub const HSA_EXT_AGENT_INFO_IMAGE_2DADEPTH_MAX_ELEMENTS: _bindgen_ty_2 = 12294;
#[doc = " Maximum dimensions (width, height, depth) of 3D images, in image\n elements. The maximum along any dimension must be at least 2048. The type\n of this attribute is size_t[3]."]
pub const HSA_EXT_AGENT_INFO_IMAGE_3D_MAX_ELEMENTS: _bindgen_ty_2 = 12295;
#[doc = " Maximum number of image layers in a image array. Must be at least 2048. The\n type of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS: _bindgen_ty_2 = 12296;
#[doc = " Maximum number of read-only image handles that can be created for an agent at any one\n time. Must be at least 128. The type of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_MAX_IMAGE_RD_HANDLES: _bindgen_ty_2 = 12297;
#[doc = " Maximum number of write-only and read-write image handles (combined) that\n can be created for an agent at any one time. Must be at least 64. The type of this\n attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_MAX_IMAGE_RORW_HANDLES: _bindgen_ty_2 = 12298;
#[doc = " Maximum number of sampler handlers that can be created for an agent at any one\n time. Must be at least 16. The type of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_MAX_SAMPLER_HANDLERS: _bindgen_ty_2 = 12299;
#[doc = " Image pitch alignment. The agent only supports linear image data\n layouts with a row pitch that is a multiple of this value. Must be\n a power of 2. The type of this attribute is size_t."]
pub const HSA_EXT_AGENT_INFO_IMAGE_LINEAR_ROW_PITCH_ALIGNMENT: _bindgen_ty_2 = 12300;
#[doc = " @brief Enumeration constants added to ::hsa_agent_info_t by this\n extension.\n\n @remark Additions to hsa_agent_info_t"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " @brief Image handle, populated by ::hsa_ext_image_create or\n ::hsa_ext_image_create_with_layout. Image\n handles are only unique within an agent, not across agents.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_image_s {
    #[doc = "  Opaque handle. For a given agent, two handles reference the same object of\n  the enclosing type if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_image_s"][::std::mem::size_of::<hsa_ext_image_s>() - 8usize];
    ["Alignment of hsa_ext_image_s"][::std::mem::align_of::<hsa_ext_image_s>() - 8usize];
    ["Offset of field: hsa_ext_image_s::handle"]
        [::std::mem::offset_of!(hsa_ext_image_s, handle) - 0usize];
};
#[doc = " @brief Image handle, populated by ::hsa_ext_image_create or\n ::hsa_ext_image_create_with_layout. Image\n handles are only unique within an agent, not across agents.\n"]
pub type hsa_ext_image_t = hsa_ext_image_s;
#[doc = " One-dimensional image addressed by width coordinate."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_1D: hsa_ext_image_geometry_t = 0;
#[doc = " Two-dimensional image addressed by width and height coordinates."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_2D: hsa_ext_image_geometry_t = 1;
#[doc = " Three-dimensional image addressed by width, height, and depth coordinates."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_3D: hsa_ext_image_geometry_t = 2;
#[doc = " Array of one-dimensional images with the same size and format. 1D arrays\n are addressed by width and index coordinate."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_1DA: hsa_ext_image_geometry_t = 3;
#[doc = " Array of two-dimensional images with the same size and format. 2D arrays\n are addressed by width,  height, and index coordinates."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_2DA: hsa_ext_image_geometry_t = 4;
#[doc = " One-dimensional image addressed by width coordinate. It has\n specific restrictions compared to ::HSA_EXT_IMAGE_GEOMETRY_1D. An\n image with an opaque image data layout will always use a linear\n image data layout, and one with an explicit image data layout\n must specify ::HSA_EXT_IMAGE_DATA_LAYOUT_LINEAR."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_1DB: hsa_ext_image_geometry_t = 5;
#[doc = " Two-dimensional depth image addressed by width and height coordinates."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_2DDEPTH: hsa_ext_image_geometry_t = 6;
#[doc = " Array of two-dimensional depth images with the same size and format. 2D\n arrays are addressed by width, height, and index coordinates."]
pub const hsa_ext_image_geometry_t_HSA_EXT_IMAGE_GEOMETRY_2DADEPTH: hsa_ext_image_geometry_t = 7;
#[doc = " @brief Geometry associated with the image. This specifies the\n number of image dimensions and whether the image is an image\n array. See the <em>Image Geometry</em> section in the <em>HSA\n Programming Reference Manual</em> for definitions on each\n geometry. The enumeration values match the BRIG type @p\n hsa_ext_brig_image_geometry_t."]
pub type hsa_ext_image_geometry_t = ::std::os::raw::c_uint;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT8:
    hsa_ext_image_channel_type_t = 0;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT16:
    hsa_ext_image_channel_type_t = 1;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT8:
    hsa_ext_image_channel_type_t = 2;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT16:
    hsa_ext_image_channel_type_t = 3;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT24:
    hsa_ext_image_channel_type_t = 4;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_555:
    hsa_ext_image_channel_type_t = 5;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_565:
    hsa_ext_image_channel_type_t = 6;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_101010:
    hsa_ext_image_channel_type_t = 7;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT8:
    hsa_ext_image_channel_type_t = 8;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT16:
    hsa_ext_image_channel_type_t = 9;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT32:
    hsa_ext_image_channel_type_t = 10;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT8:
    hsa_ext_image_channel_type_t = 11;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT16:
    hsa_ext_image_channel_type_t = 12;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT32:
    hsa_ext_image_channel_type_t = 13;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_HALF_FLOAT:
    hsa_ext_image_channel_type_t = 14;
pub const hsa_ext_image_channel_type_t_HSA_EXT_IMAGE_CHANNEL_TYPE_FLOAT:
    hsa_ext_image_channel_type_t = 15;
#[doc = " @brief Channel type associated with the elements of an image. See\n the <em>Channel Type</em> section in the <em>HSA Programming Reference\n Manual</em> for definitions on each channel type. The\n enumeration values and definition match the BRIG type @p\n hsa_ext_brig_image_channel_type_t."]
pub type hsa_ext_image_channel_type_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_ext_image_channel_type_t constants."]
pub type hsa_ext_image_channel_type32_t = u32;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_A:
    hsa_ext_image_channel_order_t = 0;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_R:
    hsa_ext_image_channel_order_t = 1;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RX:
    hsa_ext_image_channel_order_t = 2;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RG:
    hsa_ext_image_channel_order_t = 3;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RGX:
    hsa_ext_image_channel_order_t = 4;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RA:
    hsa_ext_image_channel_order_t = 5;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RGB:
    hsa_ext_image_channel_order_t = 6;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RGBX:
    hsa_ext_image_channel_order_t = 7;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_RGBA:
    hsa_ext_image_channel_order_t = 8;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_BGRA:
    hsa_ext_image_channel_order_t = 9;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_ARGB:
    hsa_ext_image_channel_order_t = 10;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_ABGR:
    hsa_ext_image_channel_order_t = 11;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB:
    hsa_ext_image_channel_order_t = 12;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBX:
    hsa_ext_image_channel_order_t = 13;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBA:
    hsa_ext_image_channel_order_t = 14;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_SBGRA:
    hsa_ext_image_channel_order_t = 15;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_INTENSITY:
    hsa_ext_image_channel_order_t = 16;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_LUMINANCE:
    hsa_ext_image_channel_order_t = 17;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH:
    hsa_ext_image_channel_order_t = 18;
pub const hsa_ext_image_channel_order_t_HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH_STENCIL:
    hsa_ext_image_channel_order_t = 19;
#[doc = " @brief Channel order associated with the elements of an image. See\n the <em>Channel Order</em> section in the <em>HSA Programming Reference\n Manual</em> for definitions on each channel order. The\n enumeration values match the BRIG type @p\n hsa_ext_brig_image_channel_order_t."]
pub type hsa_ext_image_channel_order_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_ext_image_channel_order_t constants."]
pub type hsa_ext_image_channel_order32_t = u32;
#[doc = " @brief Image format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_image_format_s {
    #[doc = " Channel type."]
    pub channel_type: hsa_ext_image_channel_type32_t,
    #[doc = " Channel order."]
    pub channel_order: hsa_ext_image_channel_order32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_image_format_s"][::std::mem::size_of::<hsa_ext_image_format_s>() - 8usize];
    ["Alignment of hsa_ext_image_format_s"]
        [::std::mem::align_of::<hsa_ext_image_format_s>() - 4usize];
    ["Offset of field: hsa_ext_image_format_s::channel_type"]
        [::std::mem::offset_of!(hsa_ext_image_format_s, channel_type) - 0usize];
    ["Offset of field: hsa_ext_image_format_s::channel_order"]
        [::std::mem::offset_of!(hsa_ext_image_format_s, channel_order) - 4usize];
};
#[doc = " @brief Image format."]
pub type hsa_ext_image_format_t = hsa_ext_image_format_s;
#[doc = " @brief Implementation independent image descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_image_descriptor_s {
    #[doc = " Image geometry."]
    pub geometry: hsa_ext_image_geometry_t,
    #[doc = " Width of the image, in components."]
    pub width: usize,
    #[doc = " Height of the image, in components. Only used if the geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_2D, ::HSA_EXT_IMAGE_GEOMETRY_3D,\n HSA_EXT_IMAGE_GEOMETRY_2DA, HSA_EXT_IMAGE_GEOMETRY_2DDEPTH, or\n HSA_EXT_IMAGE_GEOMETRY_2DADEPTH, otherwise must be 0."]
    pub height: usize,
    #[doc = " Depth of the image, in components. Only used if the geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_3D, otherwise must be 0."]
    pub depth: usize,
    #[doc = " Number of image layers in the image array. Only used if the geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_1DA, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n HSA_EXT_IMAGE_GEOMETRY_2DADEPTH, otherwise must be 0."]
    pub array_size: usize,
    #[doc = " Image format."]
    pub format: hsa_ext_image_format_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_image_descriptor_s"]
        [::std::mem::size_of::<hsa_ext_image_descriptor_s>() - 48usize];
    ["Alignment of hsa_ext_image_descriptor_s"]
        [::std::mem::align_of::<hsa_ext_image_descriptor_s>() - 8usize];
    ["Offset of field: hsa_ext_image_descriptor_s::geometry"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, geometry) - 0usize];
    ["Offset of field: hsa_ext_image_descriptor_s::width"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, width) - 8usize];
    ["Offset of field: hsa_ext_image_descriptor_s::height"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, height) - 16usize];
    ["Offset of field: hsa_ext_image_descriptor_s::depth"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, depth) - 24usize];
    ["Offset of field: hsa_ext_image_descriptor_s::array_size"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, array_size) - 32usize];
    ["Offset of field: hsa_ext_image_descriptor_s::format"]
        [::std::mem::offset_of!(hsa_ext_image_descriptor_s, format) - 40usize];
};
#[doc = " @brief Implementation independent image descriptor."]
pub type hsa_ext_image_descriptor_t = hsa_ext_image_descriptor_s;
#[doc = " Images of this geometry, format, and layout are not supported by\n the agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_NOT_SUPPORTED:
    hsa_ext_image_capability_t = 0;
#[doc = " Read-only images of this geometry, format, and layout are\n supported by the agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_READ_ONLY:
    hsa_ext_image_capability_t = 1;
#[doc = " Write-only images of this geometry, format, and layout are\n supported by the agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_WRITE_ONLY:
    hsa_ext_image_capability_t = 2;
#[doc = " Read-write images of this geometry, format, and layout are\n supported by the agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_READ_WRITE:
    hsa_ext_image_capability_t = 4;
#[doc = " @deprecated Images of this geometry, format, and layout can be accessed from\n read-modify-write atomic operations in the agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_READ_MODIFY_WRITE:
    hsa_ext_image_capability_t = 8;
#[doc = " Images of this geometry, format, and layout are guaranteed to\n have a consistent data layout regardless of how they are\n accessed by the associated agent."]
pub const hsa_ext_image_capability_t_HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT:
    hsa_ext_image_capability_t = 16;
#[doc = " @brief Image capability."]
pub type hsa_ext_image_capability_t = ::std::os::raw::c_uint;
#[doc = " An implementation specific opaque image data layout which can\n vary depending on the agent, geometry, image format, image size,\n and access permissions."]
pub const hsa_ext_image_data_layout_t_HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE:
    hsa_ext_image_data_layout_t = 0;
#[doc = " The image data layout is specified by the following rules in\n ascending byte address order. For a 3D image, 2DA image array,\n or 1DA image array, the image data is stored as a linear sequence\n of adjacent 2D image slices, 2D images, or 1D images\n respectively, spaced according to the slice pitch. Each 2D image\n is stored as a linear sequence of adjacent image rows, spaced\n according to the row pitch. Each 1D or 1DB image is stored as a\n single image row. Each image row is stored as a linear sequence\n of image elements. Each image element is stored as a linear\n sequence of image components specified by the left to right\n channel order definition. Each image component is stored using\n the memory type specified by the channel type.\n\n The 1DB image geometry always uses the linear image data layout."]
pub const hsa_ext_image_data_layout_t_HSA_EXT_IMAGE_DATA_LAYOUT_LINEAR:
    hsa_ext_image_data_layout_t = 1;
#[doc = " @brief Image data layout.\n\n @details An image data layout denotes such aspects of image data\n layout as tiling and organization of channels in memory. Some image\n data layouts may only apply to specific image geometries, formats,\n and access permissions. Different agents may support different\n image layout identifiers, including vendor specific layouts. Note\n that an agent may not support the same image data layout for\n different access permissions to images with the same image\n geometry, size, and format. If multiple agents support the same\n image data layout then it is possible to use separate image handles\n for each agent that references the same image data."]
pub type hsa_ext_image_data_layout_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Retrieve the supported image capabilities for a given combination of\n agent, geometry, and image format for an image created with an opaque image\n data layout.\n\n @param[in] agent Agent to be associated with the image handle.\n\n @param[in] geometry Geometry.\n\n @param[in] image_format Pointer to an image format. Must not be NULL.\n\n @param[out] capability_mask Pointer to a memory location where the HSA\n runtime stores a bit-mask of supported image capability\n (::hsa_ext_image_capability_t) values. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_format is\n NULL, or @p capability_mask is NULL."]
    pub fn hsa_ext_image_get_capability(
        agent: hsa_agent_t,
        geometry: hsa_ext_image_geometry_t,
        image_format: *const hsa_ext_image_format_t,
        capability_mask: *mut u32,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the supported image capabilities for a given combination of\n agent, geometry, image format, and image layout for an image created with\n an explicit image data layout.\n\n @param[in] agent Agent to be associated with the image handle.\n\n @param[in] geometry Geometry.\n\n @param[in] image_format Pointer to an image format. Must not be NULL.\n\n @param[in] image_data_layout The image data layout.\n It is invalid to use ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use\n ::hsa_ext_image_get_capability instead.\n\n @param[out] capability_mask Pointer to a memory location where the HSA\n runtime stores a bit-mask of supported image capability\n (::hsa_ext_image_capability_t) values. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_format is\n NULL, @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n or @p capability_mask is NULL."]
    pub fn hsa_ext_image_get_capability_with_layout(
        agent: hsa_agent_t,
        geometry: hsa_ext_image_geometry_t,
        image_format: *const hsa_ext_image_format_t,
        image_data_layout: hsa_ext_image_data_layout_t,
        capability_mask: *mut u32,
    ) -> hsa_status_t;
}
#[doc = " @brief Agent specific image size and alignment requirements, populated by\n ::hsa_ext_image_data_get_info and ::hsa_ext_image_data_get_info_with_layout."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_image_data_info_s {
    #[doc = " Image data size, in bytes."]
    pub size: usize,
    #[doc = " Image data alignment, in bytes. Must always be a power of 2."]
    pub alignment: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_image_data_info_s"]
        [::std::mem::size_of::<hsa_ext_image_data_info_s>() - 16usize];
    ["Alignment of hsa_ext_image_data_info_s"]
        [::std::mem::align_of::<hsa_ext_image_data_info_s>() - 8usize];
    ["Offset of field: hsa_ext_image_data_info_s::size"]
        [::std::mem::offset_of!(hsa_ext_image_data_info_s, size) - 0usize];
    ["Offset of field: hsa_ext_image_data_info_s::alignment"]
        [::std::mem::offset_of!(hsa_ext_image_data_info_s, alignment) - 8usize];
};
#[doc = " @brief Agent specific image size and alignment requirements, populated by\n ::hsa_ext_image_data_get_info and ::hsa_ext_image_data_get_info_with_layout."]
pub type hsa_ext_image_data_info_t = hsa_ext_image_data_info_s;
unsafe extern "C" {
    #[doc = " @brief Retrieve the image data requirements for a given combination of agent, image\n descriptor, and access permission for an image created with an opaque image\n data layout.\n\n @details The optimal image data size and alignment requirements may\n vary depending on the image attributes specified in @p\n image_descriptor, the @p access_permission, and the @p agent. Also,\n different implementations of the HSA runtime may return different\n requirements for the same input values.\n\n The implementation must return the same image data requirements for\n different access permissions with matching image descriptors as long\n as ::hsa_ext_image_get_capability reports\n ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT. Image\n descriptors match if they have the same values, with the exception\n that s-form channel orders match the corresponding non-s-form\n channel order and vice versa.\n\n @param[in] agent Agent to be associated with the image handle.\n\n @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n\n @param[in] access_permission Access permission of the image when\n accessed by @p agent. The access permission defines how the agent\n is allowed to access the image and must match the corresponding\n HSAIL image handle type. The @p agent must support the image format\n specified in @p image_descriptor for the given @p\n access_permission.\n\n @param[out] image_data_info Memory location where the runtime stores the\n size and alignment requirements. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The @p\n agent does not support the image format specified by @p\n image_descriptor with the specified @p access_permission.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n does not support the image dimensions specified by @p\n image_descriptor with the specified @p access_permission.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n access_permission is not a valid access permission value, or @p\n image_data_info is NULL."]
    pub fn hsa_ext_image_data_get_info(
        agent: hsa_agent_t,
        image_descriptor: *const hsa_ext_image_descriptor_t,
        access_permission: hsa_access_permission_t,
        image_data_info: *mut hsa_ext_image_data_info_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the image data requirements for a given combination of\n image descriptor, access permission, image data layout, image data row pitch,\n and image data slice pitch for an image created with an explicit image\n data layout.\n\n @details The image data size and alignment requirements may vary\n depending on the image attributes specified in @p image_descriptor,\n the @p access_permission, and the image layout. However, different\n implementations of the HSA runtime will return the same\n requirements for the same input values.\n\n The implementation must return the same image data requirements for\n different access permissions with matching image descriptors and\n matching image layouts as long as ::hsa_ext_image_get_capability\n reports\n ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT. Image\n descriptors match if they have the same values, with the exception\n that s-form channel orders match the corresponding non-s-form\n channel order and vice versa. Image layouts match if they are the\n same image data layout and use the same image row and slice pitch\n values.\n\n @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n\n @param[in] access_permission Access permission of the image when\n accessed by an agent. The access permission defines how the agent\n is allowed to access the image and must match the corresponding\n HSAIL image handle type.\n\n @param[in] image_data_layout The image data layout to use.\n It is invalid to use ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use\n ::hsa_ext_image_data_get_info instead.\n\n @param[in] image_data_row_pitch The size in bytes for a single row\n of the image in the image data. If 0 is specified then the default\n row pitch value is used: image width * image element byte size.\n The value used must be greater than or equal to the default row\n pitch, and be a multiple of the image element byte size. For the\n linear image layout it must also be a multiple of the image linear\n row pitch alignment for the agents that will access the image data\n using image instructions.\n\n @param[in] image_data_slice_pitch The size in bytes of a single\n slice of a 3D image, or the size in bytes of each image layer in an\n image array in the image data. If 0 is specified then the default\n slice pitch value is used: row pitch * height if geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n ::HSA_EXT_IMAGE_GEOMETRY_2DADEPTH; row pitch if geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_1DA; and 0 otherwise. The value used must\n be 0 if the default slice pitch is 0, be greater than or equal to\n the default slice pitch, and be a multiple of the row pitch.\n\n @param[out] image_data_info Memory location where the runtime stores the\n size and alignment requirements. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The image\n format specified by @p image_descriptor is not supported for the\n @p access_permission and @p image_data_layout specified.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The image\n dimensions specified by @p image_descriptor are not supported for\n the @p access_permission and @p image_data_layout specified.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED The row and\n slice pitch specified by @p image_data_row_pitch and @p\n image_data_slice_pitch are invalid or not supported.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is\n NULL, @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n or @p image_data_info is NULL."]
    pub fn hsa_ext_image_data_get_info_with_layout(
        agent: hsa_agent_t,
        image_descriptor: *const hsa_ext_image_descriptor_t,
        access_permission: hsa_access_permission_t,
        image_data_layout: hsa_ext_image_data_layout_t,
        image_data_row_pitch: usize,
        image_data_slice_pitch: usize,
        image_data_info: *mut hsa_ext_image_data_info_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an agent specific image handle to an image with an\n opaque image data layout.\n\n @details Images with an opaque image data layout created with\n different access permissions but matching image descriptors and\n same agent can share the same image data if\n ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT is reported\n by ::hsa_ext_image_get_capability for the image format specified in\n the image descriptor. Image descriptors match if they have the same\n values, with the exception that s-form channel orders match the\n corresponding non-s-form channel order and vice versa.\n\n If necessary, an application can use image operations (import,\n export, copy, clear) to prepare the image for the intended use\n regardless of the access permissions.\n\n @param[in] agent agent to be associated with the image handle created.\n\n @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n\n @param[in] image_data Image data buffer that must have been allocated\n according to the size and alignment requirements dictated by\n ::hsa_ext_image_data_get_info. Must not be NULL.\n\n Any previous memory contents are preserved upon creation. The application is\n responsible for ensuring that the lifetime of the image data exceeds that of\n all the associated images.\n\n @param[in] access_permission Access permission of the image when\n accessed by agent. The access permission defines how the agent\n is allowed to access the image using the image handle created and\n must match the corresponding HSAIL image handle type. The agent\n must support the image format specified in @p image_descriptor for\n the given @p access_permission.\n\n @param[out] image Pointer to a memory location where the HSA runtime stores\n the newly created image handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The agent\n does not have the capability to support the image format contained\n in @p image_descriptor using the specified @p access_permission.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n does not support the image dimensions specified by @p\n image_descriptor using the specified @p access_permission.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n support the creation of more image handles with the given @p access_permission).\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n image_data is NULL, @p image_data does not have a valid alignment,\n @p access_permission is not a valid access permission\n value, or @p image is NULL."]
    pub fn hsa_ext_image_create(
        agent: hsa_agent_t,
        image_descriptor: *const hsa_ext_image_descriptor_t,
        image_data: *const ::std::os::raw::c_void,
        access_permission: hsa_access_permission_t,
        image: *mut hsa_ext_image_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Creates an agent specific image handle to an image with an explicit\n image data layout.\n\n @details Images with an explicit image data layout created with\n different access permissions but matching image descriptors and\n matching image layout can share the same image data if\n ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT is reported\n by ::hsa_ext_image_get_capability_with_layout for the image format\n specified in the image descriptor and specified image data\n layout. Image descriptors match if they have the same values, with\n the exception that s-form channel orders match the corresponding\n non-s-form channel order and vice versa. Image layouts match if\n they are the same image data layout and use the same image row and\n slice values.\n\n If necessary, an application can use image operations (import, export, copy,\n clear) to prepare the image for the intended use regardless of the access\n permissions.\n\n @param[in] agent agent to be associated with the image handle created.\n\n @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n\n @param[in] image_data Image data buffer that must have been allocated\n according to the size and alignment requirements dictated by\n ::hsa_ext_image_data_get_info_with_layout. Must not be NULL.\n\n Any previous memory contents are preserved upon creation. The application is\n responsible for ensuring that the lifetime of the image data exceeds that of\n all the associated images.\n\n @param[in] access_permission Access permission of the image when\n accessed by the agent. The access permission defines how the agent\n is allowed to access the image and must match the corresponding\n HSAIL image handle type. The agent must support the image format\n specified in @p image_descriptor for the given @p access_permission\n and @p image_data_layout.\n\n @param[in] image_data_layout The image data layout to use for the\n @p image_data. It is invalid to use\n ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use ::hsa_ext_image_create\n instead.\n\n @param[in] image_data_row_pitch The size in bytes for a single row\n of the image in the image data. If 0 is specified then the default\n row pitch value is used: image width * image element byte size.\n The value used must be greater than or equal to the default row\n pitch, and be a multiple of the image element byte size. For the\n linear image layout it must also be a multiple of the image linear\n row pitch alignment for the agents that will access the image data\n using image instructions.\n\n @param[in] image_data_slice_pitch The size in bytes of a single\n slice of a 3D image, or the size in bytes of each image layer in an\n image array in the image data. If 0 is specified then the default\n slice pitch value is used: row pitch * height if geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n ::HSA_EXT_IMAGE_GEOMETRY_2DADEPTH; row pitch if geometry is\n ::HSA_EXT_IMAGE_GEOMETRY_1DA; and 0 otherwise. The value used must\n be 0 if the default slice pitch is 0, be greater than or equal to\n the default slice pitch, and be a multiple of the row pitch.\n\n @param[out] image Pointer to a memory location where the HSA runtime stores\n the newly created image handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The agent does\n not have the capability to support the image format contained in the image\n descriptor using the specified @p access_permission and @p image_data_layout.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n does not support the image dimensions specified by @p\n image_descriptor using the specified @p access_permission and @p\n image_data_layout.\n\n @retval ::HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED The agent does\n not support the row and slice pitch specified by @p image_data_row_pitch\n and @p image_data_slice_pitch, or the values are invalid.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n support the creation of more image handles with the given @p access_permission).\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n image_data is NULL, @p image_data does not have a valid alignment,\n @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n or @p image is NULL."]
    pub fn hsa_ext_image_create_with_layout(
        agent: hsa_agent_t,
        image_descriptor: *const hsa_ext_image_descriptor_t,
        image_data: *const ::std::os::raw::c_void,
        access_permission: hsa_access_permission_t,
        image_data_layout: hsa_ext_image_data_layout_t,
        image_data_row_pitch: usize,
        image_data_slice_pitch: usize,
        image: *mut hsa_ext_image_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy an image handle previously created using ::hsa_ext_image_create or\n ::hsa_ext_image_create_with_layout.\n\n @details Destroying the image handle does not free the associated image data,\n or modify its contents. The application should not destroy an image handle while\n there are references to it queued for execution or currently being used in a\n kernel dispatch.\n\n @param[in] agent Agent associated with the image handle.\n\n @param[in] image Image handle to destroy.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid."]
    pub fn hsa_ext_image_destroy(agent: hsa_agent_t, image: hsa_ext_image_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Copies a portion of one image (the source) to another image (the\n destination).\n\n @details The source and destination image formats should be the\n same, with the exception that s-form channel orders match the\n corresponding non-s-form channel order and vice versa. For example,\n it is allowed to copy a source image with a channel order of\n HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB to a destination image with a\n channel order of HSA_EXT_IMAGE_CHANNEL_ORDER_RGB.\n\n The source and destination images do not have to be of the same geometry and\n appropriate scaling is performed by the HSA runtime. It is possible to copy\n subregions between any combinations of source and destination geometries, provided\n that the dimensions of the subregions are the same. For example, it is\n allowed to copy a rectangular region from a 2D image to a slice of a 3D\n image.\n\n If the source and destination image data overlap, or the combination of\n offset and range references an out-out-bounds element in any of the images,\n the behavior is undefined.\n\n @param[in] agent Agent associated with both the source and destination image handles.\n\n @param[in] src_image Image handle of source image. The agent associated with the source\n image handle must be identical to that of the destination image.\n\n @param[in] src_offset Pointer to the offset within the source image where to\n copy the data from. Must not be NULL.\n\n @param[in] dst_image Image handle of destination image.\n\n @param[in] dst_offset Pointer to the offset within the destination\n image where to copy the data. Must not be NULL.\n\n @param[in] range Dimensions of the image portion to be copied. The HSA\n runtime computes the size of the image data to be copied using this\n argument. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p src_offset is\n NULL, @p dst_offset is NULL, or @p range is NULL."]
    pub fn hsa_ext_image_copy(
        agent: hsa_agent_t,
        src_image: hsa_ext_image_t,
        src_offset: *const hsa_dim3_t,
        dst_image: hsa_ext_image_t,
        dst_offset: *const hsa_dim3_t,
        range: *const hsa_dim3_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Image region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_image_region_s {
    #[doc = " Offset within an image (in coordinates)."]
    pub offset: hsa_dim3_t,
    #[doc = " Dimension size of the image range (in coordinates). The x, y, and z dimensions\n correspond to width, height, and depth or index respectively."]
    pub range: hsa_dim3_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_image_region_s"][::std::mem::size_of::<hsa_ext_image_region_s>() - 24usize];
    ["Alignment of hsa_ext_image_region_s"]
        [::std::mem::align_of::<hsa_ext_image_region_s>() - 4usize];
    ["Offset of field: hsa_ext_image_region_s::offset"]
        [::std::mem::offset_of!(hsa_ext_image_region_s, offset) - 0usize];
    ["Offset of field: hsa_ext_image_region_s::range"]
        [::std::mem::offset_of!(hsa_ext_image_region_s, range) - 12usize];
};
#[doc = " @brief Image region."]
pub type hsa_ext_image_region_t = hsa_ext_image_region_s;
unsafe extern "C" {
    #[doc = " @brief Import a linearly organized image data from memory directly to an\n image handle.\n\n @details This operation updates the image data referenced by the image handle\n from the source memory. The size of the data imported from memory is\n implicitly derived from the image region.\n\n It is the application's responsibility to avoid out of bounds memory access.\n\n None of the source memory or destination image data memory can\n overlap. Overlapping of any of the source and destination image\n data memory within the import operation produces undefined results.\n\n @param[in] agent Agent associated with the image handle.\n\n @param[in] src_memory Source memory. Must not be NULL.\n\n @param[in] src_row_pitch The size in bytes of a single row of the image in the\n source memory. If the value is smaller than the destination image region\n width * image element byte size, then region width * image element byte\n size is used.\n\n @param[in] src_slice_pitch The size in bytes of a single 2D slice of a 3D image,\n or the size in bytes of each image layer in an image array in the source memory.\n If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_1DA and the value is smaller than the\n value used for @p src_row_pitch, then the value used for @p src_row_pitch is used.\n If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n HSA_EXT_IMAGE_GEOMETRY_2DADEPTH and the value is smaller than the value used for\n @p src_row_pitch * destination image region height, then the value used for\n @p src_row_pitch * destination image region height is used.\n Otherwise, the value is not used.\n\n @param[in] dst_image Image handle of destination image.\n\n @param[in] image_region Pointer to the image region to be updated. Must not\n be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p src_memory is NULL, or @p\n image_region is NULL.\n"]
    pub fn hsa_ext_image_import(
        agent: hsa_agent_t,
        src_memory: *const ::std::os::raw::c_void,
        src_row_pitch: usize,
        src_slice_pitch: usize,
        dst_image: hsa_ext_image_t,
        image_region: *const hsa_ext_image_region_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Export the image data to linearly organized memory.\n\n @details The operation updates the destination memory with the image data of\n @p src_image. The size of the data exported to memory is implicitly derived\n from the image region.\n\n It is the application's responsibility to avoid out of bounds memory access.\n\n None of the destination memory or source image data memory can\n overlap. Overlapping of any of the source and destination image\n data memory within the export operation produces undefined results.\n\n @param[in] agent Agent associated with the image handle.\n\n @param[in] src_image Image handle of source image.\n\n @param[in] dst_memory Destination memory. Must not be NULL.\n\n @param[in] dst_row_pitch The size in bytes of a single row of the image in the\n destination memory. If the value is smaller than the source image region\n width * image element byte size, then region width * image element byte\n size is used.\n\n @param[in] dst_slice_pitch The size in bytes of a single 2D slice of a 3D image,\n or the size in bytes of each image in an image array in the destination memory.\n If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_1DA and the value is smaller than the\n value used for @p dst_row_pitch, then the value used for @p dst_row_pitch is used.\n If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n HSA_EXT_IMAGE_GEOMETRY_2DADEPTH and the value is smaller than the value used for\n @p dst_row_pitch * source image region height, then the value used for\n @p dst_row_pitch * source image region height is used.\n Otherwise, the value is not used.\n\n @param[in] image_region Pointer to the image region to be exported. Must not\n be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p dst_memory is NULL, or @p\n image_region is NULL."]
    pub fn hsa_ext_image_export(
        agent: hsa_agent_t,
        src_image: hsa_ext_image_t,
        dst_memory: *mut ::std::os::raw::c_void,
        dst_row_pitch: usize,
        dst_slice_pitch: usize,
        image_region: *const hsa_ext_image_region_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear a region of an image so that every image element has\n the specified value.\n\n @param[in] agent Agent associated with the image handle.\n\n @param[in] image Image handle for image to be cleared.\n\n @param[in] data The value to which to set each image element being\n cleared. It is specified as an array of image component values. The\n number of array elements must match the number of access components\n for the image channel order. The type of each array element must\n match the image access type of the image channel type. When the\n value is used to set the value of an image element, the conversion\n method corresponding to the image channel type is used. See the\n <em>Channel Order</em> section and <em>Channel Type</em> section in\n the <em>HSA Programming Reference Manual</em> for more\n information. Must not be NULL.\n\n @param[in] image_region Pointer to the image region to clear. Must not be\n NULL. If the region references an out-out-bounds element, the behavior is\n undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p data is NULL, or @p\n image_region is NULL."]
    pub fn hsa_ext_image_clear(
        agent: hsa_agent_t,
        image: hsa_ext_image_t,
        data: *const ::std::os::raw::c_void,
        image_region: *const hsa_ext_image_region_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Sampler handle. Samplers are populated by\n ::hsa_ext_sampler_create. Sampler handles are only unique within an\n agent, not across agents."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_sampler_s {
    #[doc = "  Opaque handle. For a given agent, two handles reference the same object of\n  the enclosing type if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_sampler_s"][::std::mem::size_of::<hsa_ext_sampler_s>() - 8usize];
    ["Alignment of hsa_ext_sampler_s"][::std::mem::align_of::<hsa_ext_sampler_s>() - 8usize];
    ["Offset of field: hsa_ext_sampler_s::handle"]
        [::std::mem::offset_of!(hsa_ext_sampler_s, handle) - 0usize];
};
#[doc = " @brief Sampler handle. Samplers are populated by\n ::hsa_ext_sampler_create. Sampler handles are only unique within an\n agent, not across agents."]
pub type hsa_ext_sampler_t = hsa_ext_sampler_s;
#[doc = " Out-of-range coordinates are not handled."]
pub const hsa_ext_sampler_addressing_mode_t_HSA_EXT_SAMPLER_ADDRESSING_MODE_UNDEFINED:
    hsa_ext_sampler_addressing_mode_t = 0;
#[doc = " Clamp out-of-range coordinates to the image edge."]
pub const hsa_ext_sampler_addressing_mode_t_HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_EDGE:
    hsa_ext_sampler_addressing_mode_t = 1;
#[doc = " Clamp out-of-range coordinates to the image border color."]
pub const hsa_ext_sampler_addressing_mode_t_HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_BORDER:
    hsa_ext_sampler_addressing_mode_t = 2;
#[doc = " Wrap out-of-range coordinates back into the valid coordinate\n range so the image appears as repeated tiles."]
pub const hsa_ext_sampler_addressing_mode_t_HSA_EXT_SAMPLER_ADDRESSING_MODE_REPEAT:
    hsa_ext_sampler_addressing_mode_t = 3;
#[doc = " Mirror out-of-range coordinates back into the valid coordinate\n range so the image appears as repeated tiles with every other\n tile a reflection."]
pub const hsa_ext_sampler_addressing_mode_t_HSA_EXT_SAMPLER_ADDRESSING_MODE_MIRRORED_REPEAT:
    hsa_ext_sampler_addressing_mode_t = 4;
#[doc = " @brief Sampler address modes. The sampler address mode describes\n the processing of out-of-range image coordinates. See the\n <em>Addressing Mode</em> section in the <em>HSA Programming Reference\n Manual</em> for definitions on each address mode. The values\n match the BRIG type @p hsa_ext_brig_sampler_addressing_t."]
pub type hsa_ext_sampler_addressing_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_ext_sampler_addressing_mode_t constants."]
pub type hsa_ext_sampler_addressing_mode32_t = u32;
#[doc = " Coordinates are used to directly address an image element."]
pub const hsa_ext_sampler_coordinate_mode_t_HSA_EXT_SAMPLER_COORDINATE_MODE_UNNORMALIZED:
    hsa_ext_sampler_coordinate_mode_t = 0;
#[doc = " Coordinates are scaled by the image dimension size before being\n used to address an image element."]
pub const hsa_ext_sampler_coordinate_mode_t_HSA_EXT_SAMPLER_COORDINATE_MODE_NORMALIZED:
    hsa_ext_sampler_coordinate_mode_t = 1;
#[doc = " @brief Sampler coordinate normalization modes. See the\n <em>Coordinate Normalization Mode</em> section in the <em>HSA\n Programming Reference Manual</em> for definitions on each\n coordinate normalization mode. The values match the BRIG type @p\n hsa_ext_brig_sampler_coord_normalization_t."]
pub type hsa_ext_sampler_coordinate_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_ext_sampler_coordinate_mode_t constants."]
pub type hsa_ext_sampler_coordinate_mode32_t = u32;
#[doc = " Filter to the image element nearest (in Manhattan distance) to the\n specified coordinate."]
pub const hsa_ext_sampler_filter_mode_t_HSA_EXT_SAMPLER_FILTER_MODE_NEAREST:
    hsa_ext_sampler_filter_mode_t = 0;
#[doc = " Filter to the image element calculated by combining the elements in a 2x2\n square block or 2x2x2 cube block around the specified coordinate. The\n elements are combined using linear interpolation."]
pub const hsa_ext_sampler_filter_mode_t_HSA_EXT_SAMPLER_FILTER_MODE_LINEAR:
    hsa_ext_sampler_filter_mode_t = 1;
#[doc = " @brief Sampler filter modes. See the <em>Filter Mode</em> section\n in the <em>HSA Programming Reference Manual</em> for definitions\n on each address mode. The enumeration values match the BRIG type @p\n hsa_ext_brig_sampler_filter_t."]
pub type hsa_ext_sampler_filter_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_ext_sampler_filter_mode_t constants."]
pub type hsa_ext_sampler_filter_mode32_t = u32;
#[doc = " @brief Implementation independent sampler descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_sampler_descriptor_s {
    #[doc = " Sampler coordinate mode describes the normalization of image coordinates."]
    pub coordinate_mode: hsa_ext_sampler_coordinate_mode32_t,
    #[doc = " Sampler filter type describes the type of sampling performed."]
    pub filter_mode: hsa_ext_sampler_filter_mode32_t,
    #[doc = " Sampler address mode describes the processing of out-of-range image\n coordinates."]
    pub address_mode: hsa_ext_sampler_addressing_mode32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_sampler_descriptor_s"]
        [::std::mem::size_of::<hsa_ext_sampler_descriptor_s>() - 12usize];
    ["Alignment of hsa_ext_sampler_descriptor_s"]
        [::std::mem::align_of::<hsa_ext_sampler_descriptor_s>() - 4usize];
    ["Offset of field: hsa_ext_sampler_descriptor_s::coordinate_mode"]
        [::std::mem::offset_of!(hsa_ext_sampler_descriptor_s, coordinate_mode) - 0usize];
    ["Offset of field: hsa_ext_sampler_descriptor_s::filter_mode"]
        [::std::mem::offset_of!(hsa_ext_sampler_descriptor_s, filter_mode) - 4usize];
    ["Offset of field: hsa_ext_sampler_descriptor_s::address_mode"]
        [::std::mem::offset_of!(hsa_ext_sampler_descriptor_s, address_mode) - 8usize];
};
#[doc = " @brief Implementation independent sampler descriptor."]
pub type hsa_ext_sampler_descriptor_t = hsa_ext_sampler_descriptor_s;
unsafe extern "C" {
    #[doc = " @brief Create an agent specific sampler handle for a given agent\n independent sampler descriptor and agent.\n\n @param[in] agent Agent to be associated with the sampler handle created.\n\n @param[in] sampler_descriptor Pointer to a sampler descriptor. Must not be\n NULL.\n\n @param[out] sampler Memory location where the HSA runtime stores the newly\n created sampler handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_EXT_STATUS_ERROR_SAMPLER_DESCRIPTOR_UNSUPPORTED The\n @p agent does not have the capability to support the properties\n specified by @p sampler_descriptor or it is invalid.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p sampler_descriptor is NULL, or\n @p sampler is NULL."]
    pub fn hsa_ext_sampler_create(
        agent: hsa_agent_t,
        sampler_descriptor: *const hsa_ext_sampler_descriptor_t,
        sampler: *mut hsa_ext_sampler_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroy a sampler handle previously created using ::hsa_ext_sampler_create.\n\n @details The sampler handle should not be destroyed while there are\n references to it queued for execution or currently being used in a\n kernel dispatch.\n\n @param[in] agent Agent associated with the sampler handle.\n\n @param[in] sampler Sampler handle to destroy.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid."]
    pub fn hsa_ext_sampler_destroy(agent: hsa_agent_t, sampler: hsa_ext_sampler_t) -> hsa_status_t;
}
#[doc = " @brief The function pointer table for the images v1.00 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_images_1_00_pfn_s {
    pub hsa_ext_image_get_capability: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            geometry: hsa_ext_image_geometry_t,
            image_format: *const hsa_ext_image_format_t,
            capability_mask: *mut u32,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_data_get_info: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            access_permission: hsa_access_permission_t,
            image_data_info: *mut hsa_ext_image_data_info_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_create: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            image_data: *const ::std::os::raw::c_void,
            access_permission: hsa_access_permission_t,
            image: *mut hsa_ext_image_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_destroy: ::std::option::Option<
        unsafe extern "C" fn(agent: hsa_agent_t, image: hsa_ext_image_t) -> hsa_status_t,
    >,
    pub hsa_ext_image_copy: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_image: hsa_ext_image_t,
            src_offset: *const hsa_dim3_t,
            dst_image: hsa_ext_image_t,
            dst_offset: *const hsa_dim3_t,
            range: *const hsa_dim3_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_import: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_memory: *const ::std::os::raw::c_void,
            src_row_pitch: usize,
            src_slice_pitch: usize,
            dst_image: hsa_ext_image_t,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_export: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_image: hsa_ext_image_t,
            dst_memory: *mut ::std::os::raw::c_void,
            dst_row_pitch: usize,
            dst_slice_pitch: usize,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_clear: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image: hsa_ext_image_t,
            data: *const ::std::os::raw::c_void,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_sampler_create: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            sampler_descriptor: *const hsa_ext_sampler_descriptor_t,
            sampler: *mut hsa_ext_sampler_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_sampler_destroy: ::std::option::Option<
        unsafe extern "C" fn(agent: hsa_agent_t, sampler: hsa_ext_sampler_t) -> hsa_status_t,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_images_1_00_pfn_s"]
        [::std::mem::size_of::<hsa_ext_images_1_00_pfn_s>() - 80usize];
    ["Alignment of hsa_ext_images_1_00_pfn_s"]
        [::std::mem::align_of::<hsa_ext_images_1_00_pfn_s>() - 8usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_get_capability"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_get_capability) - 0usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_data_get_info"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_data_get_info) - 8usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_create"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_create) - 16usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_destroy"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_destroy) - 24usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_copy"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_copy) - 32usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_import"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_import) - 40usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_export"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_export) - 48usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_image_clear"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_image_clear) - 56usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_sampler_create"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_sampler_create) - 64usize];
    ["Offset of field: hsa_ext_images_1_00_pfn_s::hsa_ext_sampler_destroy"]
        [::std::mem::offset_of!(hsa_ext_images_1_00_pfn_s, hsa_ext_sampler_destroy) - 72usize];
};
#[doc = " @brief The function pointer table for the images v1.00 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table."]
pub type hsa_ext_images_1_00_pfn_t = hsa_ext_images_1_00_pfn_s;
#[doc = " @brief The function pointer table for the images v1 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ext_images_1_pfn_s {
    pub hsa_ext_image_get_capability: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            geometry: hsa_ext_image_geometry_t,
            image_format: *const hsa_ext_image_format_t,
            capability_mask: *mut u32,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_data_get_info: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            access_permission: hsa_access_permission_t,
            image_data_info: *mut hsa_ext_image_data_info_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_create: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            image_data: *const ::std::os::raw::c_void,
            access_permission: hsa_access_permission_t,
            image: *mut hsa_ext_image_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_destroy: ::std::option::Option<
        unsafe extern "C" fn(agent: hsa_agent_t, image: hsa_ext_image_t) -> hsa_status_t,
    >,
    pub hsa_ext_image_copy: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_image: hsa_ext_image_t,
            src_offset: *const hsa_dim3_t,
            dst_image: hsa_ext_image_t,
            dst_offset: *const hsa_dim3_t,
            range: *const hsa_dim3_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_import: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_memory: *const ::std::os::raw::c_void,
            src_row_pitch: usize,
            src_slice_pitch: usize,
            dst_image: hsa_ext_image_t,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_export: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            src_image: hsa_ext_image_t,
            dst_memory: *mut ::std::os::raw::c_void,
            dst_row_pitch: usize,
            dst_slice_pitch: usize,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_clear: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image: hsa_ext_image_t,
            data: *const ::std::os::raw::c_void,
            image_region: *const hsa_ext_image_region_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_sampler_create: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            sampler_descriptor: *const hsa_ext_sampler_descriptor_t,
            sampler: *mut hsa_ext_sampler_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_sampler_destroy: ::std::option::Option<
        unsafe extern "C" fn(agent: hsa_agent_t, sampler: hsa_ext_sampler_t) -> hsa_status_t,
    >,
    pub hsa_ext_image_get_capability_with_layout: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            geometry: hsa_ext_image_geometry_t,
            image_format: *const hsa_ext_image_format_t,
            image_data_layout: hsa_ext_image_data_layout_t,
            capability_mask: *mut u32,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_data_get_info_with_layout: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            access_permission: hsa_access_permission_t,
            image_data_layout: hsa_ext_image_data_layout_t,
            image_data_row_pitch: usize,
            image_data_slice_pitch: usize,
            image_data_info: *mut hsa_ext_image_data_info_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ext_image_create_with_layout: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            image_descriptor: *const hsa_ext_image_descriptor_t,
            image_data: *const ::std::os::raw::c_void,
            access_permission: hsa_access_permission_t,
            image_data_layout: hsa_ext_image_data_layout_t,
            image_data_row_pitch: usize,
            image_data_slice_pitch: usize,
            image: *mut hsa_ext_image_t,
        ) -> hsa_status_t,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ext_images_1_pfn_s"][::std::mem::size_of::<hsa_ext_images_1_pfn_s>() - 104usize];
    ["Alignment of hsa_ext_images_1_pfn_s"]
        [::std::mem::align_of::<hsa_ext_images_1_pfn_s>() - 8usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_get_capability"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_get_capability) - 0usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_data_get_info"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_data_get_info) - 8usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_create"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_create) - 16usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_destroy"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_destroy) - 24usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_copy"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_copy) - 32usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_import"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_import) - 40usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_export"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_export) - 48usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_clear"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_image_clear) - 56usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_sampler_create"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_sampler_create) - 64usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_sampler_destroy"]
        [::std::mem::offset_of!(hsa_ext_images_1_pfn_s, hsa_ext_sampler_destroy) - 72usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_get_capability_with_layout"][::std::mem::offset_of!(
        hsa_ext_images_1_pfn_s,
        hsa_ext_image_get_capability_with_layout
    )
        - 80usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_data_get_info_with_layout"][::std::mem::offset_of!(
        hsa_ext_images_1_pfn_s,
        hsa_ext_image_data_get_info_with_layout
    )
        - 88usize];
    ["Offset of field: hsa_ext_images_1_pfn_s::hsa_ext_image_create_with_layout"][::std::mem::offset_of!(
        hsa_ext_images_1_pfn_s,
        hsa_ext_image_create_with_layout
    ) - 96usize];
};
#[doc = " @brief The function pointer table for the images v1 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table."]
pub type hsa_ext_images_1_pfn_t = hsa_ext_images_1_pfn_s;
#[doc = " @brief PC Sampling sample data for hosttrap sampling method"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_hosttrap_v1_t {
    pub pc: u64,
    pub exec_mask: u64,
    pub workgroup_id_x: u32,
    pub workgroup_id_y: u32,
    pub workgroup_id_z: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub hw_id: u32,
    pub reserved0: u32,
    pub reserved1: u64,
    pub timestamp: u64,
    pub correlation_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of perf_sample_hosttrap_v1_t"]
        [::std::mem::size_of::<perf_sample_hosttrap_v1_t>() - 64usize];
    ["Alignment of perf_sample_hosttrap_v1_t"]
        [::std::mem::align_of::<perf_sample_hosttrap_v1_t>() - 8usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::pc"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, pc) - 0usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::exec_mask"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, exec_mask) - 8usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::workgroup_id_x"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, workgroup_id_x) - 16usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::workgroup_id_y"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, workgroup_id_y) - 20usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::workgroup_id_z"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, workgroup_id_z) - 24usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::hw_id"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, hw_id) - 32usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::reserved0"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, reserved0) - 36usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::reserved1"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, reserved1) - 40usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::timestamp"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, timestamp) - 48usize];
    ["Offset of field: perf_sample_hosttrap_v1_t::correlation_id"]
        [::std::mem::offset_of!(perf_sample_hosttrap_v1_t, correlation_id) - 56usize];
};
impl perf_sample_hosttrap_v1_t {
    #[inline]
    pub fn wave_in_wg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wave_in_wg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wave_in_wg_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wave_in_wg_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chiplet(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_chiplet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chiplet_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chiplet_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wave_in_wg: u32,
        chiplet: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let wave_in_wg: u32 = unsafe { ::std::mem::transmute(wave_in_wg) };
            wave_in_wg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let chiplet: u32 = unsafe { ::std::mem::transmute(chiplet) };
            chiplet as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief PC Sampling sample data for stochastic sampling method"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_snapshot_v1_t {
    pub pc: u64,
    pub exec_mask: u64,
    pub workgroup_id_x: u32,
    pub workgroup_id_y: u32,
    pub workgroup_id_z: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub hw_id: u32,
    pub perf_snapshot_data: u32,
    pub perf_snapshot_data1: u32,
    pub perf_snapshot_data2: u32,
    pub timestamp: u64,
    pub correlation_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of perf_sample_snapshot_v1_t"]
        [::std::mem::size_of::<perf_sample_snapshot_v1_t>() - 64usize];
    ["Alignment of perf_sample_snapshot_v1_t"]
        [::std::mem::align_of::<perf_sample_snapshot_v1_t>() - 8usize];
    ["Offset of field: perf_sample_snapshot_v1_t::pc"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, pc) - 0usize];
    ["Offset of field: perf_sample_snapshot_v1_t::exec_mask"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, exec_mask) - 8usize];
    ["Offset of field: perf_sample_snapshot_v1_t::workgroup_id_x"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, workgroup_id_x) - 16usize];
    ["Offset of field: perf_sample_snapshot_v1_t::workgroup_id_y"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, workgroup_id_y) - 20usize];
    ["Offset of field: perf_sample_snapshot_v1_t::workgroup_id_z"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, workgroup_id_z) - 24usize];
    ["Offset of field: perf_sample_snapshot_v1_t::hw_id"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, hw_id) - 32usize];
    ["Offset of field: perf_sample_snapshot_v1_t::perf_snapshot_data"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, perf_snapshot_data) - 36usize];
    ["Offset of field: perf_sample_snapshot_v1_t::perf_snapshot_data1"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, perf_snapshot_data1) - 40usize];
    ["Offset of field: perf_sample_snapshot_v1_t::perf_snapshot_data2"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, perf_snapshot_data2) - 44usize];
    ["Offset of field: perf_sample_snapshot_v1_t::timestamp"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, timestamp) - 48usize];
    ["Offset of field: perf_sample_snapshot_v1_t::correlation_id"]
        [::std::mem::offset_of!(perf_sample_snapshot_v1_t, correlation_id) - 56usize];
};
impl perf_sample_snapshot_v1_t {
    #[inline]
    pub fn wave_in_wg(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wave_in_wg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wave_in_wg_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wave_in_wg_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn chiplet(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_chiplet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn chiplet_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_chiplet_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wave_in_wg: u32,
        chiplet: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let wave_in_wg: u32 = unsafe { ::std::mem::transmute(wave_in_wg) };
            wave_in_wg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let chiplet: u32 = unsafe { ::std::mem::transmute(chiplet) };
            chiplet as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const hsa_ven_amd_pcs_method_kind_t_HSA_VEN_AMD_PCS_METHOD_HOSTTRAP_V1:
    hsa_ven_amd_pcs_method_kind_t = 0;
pub const hsa_ven_amd_pcs_method_kind_t_HSA_VEN_AMD_PCS_METHOD_STOCHASTIC_V1:
    hsa_ven_amd_pcs_method_kind_t = 1;
#[doc = " @brief PC Sampling method kinds"]
pub type hsa_ven_amd_pcs_method_kind_t = ::std::os::raw::c_uint;
pub const hsa_ven_amd_pcs_units_t_HSA_VEN_AMD_PCS_INTERVAL_UNITS_MICRO_SECONDS:
    hsa_ven_amd_pcs_units_t = 0;
pub const hsa_ven_amd_pcs_units_t_HSA_VEN_AMD_PCS_INTERVAL_UNITS_CLOCK_CYCLES:
    hsa_ven_amd_pcs_units_t = 1;
pub const hsa_ven_amd_pcs_units_t_HSA_VEN_AMD_PCS_INTERVAL_UNITS_INSTRUCTIONS:
    hsa_ven_amd_pcs_units_t = 2;
#[doc = " @brief PC Sampling interval unit type"]
pub type hsa_ven_amd_pcs_units_t = ::std::os::raw::c_uint;
#[doc = " @brief HSA callback function to perform the copy onto a destination buffer\n\n If data_size is 0, HSA will stop current copy operation and keep remaining data in internal\n buffers. Remaining contents of HSA internal buffers will be included in next\n hsa_ven_amd_pcs_data_ready_callback_t. HSA internal buffers can also be drained by calling\n hsa_ven_amd_pcs_flush.\n\n @param[in] hsa_callback_data private data to pass back to HSA. Provided in\n hsa_ven_amd_pcs_data_ready_callback_t\n\n @param[in] data_size size of destination buffer in bytes.\n @param[in] destination destination buffer\n @retval    TBD: but could be used to indicate that there is no more data to be read.\n Or indicate an error and abort of current copy operations"]
pub type hsa_ven_amd_pcs_data_copy_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        hsa_callback_data: *mut ::std::os::raw::c_void,
        data_size: usize,
        destination: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t,
>;
#[doc = " @brief HSA callback function to to indicate that there is data ready to be copied\n\n When the client receives this callback, the client should call back @p data_copy_callback for HSA\n to perform the copy operation into an available buffer. @p data_copy_callback can be called back\n multiple times with smaller @p data_size to split the copy operation.\n\n This callback must not call ::hsa_ven_amd_pcs_flush.\n\n @param[in] client_callback_data client private data passed in via\n hsa_ven_amd_pcs_create/hsa_ven_amd_pcs_create_from_id\n @param[in] data_size size of data available to be copied\n @param[in] lost_sample_count number of lost samples since last call to\n hsa_ven_amd_pcs_data_ready_callback_t.\n @param[in] data_copy_callback callback function for HSA to perform the actual copy\n @param[in] hsa_callback_data private data to pass back to HSA"]
pub type hsa_ven_amd_pcs_data_ready_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        client_callback_data: *mut ::std::os::raw::c_void,
        data_size: usize,
        lost_sample_count: usize,
        data_copy_callback: hsa_ven_amd_pcs_data_copy_callback_t,
        hsa_callback_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Opaque handle representing a sampling session.\n Two sessions having same handle value represent the same session"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_pcs_t {
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ven_amd_pcs_t"][::std::mem::size_of::<hsa_ven_amd_pcs_t>() - 8usize];
    ["Alignment of hsa_ven_amd_pcs_t"][::std::mem::align_of::<hsa_ven_amd_pcs_t>() - 8usize];
    ["Offset of field: hsa_ven_amd_pcs_t::handle"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_t, handle) - 0usize];
};
pub const hsa_ven_amd_pcs_configuration_flags_t_HSA_VEN_AMD_PCS_CONFIGURATION_FLAGS_INTERVAL_POWER_OF_2 : hsa_ven_amd_pcs_configuration_flags_t = 1 ;
#[doc = " @brief PC Sampling configuration flag options"]
pub type hsa_ven_amd_pcs_configuration_flags_t = ::std::os::raw::c_uint;
#[doc = " @brief PC Sampling method information\n Used to provide client with list of supported PC Sampling methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_pcs_configuration_t {
    pub method: hsa_ven_amd_pcs_method_kind_t,
    pub units: hsa_ven_amd_pcs_units_t,
    pub min_interval: usize,
    pub max_interval: usize,
    pub flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ven_amd_pcs_configuration_t"]
        [::std::mem::size_of::<hsa_ven_amd_pcs_configuration_t>() - 32usize];
    ["Alignment of hsa_ven_amd_pcs_configuration_t"]
        [::std::mem::align_of::<hsa_ven_amd_pcs_configuration_t>() - 8usize];
    ["Offset of field: hsa_ven_amd_pcs_configuration_t::method"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_configuration_t, method) - 0usize];
    ["Offset of field: hsa_ven_amd_pcs_configuration_t::units"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_configuration_t, units) - 4usize];
    ["Offset of field: hsa_ven_amd_pcs_configuration_t::min_interval"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_configuration_t, min_interval) - 8usize];
    ["Offset of field: hsa_ven_amd_pcs_configuration_t::max_interval"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_configuration_t, max_interval) - 16usize];
    ["Offset of field: hsa_ven_amd_pcs_configuration_t::flags"]
        [::std::mem::offset_of!(hsa_ven_amd_pcs_configuration_t, flags) - 24usize];
};
#[doc = " @brief Callback function to iterate through list of supported PC Sampling configurations\n\n @param[in] configuration one entry for supported PC Sampling method and configuration options\n @param[in] callback_data client private callback data that was passed in when calling\n hsa_ven_amd_pcs_iterate_configuration"]
pub type hsa_ven_amd_pcs_iterate_configuration_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        configuration: *const hsa_ven_amd_pcs_configuration_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t,
>;
unsafe extern "C" {
    #[doc = " @brief Iterate through list of current supported PC Sampling configurations for this @p agent\n\n HSA will callback @p configuration_callback for each currently available PC Sampling\n configuration. The list of currently available configurations may not be the complete list of\n configurations supported on the @p agent. The list of currently available configurations may be\n reduced if the @p agent is currently handling other PC sampling sessions.\n\n @param[in] agent target agent\n @param[in] configuration_callback callback function to iterate through list of configurations\n @param[in] callback_data client private callback data"]
    pub fn hsa_ven_amd_pcs_iterate_configuration(
        agent: hsa_agent_t,
        configuration_callback: hsa_ven_amd_pcs_iterate_configuration_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Create a PC Sampling session on @p agent\n\n Allocate the resources required for a PC Sampling session. The @p method, @p units, @p interval\n parameters must be a legal configuration value, as described by the\n hsa_ven_amd_pcs_configuration_t configurations passed to the callbacks of\n hsa_ven_amd_pcs_iterate_configuration for this @p agent.\n A successfull call may restrict the list of possible PC sampling methods available to subsequent\n calls to hsa_ven_amd_pcs_iterate_configuration on the same agent as agents have limitations\n on what types of PC sampling they can perform concurrently.\n For all successful calls, hsa_ven_amd_pcs_destroy should be called to free this session.\n The session will be in a stopped/inactive state after this call\n\n @param[in] agent target agent\n @param[in] method method to use\n @param[in] units sampling units\n @param[in] interval sampling interval in @p units\n @param[in] latency expected latency in microseconds for client to provide a buffer for the data\n copy callback once HSA calls @p data_ready_callback. This is a performance hint to avoid the\n buffer filling up before the client is notified that data is ready. HSA-runtime will estimate\n how many samples are received within @p latency and call @p data_ready_callback ahead of time so\n that the client has @p latency time to allocate the buffer before the HSA-runtime internal\n buffers are full. The value of latency can be 0.\n @param[in] buffer_size size of client buffer in bytes. @p data_ready_callback will be called once\n HSA-runtime has enough samples to fill @p buffer_size. This needs to be a multiple of size of\n perf_sample_hosttrap_v1_t or size of perf_sample_snapshot_v1_t.\n @param[in] data_ready_callback client callback function that will be called when:\n   1. There is enough samples fill a buffer with @p buffer_size  - estimated samples received\n      within @p latency period.\n OR\n   2. When hsa_ven_amd_pcs_flush is called.\n @param[in] client_callback_data client private data to be provided back when data_ready_callback\n is called.\n @param[out] pc_sampling PC sampling session handle used to reference this session when calling\n hsa_ven_amd_pcs_start, hsa_ven_amd_pcs_stop, hsa_ven_amd_pcs_destroy\n\n @retval ::HSA_STATUS_SUCCESS session created successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT invalid parameters\n @retval ::HSA_STATUS_ERROR_RESOURCE_BUSY agent currently handling another PC Sampling session and\n cannot handle the type requested.\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Failed to allocate resources\n @retval ::HSA_STATUS_ERROR Unexpected error"]
    pub fn hsa_ven_amd_pcs_create(
        agent: hsa_agent_t,
        method: hsa_ven_amd_pcs_method_kind_t,
        units: hsa_ven_amd_pcs_units_t,
        interval: usize,
        latency: usize,
        buffer_size: usize,
        data_ready_callback: hsa_ven_amd_pcs_data_ready_callback_t,
        client_callback_data: *mut ::std::os::raw::c_void,
        pc_sampling: *mut hsa_ven_amd_pcs_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Creates a PC Sampling session on @p agent. Assumes that the caller provides the\n @p pcs_id generated by the previous call to the underlying driver that reserved PC sampling\n on the @p agent.\n\n Similar to the @ref hsa_ven_amd_pcs_create with the difference that it inherits an existing\n PC sampling session that was previously created in the underlying driver.\n\n Allocate the resources required for a PC Sampling session. The @p method, @p units, @p interval\n parameters must be a legal configuration value, and match the parameters that we used to create\n the underlying PC Sampling session in the underlying driver.\n A successfull call may restrict the list of possible PC sampling methods available to subsequent\n calls to hsa_ven_amd_pcs_iterate_configuration on the same agent as agents have limitations\n on what types of PC sampling they can perform concurrently.\n For all successful calls, hsa_ven_amd_pcs_destroy should be called to free this session.\n The session will be in a stopped/inactive state after this call\n\n @param[in] pcs_id ID that uniquely identifies the PC sampling session within underlying driver\n @param[in] agent target agent\n @param[in] method method to use\n @param[in] units sampling units\n @param[in] interval sampling interval in @p units\n @param[in] latency expected latency in microseconds for client to provide a buffer for the data\n copy callback once HSA calls @p data_ready_callback. This is a performance hint to avoid the\n buffer filling up before the client is notified that data is ready. HSA-runtime will estimate\n how many samples are received within @p latency and call @p data_ready_callback ahead of time so\n that the client has @p latency time to allocate the buffer before the HSA-runtime internal\n buffers are full. The value of latency can be 0.\n @param[in] buffer_size size of client buffer in bytes. @p data_ready_callback will be called once\n HSA-runtime has enough samples to fill @p buffer_size. This needs to be a multiple of size of\n perf_sample_hosttrap_v1_t or size of perf_sample_snapshot_v1_t.\n @param[in] data_ready_callback client callback function that will be called when:\n   1. There is enough samples fill a buffer with @p buffer_size  - estimated samples received\n      within @p latency period.\n OR\n   2. When hsa_ven_amd_pcs_flush is called.\n @param[in] client_callback_data client private data to be provided back when data_ready_callback\n is called.\n @param[out] pc_sampling PC sampling session handle used to reference this session when calling\n hsa_ven_amd_pcs_start, hsa_ven_amd_pcs_stop, hsa_ven_amd_pcs_destroy\n\n @retval ::HSA_STATUS_SUCCESS session created successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT invalid parameters\n @retval ::HSA_STATUS_ERROR_RESOURCE_BUSY agent currently handling another PC Sampling session and\n cannot handle the type requested.\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Failed to allocate resources\n @retval ::HSA_STATUS_ERROR Unexpected error"]
    pub fn hsa_ven_amd_pcs_create_from_id(
        pcs_id: u32,
        agent: hsa_agent_t,
        method: hsa_ven_amd_pcs_method_kind_t,
        units: hsa_ven_amd_pcs_units_t,
        interval: usize,
        latency: usize,
        buffer_size: usize,
        data_ready_callback: hsa_ven_amd_pcs_data_ready_callback_t,
        client_callback_data: *mut ::std::os::raw::c_void,
        pc_sampling: *mut hsa_ven_amd_pcs_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Free a PC Sampling session on @p agent\n\n Free all the resources allocated for a PC Sampling session on @p agent\n Internal buffers for this session will be lost.\n If the session was active, the session will be stopped before it is destroyed.\n\n @param[in] pc_sampling PC sampling session handle\n\n @retval ::HSA_STATUS_SUCCESS Session destroyed successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid PC sampling handle\n @retval ::HSA_STATUS_ERROR unexpected error"]
    pub fn hsa_ven_amd_pcs_destroy(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Start a PC Sampling session\n\n Activate a PC Sampling session that was previous created.\n The session with be in a active state after this call\n If the session was already active, this will result in a no-op and will return HSA_STATUS_SUCCESS\n\n @param[in] pc_sampling PC sampling session handle\n\n @retval ::HSA_STATUS_SUCCESS Session started successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid PC sampling handle\n @retval ::HSA_STATUS_ERROR unexpected error"]
    pub fn hsa_ven_amd_pcs_start(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Stop a PC Sampling session\n\n Stop a session that is currently active\n After a session is stopped HSA may still have some PC Sampling data in its internal buffers.\n The internal buffers can be drained using hsa_ven_amd_pcs_flush. If the internal\n buffers are not drained and the session is started again, the internal buffers will be available\n on the next data_ready_callback.\n If the session was already inactive, this will result in a no-op and will return\n HSA_STATUS_SUCCESS\n\n @param[in] pc_sampling PC sampling session handle\n\n @retval ::HSA_STATUS_SUCCESS Session stopped successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid PC sampling handle"]
    pub fn hsa_ven_amd_pcs_stop(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Flush internal buffers for a PC Sampling session\n\n Drain internal buffers for a PC Sampling session. If internal buffers have available data,\n this trigger a data_ready_callback.\n\n The function blocks until all PC samples associated with the @p pc_sampling session\n generated prior to the function call have been communicated by invocations of\n @p data_ready_callback having completed execution.\n\n @param[in] pc_sampling PC sampling session handle\n\n @retval ::HSA_STATUS_SUCCESS Session flushed successfully\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid PC sampling handle"]
    pub fn hsa_ven_amd_pcs_flush(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t;
}
#[doc = " @brief The function pointer table for the PC Sampling v1.00 extension. Can be returned by\n ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_ven_amd_pc_sampling_1_00_pfn_t {
    pub hsa_ven_amd_pcs_iterate_configuration: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            configuration_callback: hsa_ven_amd_pcs_iterate_configuration_callback_t,
            callback_data: *mut ::std::os::raw::c_void,
        ) -> hsa_status_t,
    >,
    pub hsa_ven_amd_pcs_create: ::std::option::Option<
        unsafe extern "C" fn(
            agent: hsa_agent_t,
            method: hsa_ven_amd_pcs_method_kind_t,
            units: hsa_ven_amd_pcs_units_t,
            interval: usize,
            latency: usize,
            buffer_size: usize,
            data_ready_callback: hsa_ven_amd_pcs_data_ready_callback_t,
            client_callback_data: *mut ::std::os::raw::c_void,
            pc_sampling: *mut hsa_ven_amd_pcs_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ven_amd_pcs_create_from_id: ::std::option::Option<
        unsafe extern "C" fn(
            pcs_id: u32,
            agent: hsa_agent_t,
            method: hsa_ven_amd_pcs_method_kind_t,
            units: hsa_ven_amd_pcs_units_t,
            interval: usize,
            latency: usize,
            buffer_size: usize,
            data_ready_callback: hsa_ven_amd_pcs_data_ready_callback_t,
            client_callback_data: *mut ::std::os::raw::c_void,
            pc_sampling: *mut hsa_ven_amd_pcs_t,
        ) -> hsa_status_t,
    >,
    pub hsa_ven_amd_pcs_destroy:
        ::std::option::Option<unsafe extern "C" fn(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t>,
    pub hsa_ven_amd_pcs_start:
        ::std::option::Option<unsafe extern "C" fn(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t>,
    pub hsa_ven_amd_pcs_stop:
        ::std::option::Option<unsafe extern "C" fn(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t>,
    pub hsa_ven_amd_pcs_flush:
        ::std::option::Option<unsafe extern "C" fn(pc_sampling: hsa_ven_amd_pcs_t) -> hsa_status_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_ven_amd_pc_sampling_1_00_pfn_t"]
        [::std::mem::size_of::<hsa_ven_amd_pc_sampling_1_00_pfn_t>() - 56usize];
    ["Alignment of hsa_ven_amd_pc_sampling_1_00_pfn_t"]
        [::std::mem::align_of::<hsa_ven_amd_pc_sampling_1_00_pfn_t>() - 8usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_iterate_configuration"] [:: std :: mem :: offset_of ! (hsa_ven_amd_pc_sampling_1_00_pfn_t , hsa_ven_amd_pcs_iterate_configuration) - 0usize] ;
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_create"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_create
    ) - 8usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_create_from_id"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_create_from_id
    )
        - 16usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_destroy"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_destroy
    ) - 24usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_start"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_start
    ) - 32usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_stop"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_stop
    ) - 40usize];
    ["Offset of field: hsa_ven_amd_pc_sampling_1_00_pfn_t::hsa_ven_amd_pcs_flush"][::std::mem::offset_of!(
        hsa_ven_amd_pc_sampling_1_00_pfn_t,
        hsa_ven_amd_pcs_flush
    ) - 48usize];
};
#[doc = " @brief A fixed-size type used to represent ::hsa_signal_condition_t constants."]
pub type hsa_signal_condition32_t = u32;
#[doc = " Packet used by agents to delay processing of subsequent packets until a\n configurable condition is satisfied by an HSA signal.  Only kernel dispatch\n queues created from AMD GPU Agents support this packet."]
pub const hsa_amd_packet_type_t_HSA_AMD_PACKET_TYPE_BARRIER_VALUE: hsa_amd_packet_type_t = 2;
#[doc = " @brief AMD vendor specific packet type."]
pub type hsa_amd_packet_type_t = ::std::os::raw::c_uint;
#[doc = " @brief A fixed-size type used to represent ::hsa_amd_packet_type_t constants."]
pub type hsa_amd_packet_type8_t = u8;
#[doc = " @brief AMD vendor specific AQL packet header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_packet_header_s {
    #[doc = " Packet header. Used to configure multiple packet parameters such as the\n packet type. The parameters are described by ::hsa_packet_header_t."]
    pub header: u16,
    #[doc = "Format of the vendor specific packet."]
    pub AmdFormat: hsa_amd_packet_type8_t,
    #[doc = " Reserved. Must be 0."]
    pub reserved: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_packet_header_s"][::std::mem::size_of::<hsa_amd_packet_header_s>() - 4usize];
    ["Alignment of hsa_amd_packet_header_s"]
        [::std::mem::align_of::<hsa_amd_packet_header_s>() - 2usize];
    ["Offset of field: hsa_amd_packet_header_s::header"]
        [::std::mem::offset_of!(hsa_amd_packet_header_s, header) - 0usize];
    ["Offset of field: hsa_amd_packet_header_s::AmdFormat"]
        [::std::mem::offset_of!(hsa_amd_packet_header_s, AmdFormat) - 2usize];
    ["Offset of field: hsa_amd_packet_header_s::reserved"]
        [::std::mem::offset_of!(hsa_amd_packet_header_s, reserved) - 3usize];
};
#[doc = " @brief AMD vendor specific AQL packet header"]
pub type hsa_amd_vendor_packet_header_t = hsa_amd_packet_header_s;
#[doc = " @brief AMD barrier value packet.  Halts packet processing and waits for\n (signal_value & ::mask) ::cond ::value to be satisfied, where signal_value\n is the value of the signal ::signal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_barrier_value_packet_s {
    #[doc = " AMD vendor specific packet header."]
    pub header: hsa_amd_vendor_packet_header_t,
    #[doc = " Reserved. Must be 0."]
    pub reserved0: u32,
    #[doc = " Dependent signal object. A signal with a handle value of 0 is\n allowed and is interpreted by the packet processor a satisfied\n dependency."]
    pub signal: hsa_signal_t,
    #[doc = " Value to compare against."]
    pub value: hsa_signal_value_t,
    #[doc = " Bit mask to be combined by bitwise AND with ::signal's value."]
    pub mask: hsa_signal_value_t,
    #[doc = " Comparison operation.  See ::hsa_signal_condition_t."]
    pub cond: hsa_signal_condition32_t,
    #[doc = " Reserved. Must be 0."]
    pub reserved1: u32,
    #[doc = " Reserved. Must be 0."]
    pub reserved2: u64,
    #[doc = " Reserved. Must be 0."]
    pub reserved3: u64,
    #[doc = " Signal used to indicate completion of the job. The application can use the\n special signal handle 0 to indicate that no signal is used."]
    pub completion_signal: hsa_signal_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_barrier_value_packet_s"]
        [::std::mem::size_of::<hsa_amd_barrier_value_packet_s>() - 64usize];
    ["Alignment of hsa_amd_barrier_value_packet_s"]
        [::std::mem::align_of::<hsa_amd_barrier_value_packet_s>() - 8usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::header"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, header) - 0usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::reserved0"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, reserved0) - 4usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::signal"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, signal) - 8usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::value"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, value) - 16usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::mask"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, mask) - 24usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::cond"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, cond) - 32usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::reserved1"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, reserved1) - 36usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::reserved2"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, reserved2) - 40usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::reserved3"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, reserved3) - 48usize];
    ["Offset of field: hsa_amd_barrier_value_packet_s::completion_signal"]
        [::std::mem::offset_of!(hsa_amd_barrier_value_packet_s, completion_signal) - 56usize];
};
#[doc = " @brief AMD barrier value packet.  Halts packet processing and waits for\n (signal_value & ::mask) ::cond ::value to be satisfied, where signal_value\n is the value of the signal ::signal."]
pub type hsa_amd_barrier_value_packet_t = hsa_amd_barrier_value_packet_s;
#[doc = " The memory pool is invalid."]
pub const HSA_STATUS_ERROR_INVALID_MEMORY_POOL: _bindgen_ty_3 = 40;
#[doc = " Agent accessed memory beyond the maximum legal address."]
pub const HSA_STATUS_ERROR_MEMORY_APERTURE_VIOLATION: _bindgen_ty_3 = 41;
#[doc = " Agent executed an invalid shader instruction."]
pub const HSA_STATUS_ERROR_ILLEGAL_INSTRUCTION: _bindgen_ty_3 = 42;
#[doc = " Agent attempted to access an inaccessible address.\n See hsa_amd_register_system_event_handler and\n HSA_AMD_GPU_MEMORY_FAULT_EVENT for more information on illegal accesses."]
pub const HSA_STATUS_ERROR_MEMORY_FAULT: _bindgen_ty_3 = 43;
#[doc = " The CU mask was successfully set but the mask attempted to enable a CU\n which was disabled for the process.  CUs disabled for the process remain\n disabled."]
pub const HSA_STATUS_CU_MASK_REDUCED: _bindgen_ty_3 = 44;
#[doc = " Exceeded number of VGPRs available on this agent"]
pub const HSA_STATUS_ERROR_OUT_OF_REGISTERS: _bindgen_ty_3 = 45;
#[doc = " Resource is busy or temporarily unavailable"]
pub const HSA_STATUS_ERROR_RESOURCE_BUSY: _bindgen_ty_3 = 46;
#[doc = " @brief Enumeration constants added to ::hsa_status_t.\n\n @remark Additions to hsa_status_t"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[doc = " IOMMU not supported"]
pub const hsa_amd_iommu_version_t_HSA_IOMMU_SUPPORT_NONE: hsa_amd_iommu_version_t = 0;
#[doc = " IOMMU V2 supported"]
pub const hsa_amd_iommu_version_t_HSA_IOMMU_SUPPORT_V2: hsa_amd_iommu_version_t = 1;
#[doc = " @brief IOMMU version supported"]
pub type hsa_amd_iommu_version_t = ::std::os::raw::c_uint;
#[doc = " Chip identifier. The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_CHIP_ID: hsa_amd_agent_info_s = 40960;
#[doc = " Size of a cacheline in bytes. The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_CACHELINE_SIZE: hsa_amd_agent_info_s = 40961;
#[doc = " The number of compute unit available in the agent. The type of this\n attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT: hsa_amd_agent_info_s = 40962;
#[doc = " The maximum clock frequency of the agent in MHz. The type of this\n attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MAX_CLOCK_FREQUENCY: hsa_amd_agent_info_s = 40963;
#[doc = " Internal driver node identifier. The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_DRIVER_NODE_ID: hsa_amd_agent_info_s = 40964;
#[doc = " Max number of watch points on memory address ranges to generate exception\n events when the watched addresses are accessed.  The type of this\n attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MAX_ADDRESS_WATCH_POINTS: hsa_amd_agent_info_s =
    40965;
#[doc = " Agent BDF_ID, named LocationID in thunk. The type of this attribute is\n uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_BDFID: hsa_amd_agent_info_s = 40966;
#[doc = " Memory Interface width, the return value type is uint32_t.\n This attribute is deprecated."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MEMORY_WIDTH: hsa_amd_agent_info_s = 40967;
#[doc = " Max Memory Clock, the return value type is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MEMORY_MAX_FREQUENCY: hsa_amd_agent_info_s =
    40968;
#[doc = " Board name of Agent - populated from MarketingName of Kfd Node\n The value is an Ascii string of 64 chars."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_PRODUCT_NAME: hsa_amd_agent_info_s = 40969;
#[doc = " Maximum number of waves possible in a Compute Unit.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU: hsa_amd_agent_info_s = 40970;
#[doc = " Number of SIMD's per compute unit CU\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU: hsa_amd_agent_info_s = 40971;
#[doc = " Number of Shader Engines (SE) in Gpu\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES: hsa_amd_agent_info_s = 40972;
#[doc = " Number of Shader Arrays Per Shader Engines in Gpu\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE: hsa_amd_agent_info_s =
    40973;
#[doc = " Address of the HDP flush registers.  Use of these registers does not conform to the HSA memory\n model and should be treated with caution.\n The type of this attribute is hsa_amd_hdp_flush_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_HDP_FLUSH: hsa_amd_agent_info_s = 40974;
#[doc = " PCIe domain for the agent.  Pairs with HSA_AMD_AGENT_INFO_BDFID\n to give the full physical location of the Agent.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_DOMAIN: hsa_amd_agent_info_s = 40975;
#[doc = " Queries for support of cooperative queues.  See ::HSA_QUEUE_TYPE_COOPERATIVE.\n The type of this attribute is bool."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_COOPERATIVE_QUEUES: hsa_amd_agent_info_s = 40976;
#[doc = " Queries UUID of an agent. The value is an Ascii string with a maximum\n of 21 chars including NUL. The string value consists of two parts: header\n and body. The header identifies device type (GPU, CPU, DSP) while body\n encodes UUID as a 16 digit hex string\n\n Agents that do not support UUID will return the string \"GPU-XX\" or\n \"CPU-XX\" or \"DSP-XX\" depending upon their device type ::hsa_device_type_t"]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_UUID: hsa_amd_agent_info_s = 40977;
#[doc = " Queries for the ASIC revision of an agent. The value is an integer that\n increments for each revision. This can be used by user-level software to\n change how it operates, depending on the hardware version. This allows\n selective workarounds for hardware errata.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_ASIC_REVISION: hsa_amd_agent_info_s = 40978;
#[doc = " Queries whether or not the host can directly access SVM memory that is\n physically resident in the agent's local memory.\n The type of this attribute is bool."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_SVM_DIRECT_HOST_ACCESS: hsa_amd_agent_info_s =
    40979;
#[doc = " Some processors support more CUs than can reliably be used in a cooperative\n dispatch.  This queries the count of CUs which are fully enabled for\n cooperative dispatch.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_COOPERATIVE_COMPUTE_UNIT_COUNT:
    hsa_amd_agent_info_s = 40980;
#[doc = " Queries the amount of memory available in bytes accross all global pools\n owned by the agent.\n The type of this attribute is uint64_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MEMORY_AVAIL: hsa_amd_agent_info_s = 40981;
#[doc = " Timestamp value increase rate, in Hz. The timestamp (clock) frequency is\n in the range 1-400MHz.\n The type of this attribute is uint64_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_TIMESTAMP_FREQUENCY: hsa_amd_agent_info_s = 40982;
#[doc = " Queries for the ASIC family ID of an agent.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_ASIC_FAMILY_ID: hsa_amd_agent_info_s = 41223;
#[doc = " Queries for the Packet Processor(CP Firmware) ucode version of an agent.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_UCODE_VERSION: hsa_amd_agent_info_s = 41224;
#[doc = " Queries for the SDMA engine ucode of an agent.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_SDMA_UCODE_VERSION: hsa_amd_agent_info_s = 41225;
#[doc = " Queries the number of SDMA engines.\n If HSA_AMD_AGENT_INFO_NUM_SDMA_XGMI_ENG query returns non-zero,\n this query returns the the number of SDMA engines optimized for\n host to device bidirectional traffic.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_SDMA_ENG: hsa_amd_agent_info_s = 41226;
#[doc = " Queries the number of additional SDMA engines optimized for D2D xGMI copies.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_SDMA_XGMI_ENG: hsa_amd_agent_info_s = 41227;
#[doc = " Queries for version of IOMMU supported by agent.\n The type of this attribute is hsa_amd_iommu_version_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_IOMMU_SUPPORT: hsa_amd_agent_info_s = 41232;
#[doc = " Queries for number of XCCs within the agent.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NUM_XCC: hsa_amd_agent_info_s = 41233;
#[doc = " Queries for driver unique identifier.\n The type of this attribute is uint32_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_DRIVER_UID: hsa_amd_agent_info_s = 41234;
#[doc = " Returns the hsa_agent_t of the nearest CPU agent\n The type of this attribute is hsa_agent_t."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_NEAREST_CPU: hsa_amd_agent_info_s = 41235;
#[doc = " Bit-mask indicating memory properties of this agent. A memory property is set if the flag bit\n is set at that position. User may use the hsa_flag_isset64 macro to verify whether a flag\n is set. The type of this attribute is uint8_t[8]."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_MEMORY_PROPERTIES: hsa_amd_agent_info_s = 41236;
#[doc = " Bit-mask indicating AQL Extensions supported by this agent. An AQL extension is set if the flag\n bit is set at that position. User may use the hsa_flag_isset64 macro to verify whether a flag\n is set. The type of this attribute is uint8_t[8]."]
pub const hsa_amd_agent_info_s_HSA_AMD_AGENT_INFO_AQL_EXTENSIONS: hsa_amd_agent_info_s = 41237;
#[doc = " @brief Agent attributes."]
pub type hsa_amd_agent_info_s = ::std::os::raw::c_uint;
#[doc = " @brief Agent attributes."]
pub use self::hsa_amd_agent_info_s as hsa_amd_agent_info_t;
pub const hsa_amd_agent_memory_properties_s_HSA_AMD_MEMORY_PROPERTY_AGENT_IS_APU:
    hsa_amd_agent_memory_properties_s = 1;
#[doc = " @brief Agent memory properties attributes"]
pub type hsa_amd_agent_memory_properties_s = ::std::os::raw::c_uint;
#[doc = " @brief Agent memory properties attributes"]
pub use self::hsa_amd_agent_memory_properties_s as hsa_amd_agent_memory_properties_t;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_0: hsa_amd_sdma_engine_id = 1;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_1: hsa_amd_sdma_engine_id = 2;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_2: hsa_amd_sdma_engine_id = 4;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_3: hsa_amd_sdma_engine_id = 8;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_4: hsa_amd_sdma_engine_id = 16;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_5: hsa_amd_sdma_engine_id = 32;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_6: hsa_amd_sdma_engine_id = 64;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_7: hsa_amd_sdma_engine_id = 128;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_8: hsa_amd_sdma_engine_id = 256;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_9: hsa_amd_sdma_engine_id = 512;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_10: hsa_amd_sdma_engine_id = 1024;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_11: hsa_amd_sdma_engine_id = 2048;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_12: hsa_amd_sdma_engine_id = 4096;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_13: hsa_amd_sdma_engine_id = 8192;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_14: hsa_amd_sdma_engine_id = 16384;
pub const hsa_amd_sdma_engine_id_HSA_AMD_SDMA_ENGINE_15: hsa_amd_sdma_engine_id = 32768;
#[doc = " @brief SDMA engine IDs unique by single set bit position."]
pub type hsa_amd_sdma_engine_id = ::std::os::raw::c_uint;
#[doc = " @brief SDMA engine IDs unique by single set bit position."]
pub use self::hsa_amd_sdma_engine_id as hsa_amd_sdma_engine_id_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_hdp_flush_s {
    pub HDP_MEM_FLUSH_CNTL: *mut u32,
    pub HDP_REG_FLUSH_CNTL: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_hdp_flush_s"][::std::mem::size_of::<hsa_amd_hdp_flush_s>() - 16usize];
    ["Alignment of hsa_amd_hdp_flush_s"][::std::mem::align_of::<hsa_amd_hdp_flush_s>() - 8usize];
    ["Offset of field: hsa_amd_hdp_flush_s::HDP_MEM_FLUSH_CNTL"]
        [::std::mem::offset_of!(hsa_amd_hdp_flush_s, HDP_MEM_FLUSH_CNTL) - 0usize];
    ["Offset of field: hsa_amd_hdp_flush_s::HDP_REG_FLUSH_CNTL"]
        [::std::mem::offset_of!(hsa_amd_hdp_flush_s, HDP_REG_FLUSH_CNTL) - 8usize];
};
pub type hsa_amd_hdp_flush_t = hsa_amd_hdp_flush_s;
#[doc = " Determine if host can access the region. The type of this attribute\n is bool."]
pub const hsa_amd_region_info_s_HSA_AMD_REGION_INFO_HOST_ACCESSIBLE: hsa_amd_region_info_s = 40960;
#[doc = " Base address of the region in flat address space."]
pub const hsa_amd_region_info_s_HSA_AMD_REGION_INFO_BASE: hsa_amd_region_info_s = 40961;
#[doc = " Memory Interface width, the return value type is uint32_t.\n This attribute is deprecated. Use HSA_AMD_AGENT_INFO_MEMORY_WIDTH."]
pub const hsa_amd_region_info_s_HSA_AMD_REGION_INFO_BUS_WIDTH: hsa_amd_region_info_s = 40962;
#[doc = " Max Memory Clock, the return value type is uint32_t.\n This attribute is deprecated. Use HSA_AMD_AGENT_INFO_MEMORY_MAX_FREQUENCY."]
pub const hsa_amd_region_info_s_HSA_AMD_REGION_INFO_MAX_CLOCK_FREQUENCY: hsa_amd_region_info_s =
    40963;
#[doc = " @brief Region attributes."]
pub type hsa_amd_region_info_s = ::std::os::raw::c_uint;
#[doc = " @brief Region attributes."]
pub use self::hsa_amd_region_info_s as hsa_amd_region_info_t;
#[doc = " Coherent region."]
pub const hsa_amd_coherency_type_s_HSA_AMD_COHERENCY_TYPE_COHERENT: hsa_amd_coherency_type_s = 0;
#[doc = " Non coherent region."]
pub const hsa_amd_coherency_type_s_HSA_AMD_COHERENCY_TYPE_NONCOHERENT: hsa_amd_coherency_type_s = 1;
#[doc = " @brief Coherency attributes of fine grain region."]
pub type hsa_amd_coherency_type_s = ::std::os::raw::c_uint;
#[doc = " @brief Coherency attributes of fine grain region."]
pub use self::hsa_amd_coherency_type_s as hsa_amd_coherency_type_t;
unsafe extern "C" {
    #[doc = " @brief Get the coherency type of the fine grain region of an agent.\n\n @param[in] agent A valid agent.\n\n @param[out] type Pointer to a memory location where the HSA runtime will\n store the coherency type of the fine grain region.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p type is NULL."]
    pub fn hsa_amd_coherency_get_type(
        agent: hsa_agent_t,
        type_: *mut hsa_amd_coherency_type_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the coherency type of the fine grain region of an agent.\n Deprecated.  This is supported on KV platforms.  For backward compatibility\n other platforms will spuriously succeed.\n\n @param[in] agent A valid agent.\n\n @param[in] type The coherency type to be set.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p type is invalid."]
    pub fn hsa_amd_coherency_set_type(
        agent: hsa_agent_t,
        type_: hsa_amd_coherency_type_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Structure containing profiling dispatch time information.\n\n Times are reported as ticks in the domain of the HSA system clock.\n The HSA system clock tick and frequency is obtained via hsa_system_get_info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_profiling_dispatch_time_s {
    #[doc = " Dispatch packet processing start time."]
    pub start: u64,
    #[doc = " Dispatch packet completion time."]
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_profiling_dispatch_time_s"]
        [::std::mem::size_of::<hsa_amd_profiling_dispatch_time_s>() - 16usize];
    ["Alignment of hsa_amd_profiling_dispatch_time_s"]
        [::std::mem::align_of::<hsa_amd_profiling_dispatch_time_s>() - 8usize];
    ["Offset of field: hsa_amd_profiling_dispatch_time_s::start"]
        [::std::mem::offset_of!(hsa_amd_profiling_dispatch_time_s, start) - 0usize];
    ["Offset of field: hsa_amd_profiling_dispatch_time_s::end"]
        [::std::mem::offset_of!(hsa_amd_profiling_dispatch_time_s, end) - 8usize];
};
#[doc = " @brief Structure containing profiling dispatch time information.\n\n Times are reported as ticks in the domain of the HSA system clock.\n The HSA system clock tick and frequency is obtained via hsa_system_get_info."]
pub type hsa_amd_profiling_dispatch_time_t = hsa_amd_profiling_dispatch_time_s;
#[doc = " @brief Structure containing profiling async copy time information.\n\n Times are reported as ticks in the domain of the HSA system clock.\n The HSA system clock tick and frequency is obtained via hsa_system_get_info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_profiling_async_copy_time_s {
    #[doc = " Async copy processing start time."]
    pub start: u64,
    #[doc = " Async copy completion time."]
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_profiling_async_copy_time_s"]
        [::std::mem::size_of::<hsa_amd_profiling_async_copy_time_s>() - 16usize];
    ["Alignment of hsa_amd_profiling_async_copy_time_s"]
        [::std::mem::align_of::<hsa_amd_profiling_async_copy_time_s>() - 8usize];
    ["Offset of field: hsa_amd_profiling_async_copy_time_s::start"]
        [::std::mem::offset_of!(hsa_amd_profiling_async_copy_time_s, start) - 0usize];
    ["Offset of field: hsa_amd_profiling_async_copy_time_s::end"]
        [::std::mem::offset_of!(hsa_amd_profiling_async_copy_time_s, end) - 8usize];
};
#[doc = " @brief Structure containing profiling async copy time information.\n\n Times are reported as ticks in the domain of the HSA system clock.\n The HSA system clock tick and frequency is obtained via hsa_system_get_info."]
pub type hsa_amd_profiling_async_copy_time_t = hsa_amd_profiling_async_copy_time_s;
unsafe extern "C" {
    #[doc = " @brief Enable or disable profiling capability of a queue.\n\n @param[in] queue A valid queue.\n\n @param[in] enable 1 to enable profiling. 0 to disable profiling.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE The queue is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p queue is NULL."]
    pub fn hsa_amd_profiling_set_profiler_enabled(
        queue: *mut hsa_queue_t,
        enable: ::std::os::raw::c_int,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable or disable asynchronous memory copy profiling.\n\n @details The runtime will provide the copy processing start timestamp and\n completion timestamp of each call to hsa_amd_memory_async_copy if the\n async copy profiling is enabled prior to the call to\n hsa_amd_memory_async_copy. The completion signal object is used to\n hold the last async copy start and end timestamp. The client can retrieve\n these timestamps via call to hsa_amd_profiling_get_async_copy_time.\n\n @param[in] enable True to enable profiling. False to disable profiling.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Failed on allocating resources\n needed to profile the asynchronous copy."]
    pub fn hsa_amd_profiling_async_copy_enable(enable: bool) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve packet processing time stamps.\n\n @param[in] agent The agent with which the signal was last used.  For\n instance, if the profiled dispatch packet is dispatched onto queue Q,\n which was created on agent A, then this parameter must be A.\n\n @param[in] signal A signal used as the completion signal of the dispatch\n packet to retrieve time stamps from.  This dispatch packet must have been\n issued to a queue with profiling enabled and have already completed.  Also\n the signal must not have yet been used in any other packet following the\n completion of the profiled dispatch packet.\n\n @param[out] time Packet processing timestamps in the HSA system clock\n domain.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL The signal is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p time is NULL."]
    pub fn hsa_amd_profiling_get_dispatch_time(
        agent: hsa_agent_t,
        signal: hsa_signal_t,
        time: *mut hsa_amd_profiling_dispatch_time_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve asynchronous copy timestamps.\n\n @details Async copy profiling is enabled via call to\n hsa_amd_profiling_async_copy_enable.\n\n @param[in] signal A signal used as the completion signal of the call to\n hsa_amd_memory_async_copy.\n\n @param[out] time Async copy processing timestamps in the HSA system clock\n domain.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL The signal is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p time is NULL."]
    pub fn hsa_amd_profiling_get_async_copy_time(
        signal: hsa_signal_t,
        time: *mut hsa_amd_profiling_async_copy_time_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Computes the frequency ratio and offset between the agent clock and\n HSA system clock and converts the agent's tick to HSA system domain tick.\n\n @param[in] agent The agent used to retrieve the agent_tick. It is user's\n responsibility to make sure the tick number is from this agent, otherwise,\n the behavior is undefined.\n\n @param[in] agent_tick The tick count retrieved from the specified @p agent.\n\n @param[out] system_tick The translated HSA system domain clock counter tick.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p system_tick is NULL;"]
    pub fn hsa_amd_profiling_convert_tick_to_system_domain(
        agent: hsa_agent_t,
        agent_tick: u64,
        system_tick: *mut u64,
    ) -> hsa_status_t;
}
#[doc = " Signal will only be consumed by AMD GPUs.  Limits signal consumption to\n AMD GPU agents only.  Ignored if @p num_consumers is not zero (all agents)."]
pub const hsa_amd_signal_attribute_t_HSA_AMD_SIGNAL_AMD_GPU_ONLY: hsa_amd_signal_attribute_t = 1;
#[doc = " Signal may be used for interprocess communication.\n IPC signals can be read, written, and waited on from any process.\n Profiling using an IPC enabled signal is only supported in a single process\n at a time.  Producing profiling data in one process and consuming it in\n another process is undefined."]
pub const hsa_amd_signal_attribute_t_HSA_AMD_SIGNAL_IPC: hsa_amd_signal_attribute_t = 2;
#[doc = " @brief Signal attribute flags."]
pub type hsa_amd_signal_attribute_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Create a signal with specific attributes.\n\n @param[in] initial_value Initial value of the signal.\n\n @param[in] num_consumers Size of @p consumers. A value of 0 indicates that\n any agent might wait on the signal.\n\n @param[in] consumers List of agents that might consume (wait on) the\n signal. If @p num_consumers is 0, this argument is ignored; otherwise, the\n HSA runtime might use the list to optimize the handling of the signal\n object. If an agent not listed in @p consumers waits on the returned\n signal, the behavior is undefined. The memory associated with @p consumers\n can be reused or freed after the function returns.\n\n @param[in] attributes Requested signal attributes.  Multiple signal attributes\n may be requested by combining them with bitwise OR.  Requesting no attributes\n (@p attributes == 0) results in the same signal as would have been obtained\n via hsa_signal_create.\n\n @param[out] signal Pointer to a memory location where the HSA runtime will\n store the newly created signal handle. Must not be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n the required resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p signal is NULL, @p\n num_consumers is greater than 0 but @p consumers is NULL, or @p consumers\n contains duplicates."]
    pub fn hsa_amd_signal_create(
        initial_value: hsa_signal_value_t,
        num_consumers: u32,
        consumers: *const hsa_agent_t,
        attributes: u64,
        signal: *mut hsa_signal_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns a pointer to the value of a signal.\n\n Use of this API does not modify the lifetime of ::signal and any\n hsa_signal_value_t retrieved by this API has lifetime equal to that of\n ::signal.\n\n This API is intended for partial interoperability with non-HSA compatible\n devices and should not be used where HSA interfaces are available.\n\n Use of the signal value must comply with use restritions of ::signal.\n Use may result in data races if the operations performed are not platform\n atomic.  Use with HSA_AMD_SIGNAL_AMD_GPU_ONLY or HSA_AMD_SIGNAL_IPC\n attributed signals is required.\n\n @param[in] Signal handle to extract the signal value pointer from.\n\n @param[out] Location where the extracted signal value pointer will be placed.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL signal is not a valid hsa_signal_t\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT value_ptr is NULL."]
    pub fn hsa_amd_signal_value_pointer(
        signal: hsa_signal_t,
        value_ptr: *mut *mut hsa_signal_value_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Asyncronous signal handler function type.\n\n @details Type definition of callback function to be used with\n hsa_amd_signal_async_handler. This callback is invoked if the associated\n signal and condition are met. The callback receives the value of the signal\n which satisfied the associated wait condition and a user provided value. If\n the callback returns true then the callback will be called again if the\n associated signal and condition are satisfied again. If the callback returns\n false then it will not be called again.\n\n @param[in] value Contains the value of the signal observed by\n hsa_amd_signal_async_handler which caused the signal handler to be invoked.\n\n @param[in] arg Contains the user provided value given when the signal handler\n was registered with hsa_amd_signal_async_handler\n\n @retval true resumes monitoring the signal with this handler (as if calling\n hsa_amd_signal_async_handler again with identical parameters)\n\n @retval false stops monitoring the signal with this handler (handler will\n not be called again for this signal)\n"]
pub type hsa_amd_signal_handler = ::std::option::Option<
    unsafe extern "C" fn(value: hsa_signal_value_t, arg: *mut ::std::os::raw::c_void) -> bool,
>;
unsafe extern "C" {
    #[doc = " @brief Register asynchronous signal handler function.\n\n @details Allows registering a callback function and user provided value with\n a signal and wait condition. The callback will be invoked if the associated\n signal and wait condition are satisfied. Callbacks will be invoked serially\n but in an arbitrary order so callbacks should be independent of each other.\n After being invoked a callback may continue to wait for its associated signal\n and condition and, possibly, be invoked again. Or the callback may stop\n waiting. If the callback returns true then it will continue waiting and may\n be called again. If false then the callback will not wait again and will not\n be called again for the associated signal and condition. It is possible to\n register the same callback multiple times with the same or different signals\n and/or conditions. Each registration of the callback will be treated entirely\n independently.\n\n @param[in] signal hsa signal to be asynchronously monitored\n\n @param[in] cond condition value to monitor for\n\n @param[in] value signal value used in condition expression\n\n @param[in] handler asynchronous signal handler invoked when signal's\n condition is met\n\n @param[in] arg user provided value which is provided to handler when handler\n is invoked\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL signal is not a valid hsa_signal_t\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT handler is invalid (NULL)\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime is out of\n resources or blocking signals are not supported by the HSA driver component.\n"]
    pub fn hsa_amd_signal_async_handler(
        signal: hsa_signal_t,
        cond: hsa_signal_condition_t,
        value: hsa_signal_value_t,
        handler: hsa_amd_signal_handler,
        arg: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Call a function asynchronously\n\n @details Provides access to the runtime's asynchronous event handling thread\n for general asynchronous functions.  Functions queued this way are executed\n in the same manner as if they were a signal handler who's signal is\n satisfied.\n\n @param[in] callback asynchronous function to be invoked\n\n @param[in] arg user provided value which is provided to handler when handler\n is invoked\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT handler is invalid (NULL)\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime is out of\n resources or blocking signals are not supported by the HSA driver component.\n"]
    pub fn hsa_amd_async_function(
        callback: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Wait for any signal-condition pair to be satisfied.\n\n @details Allows waiting for any of several signal and conditions pairs to be\n satisfied. The function returns the index into the list of signals of the\n first satisfying signal-condition pair. The value of the satisfying signal's\n value is returned in satisfying_value unless satisfying_value is NULL. This\n function provides only relaxed memory semantics."]
    pub fn hsa_amd_signal_wait_any(
        signal_count: u32,
        signals: *mut hsa_signal_t,
        conds: *mut hsa_signal_condition_t,
        values: *mut hsa_signal_value_t,
        timeout_hint: u64,
        wait_hint: hsa_wait_state_t,
        satisfying_value: *mut hsa_signal_value_t,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Query image limits.\n\n @param[in] agent A valid agent.\n\n @param[in] attribute HSA image info attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE @p value is NULL or @p attribute <\n HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS or @p attribute >\n HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS.\n"]
    pub fn hsa_amd_image_get_info_max_dim(
        agent: hsa_agent_t,
        attribute: hsa_agent_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Set a queue's CU affinity mask.\n\n @details Enables the queue to run on only selected CUs.  The given mask is\n combined by bitwise AND with any device wide mask in HSA_CU_MASK before\n being applied.\n If num_cu_mask_count is 0 then the request is interpreted as a request to\n enable all CUs and no cu_mask array need be given.\n\n @param[in] queue A pointer to HSA queue.\n\n @param[in] num_cu_mask_count Size of CUMask bit array passed in, in bits.\n\n @param[in] cu_mask Bit-vector representing the CU mask.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_CU_MASK_REDUCED The function was successfully executed\n but the given mask attempted to enable a CU which was disabled by\n HSA_CU_MASK.  CUs disabled by HSA_CU_MASK remain disabled.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE @p queue is NULL or invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_cu_mask_count is not\n a multiple of 32 or @p num_cu_mask_count is not 0 and cu_mask is NULL.\n Devices with work group processors must even-index contiguous pairwise\n CU enable e.g. 0x33(b'110011) is valid while 0x5(0x101) and 0x6(b'0110)\n are invalid.\n"]
    pub fn hsa_amd_queue_cu_set_mask(
        queue: *const hsa_queue_t,
        num_cu_mask_count: u32,
        cu_mask: *const u32,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a queue's CU affinity mask.\n\n @details Returns the first num_cu_mask_count bits of a queue's CU mask.\n Ensure that num_cu_mask_count is at least as large as\n HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT to retrieve the entire mask.\n\n @param[in] queue A pointer to HSA queue.\n\n @param[in] num_cu_mask_count Size of CUMask bit array passed in, in bits.\n\n @param[out] cu_mask Bit-vector representing the CU mask.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_QUEUE @p queue is NULL or invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_cu_mask_count is 0, not\n a multiple of 32 or @p cu_mask is NULL.\n"]
    pub fn hsa_amd_queue_cu_get_mask(
        queue: *const hsa_queue_t,
        num_cu_mask_count: u32,
        cu_mask: *mut u32,
    ) -> hsa_status_t;
}
#[doc = " Global segment. Used to hold data that is shared by all agents."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_GLOBAL: hsa_amd_segment_t = 0;
#[doc = " Read-only segment. Used to hold data that remains constant during the\n execution of a kernel."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_READONLY: hsa_amd_segment_t = 1;
#[doc = " Private segment. Used to hold data that is local to a single work-item."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_PRIVATE: hsa_amd_segment_t = 2;
#[doc = " Group segment. Used to hold data that is shared by the work-items of a\n work-group."]
pub const hsa_amd_segment_t_HSA_AMD_SEGMENT_GROUP: hsa_amd_segment_t = 3;
#[doc = " @brief Memory segments associated with a memory pool."]
pub type hsa_amd_segment_t = ::std::os::raw::c_uint;
#[doc = " @brief A memory pool encapsulates physical storage on an agent\n along with a memory access model.\n\n @details A memory pool encapsulates a physical partition of an agent's\n memory system along with a memory access model.  Division of a single\n memory system into separate pools allows querying each partition's access\n path properties (see ::hsa_amd_agent_memory_pool_get_info). Allocations\n from a pool are preferentially bound to that pool's physical partition.\n Binding to the pool's preferential physical partition may not be\n possible or persistent depending on the system's memory policy\n and/or state which is beyond the scope of HSA APIs.\n\n For example, a multi-node NUMA memory system may be represented by multiple\n pool's with each pool providing size and access path information for the\n partition it represents.  Allocations from a pool are preferentially bound\n to the pool's partition (which in this example is a NUMA node) while\n following its memory access model. The actual placement may vary or migrate\n due to the system's NUMA policy and state, which is beyond the scope of\n HSA APIs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_memory_pool_s {
    #[doc = " Opaque handle."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_memory_pool_s"][::std::mem::size_of::<hsa_amd_memory_pool_s>() - 8usize];
    ["Alignment of hsa_amd_memory_pool_s"]
        [::std::mem::align_of::<hsa_amd_memory_pool_s>() - 8usize];
    ["Offset of field: hsa_amd_memory_pool_s::handle"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_s, handle) - 0usize];
};
#[doc = " @brief A memory pool encapsulates physical storage on an agent\n along with a memory access model.\n\n @details A memory pool encapsulates a physical partition of an agent's\n memory system along with a memory access model.  Division of a single\n memory system into separate pools allows querying each partition's access\n path properties (see ::hsa_amd_agent_memory_pool_get_info). Allocations\n from a pool are preferentially bound to that pool's physical partition.\n Binding to the pool's preferential physical partition may not be\n possible or persistent depending on the system's memory policy\n and/or state which is beyond the scope of HSA APIs.\n\n For example, a multi-node NUMA memory system may be represented by multiple\n pool's with each pool providing size and access path information for the\n partition it represents.  Allocations from a pool are preferentially bound\n to the pool's partition (which in this example is a NUMA node) while\n following its memory access model. The actual placement may vary or migrate\n due to the system's NUMA policy and state, which is beyond the scope of\n HSA APIs."]
pub type hsa_amd_memory_pool_t = hsa_amd_memory_pool_s;
#[doc = " The application can use allocations in the memory pool to store kernel\n arguments, and provide the values for the kernarg segment of\n a kernel dispatch."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT:
    hsa_amd_memory_pool_global_flag_s = 1;
#[doc = " Updates to memory in this pool conform to HSA memory consistency model.\n If this flag is set, then ::HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED\n must not be set."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_FINE_GRAINED:
    hsa_amd_memory_pool_global_flag_s = 2;
#[doc = " Writes to memory in this pool can be performed by a single agent at a time."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED:
    hsa_amd_memory_pool_global_flag_s = 4;
#[doc = " Updates to memory in this memory pool have extended scope, acting as\n system-scope atomics for variables in memory regions of this type.\n Note: On non-compliant systems, device-specific actions may be required\n for system-scope coherence."]
pub const hsa_amd_memory_pool_global_flag_s_HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_EXTENDED_SCOPE_FINE_GRAINED : hsa_amd_memory_pool_global_flag_s = 8 ;
pub type hsa_amd_memory_pool_global_flag_s = ::std::os::raw::c_uint;
pub use self::hsa_amd_memory_pool_global_flag_s as hsa_amd_memory_pool_global_flag_t;
#[doc = " This memory pool resides on the host (CPU)"]
pub const hsa_amd_memory_pool_location_s_HSA_AMD_MEMORY_POOL_LOCATION_CPU:
    hsa_amd_memory_pool_location_s = 0;
#[doc = " This memory pool resides on a GPU"]
pub const hsa_amd_memory_pool_location_s_HSA_AMD_MEMORY_POOL_LOCATION_GPU:
    hsa_amd_memory_pool_location_s = 1;
pub type hsa_amd_memory_pool_location_s = ::std::os::raw::c_uint;
pub use self::hsa_amd_memory_pool_location_s as hsa_amd_memory_pool_location_t;
#[doc = " Segment where the memory pool resides. The type of this attribute is\n ::hsa_amd_segment_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_SEGMENT: hsa_amd_memory_pool_info_t =
    0;
#[doc = " Flag mask. The value of this attribute is undefined if the value of\n ::HSA_AMD_MEMORY_POOL_INFO_SEGMENT is not ::HSA_AMD_SEGMENT_GLOBAL. The type\n of\n this attribute is uint32_t, a bit-field of\n ::hsa_amd_memory_pool_global_flag_t\n values."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS:
    hsa_amd_memory_pool_info_t = 1;
#[doc = " Size of this pool, in bytes. The type of this attribute is size_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_SIZE: hsa_amd_memory_pool_info_t = 2;
#[doc = " Indicates whether memory in this pool can be allocated using\n ::hsa_amd_memory_pool_allocate. The type of this attribute is bool.\n\n The value of this flag is always false for memory pools in the group and\n private segments."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED:
    hsa_amd_memory_pool_info_t = 5;
#[doc = " Allocation granularity of buffers allocated by\n ::hsa_amd_memory_pool_allocate\n in this memory pool. The size of a buffer allocated in this pool is a\n multiple of the value of this attribute. While this is the minimum size of\n allocation allowed, it is recommened to use\n HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_REC_GRANULE to obtain the recommended\n allocation granularity size for this pool.\n The value of this attribute is only defined if\n ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED is true for\n this pool. The type of this attribute is size_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_GRANULE:
    hsa_amd_memory_pool_info_t = 6;
#[doc = " Alignment of buffers allocated by ::hsa_amd_memory_pool_allocate in this\n pool. The value of this attribute is only defined if\n ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED is true for this pool, and\n must be a power of 2. The type of this attribute is size_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALIGNMENT:
    hsa_amd_memory_pool_info_t = 7;
#[doc = " This memory_pool can be made directly accessible by all the agents in the\n system (::hsa_amd_agent_memory_pool_get_info does not return\n ::HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED for any agent). The type of this\n attribute is bool."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_ACCESSIBLE_BY_ALL:
    hsa_amd_memory_pool_info_t = 15;
#[doc = " Maximum aggregate allocation size in bytes. The type of this attribute\n is size_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_ALLOC_MAX_SIZE:
    hsa_amd_memory_pool_info_t = 16;
#[doc = " Location of this memory pool. The type of this attribute\n is hsa_amd_memory_pool_location_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_LOCATION: hsa_amd_memory_pool_info_t =
    17;
#[doc = " Internal block size for allocations. This would also be the recommended\n granularity size for allocations as this prevents internal fragmentation.\n The value of this attribute is only defined if\n ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED is true for this pool.\n The size of this attribute is size_t."]
pub const hsa_amd_memory_pool_info_t_HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_REC_GRANULE:
    hsa_amd_memory_pool_info_t = 18;
#[doc = " @brief Memory pool features."]
pub type hsa_amd_memory_pool_info_t = ::std::os::raw::c_uint;
#[doc = " Allocates memory that conforms to standard HSA memory consistency model"]
pub const hsa_amd_memory_pool_flag_s_HSA_AMD_MEMORY_POOL_STANDARD_FLAG: hsa_amd_memory_pool_flag_s =
    0;
#[doc = " Allocates fine grain memory type where memory ordering is per point to point\n connection. Atomic memory operations on these memory buffers are not\n guaranteed to be visible at system scope."]
pub const hsa_amd_memory_pool_flag_s_HSA_AMD_MEMORY_POOL_PCIE_FLAG: hsa_amd_memory_pool_flag_s = 1;
#[doc = "  Allocates physically contiguous memory"]
pub const hsa_amd_memory_pool_flag_s_HSA_AMD_MEMORY_POOL_CONTIGUOUS_FLAG:
    hsa_amd_memory_pool_flag_s = 2;
#[doc = " @brief Memory pool flag used to specify allocation directives\n"]
pub type hsa_amd_memory_pool_flag_s = ::std::os::raw::c_uint;
#[doc = " @brief Memory pool flag used to specify allocation directives\n"]
pub use self::hsa_amd_memory_pool_flag_s as hsa_amd_memory_pool_flag_t;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute of a memory pool.\n\n @param[in] memory_pool A valid memory pool.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to a application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n"]
    pub fn hsa_amd_memory_pool_get_info(
        memory_pool: hsa_amd_memory_pool_t,
        attribute: hsa_amd_memory_pool_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Iterate over the memory pools associated with a given agent, and\n invoke an application-defined callback on every iteration.\n\n @details An agent can directly access buffers located in some memory pool, or\n be enabled to access them by the application (see ::hsa_amd_agents_allow_access),\n yet that memory pool may not be returned by this function for that given\n agent.\n\n A memory pool of fine-grained type must be associated only with the host.\n\n @param[in] agent A valid agent.\n\n @param[in] callback Callback to be invoked on the same thread that called\n ::hsa_amd_agent_iterate_memory_pools, serially, once per memory pool that is\n associated with the agent.  The HSA runtime passes two arguments to the\n callback: the memory pool, and the application data.  If @p callback\n returns a status other than ::HSA_STATUS_SUCCESS for a particular iteration,\n the traversal stops and ::hsa_amd_agent_iterate_memory_pools returns that status\n value.\n\n @param[in] data Application data that is passed to @p callback on every\n iteration. May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL."]
    pub fn hsa_amd_agent_iterate_memory_pools(
        agent: hsa_agent_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                memory_pool: hsa_amd_memory_pool_t,
                data: *mut ::std::os::raw::c_void,
            ) -> hsa_status_t,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a block of memory (or buffer) in the specified pool.\n\n @param[in] memory_pool Memory pool where to allocate memory from. The memory\n pool must have the ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED flag set.\n\n @param[in] size Allocation size, in bytes. Must not be zero. This value is\n rounded up to the nearest multiple of\n ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_GRANULE in @p memory_pool.\n\n @param[in] flags A bit-field that is used to specify allocation\n directives.\n\n @param[out] ptr Pointer to the location where to store the base virtual\n address of\n the allocated block. The returned base address is aligned to the value of\n ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALIGNMENT in @p memory_pool. If the\n allocation fails, the returned value is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES No memory is available.\n\n @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL The memory pool is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION The host is not allowed to\n allocate memory in @p memory_pool, or @p size is greater than\n the value of HSA_AMD_MEMORY_POOL_INFO_ALLOC_MAX_SIZE in @p memory_pool.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL, or @p size is 0,\n or flags is not 0.\n"]
    pub fn hsa_amd_memory_pool_allocate(
        memory_pool: hsa_amd_memory_pool_t,
        size: usize,
        flags: u32,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Deallocate a block of memory previously allocated using\n ::hsa_amd_memory_pool_allocate.\n\n @param[in] ptr Pointer to a memory block. If @p ptr does not match a value\n previously returned by ::hsa_amd_memory_pool_allocate, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n"]
    pub fn hsa_amd_memory_pool_free(ptr: *mut ::std::os::raw::c_void) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Asynchronously copy a block of memory from the location pointed to by\n @p src on the @p src_agent to the memory block pointed to by @p dst on the @p\n dst_agent.\n Because the DMA engines used may not be in the same coherency domain, the caller must ensure\n that buffers are system-level coherent. In general this requires the sending device to have\n released the buffer to system scope prior to executing the copy API and the receiving device\n must execute a system scope acquire fence prior to use of the destination buffer.\n\n @param[out] dst Buffer where the content is to be copied.\n\n @param[in] dst_agent Agent associated with the @p dst. The agent must be able to directly\n access both the source and destination buffers in their current locations.\n May be zero in which case the runtime will attempt to discover the destination agent.\n Discovery may have variable and/or high latency.\n\n @param[in] src A valid pointer to the source of data to be copied. The source\n buffer must not overlap with the destination buffer, otherwise the copy will succeed\n but contents of @p dst is undefined.\n\n @param[in] src_agent Agent associated with the @p src. The agent must be able to directly\n access both the source and destination buffers in their current locations.\n May be zero in which case the runtime will attempt to discover the destination agent.\n Discovery may have variable and/or high latency.\n\n @param[in] size Number of bytes to copy. If @p size is 0, no copy is\n performed and the function returns success. Copying a number of bytes larger\n than the size of the buffers pointed by @p dst or @p src results in undefined\n behavior.\n\n @param[in] num_dep_signals Number of dependent signals. Can be 0.\n\n @param[in] dep_signals List of signals that must be waited on before the copy\n operation starts. The copy will start after every signal has been observed with\n the value 0. The dependent signal should not include completion signal from\n hsa_amd_memory_async_copy operation to be issued in future as that can result\n in a deadlock. If @p num_dep_signals is 0, this argument is ignored.\n\n @param[in] completion_signal Signal used to indicate completion of the copy\n operation. When the copy operation is finished, the value of the signal is\n decremented. The runtime indicates that an error has occurred during the copy\n operation by setting the value of the completion signal to a negative\n number. The signal handle must not be 0.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully. The\n application is responsible for checking for asynchronous error conditions\n (see the description of @p completion_signal).\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT An agent is invalid or no discovered agent has access.\n\n @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL @p completion_signal is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The source or destination\n pointers are NULL, or the completion signal is 0."]
    pub fn hsa_amd_memory_async_copy(
        dst: *mut ::std::os::raw::c_void,
        dst_agent: hsa_agent_t,
        src: *const ::std::os::raw::c_void,
        src_agent: hsa_agent_t,
        size: usize,
        num_dep_signals: u32,
        dep_signals: *const hsa_signal_t,
        completion_signal: hsa_signal_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Asynchronously copy a block of memory from the location pointed to by\n @p src on the @p src_agent to the memory block pointed to by @p dst on the @p\n dst_agent on engine_id.\n\n WARNING: Concurrent use of this call with hsa_amd_memory_async_copy can result\n in resource conflicts as HSA runtime will auto assign engines with the latter\n call.  Approach using both calls concurrently with caution.\n\n All param definitions are identical to hsa_amd_memory_async_copy with the\n exception of engine_id and force_copy_on_sdma.\n\n @param[in] - engine_id Target engine defined by hsa_amd_sdma_engine_id_t.\n Client should use hsa_amd_memory_copy_engine_status first to get the ID\n availability.\n\n @param[in] - force_copy_on_sdma By default, blit kernel copies are used when\n dst_agent == src_agent.  Setting this to true will force the copy over SDMA1.\n\n All return definitions are identical to hsa_amd_memory_async_copy with the\n following ammendments:\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The source or destination\n pointers are NULL, or the completion signal is 0 or engine_id is improperly\n bounded."]
    pub fn hsa_amd_memory_async_copy_on_engine(
        dst: *mut ::std::os::raw::c_void,
        dst_agent: hsa_agent_t,
        src: *const ::std::os::raw::c_void,
        src_agent: hsa_agent_t,
        size: usize,
        num_dep_signals: u32,
        dep_signals: *const hsa_signal_t,
        completion_signal: hsa_signal_t,
        engine_id: hsa_amd_sdma_engine_id_t,
        force_copy_on_sdma: bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Reports the availability of SDMA copy engines.\n\n @param[in] dst_agent Destination agent of copy status direction.\n\n @param[in] src_agent Source agent of copy status direction.\n\n @param[out] engine_ids_mask returns available SDMA engine IDs that can be masked\n with hsa_amd_sdma_engine_id_t.\n\n @retval ::HSA_STATUS_SUCCESS Agent has available SDMA engines.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Agent does not have available SDMA engines.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT dst_agent and src_agent are the same as\n dst_agent == src_agent is generally used for shader copies."]
    pub fn hsa_amd_memory_copy_engine_status(
        dst_agent: hsa_agent_t,
        src_agent: hsa_agent_t,
        engine_ids_mask: *mut u32,
    ) -> hsa_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_pitched_ptr_s {
    pub base: *mut ::std::os::raw::c_void,
    pub pitch: usize,
    pub slice: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_pitched_ptr_s"][::std::mem::size_of::<hsa_pitched_ptr_s>() - 24usize];
    ["Alignment of hsa_pitched_ptr_s"][::std::mem::align_of::<hsa_pitched_ptr_s>() - 8usize];
    ["Offset of field: hsa_pitched_ptr_s::base"]
        [::std::mem::offset_of!(hsa_pitched_ptr_s, base) - 0usize];
    ["Offset of field: hsa_pitched_ptr_s::pitch"]
        [::std::mem::offset_of!(hsa_pitched_ptr_s, pitch) - 8usize];
    ["Offset of field: hsa_pitched_ptr_s::slice"]
        [::std::mem::offset_of!(hsa_pitched_ptr_s, slice) - 16usize];
};
pub type hsa_pitched_ptr_t = hsa_pitched_ptr_s;
pub const hsa_amd_copy_direction_t_hsaHostToHost: hsa_amd_copy_direction_t = 0;
pub const hsa_amd_copy_direction_t_hsaHostToDevice: hsa_amd_copy_direction_t = 1;
pub const hsa_amd_copy_direction_t_hsaDeviceToHost: hsa_amd_copy_direction_t = 2;
pub const hsa_amd_copy_direction_t_hsaDeviceToDevice: hsa_amd_copy_direction_t = 3;
pub type hsa_amd_copy_direction_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn hsa_amd_memory_async_copy_rect(
        dst: *const hsa_pitched_ptr_t,
        dst_offset: *const hsa_dim3_t,
        src: *const hsa_pitched_ptr_t,
        src_offset: *const hsa_dim3_t,
        range: *const hsa_dim3_t,
        copy_agent: hsa_agent_t,
        dir: hsa_amd_copy_direction_t,
        num_dep_signals: u32,
        dep_signals: *const hsa_signal_t,
        completion_signal: hsa_signal_t,
    ) -> hsa_status_t;
}
#[doc = " The agent cannot directly access any buffer in the memory pool."]
pub const hsa_amd_memory_pool_access_t_HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED:
    hsa_amd_memory_pool_access_t = 0;
#[doc = " The agent can directly access a buffer located in the pool; the application\n does not need to invoke ::hsa_amd_agents_allow_access."]
pub const hsa_amd_memory_pool_access_t_HSA_AMD_MEMORY_POOL_ACCESS_ALLOWED_BY_DEFAULT:
    hsa_amd_memory_pool_access_t = 1;
#[doc = " The agent can directly access a buffer located in the pool, but only if the\n application has previously requested access to that buffer using\n ::hsa_amd_agents_allow_access."]
pub const hsa_amd_memory_pool_access_t_HSA_AMD_MEMORY_POOL_ACCESS_DISALLOWED_BY_DEFAULT:
    hsa_amd_memory_pool_access_t = 2;
#[doc = " @brief Type of accesses to a memory pool from a given agent."]
pub type hsa_amd_memory_pool_access_t = ::std::os::raw::c_uint;
#[doc = " Hyper-transport bus type."]
pub const hsa_amd_link_info_type_t_HSA_AMD_LINK_INFO_TYPE_HYPERTRANSPORT: hsa_amd_link_info_type_t =
    0;
#[doc = " QPI bus type."]
pub const hsa_amd_link_info_type_t_HSA_AMD_LINK_INFO_TYPE_QPI: hsa_amd_link_info_type_t = 1;
#[doc = " PCIe bus type."]
pub const hsa_amd_link_info_type_t_HSA_AMD_LINK_INFO_TYPE_PCIE: hsa_amd_link_info_type_t = 2;
#[doc = " Infiniband bus type."]
pub const hsa_amd_link_info_type_t_HSA_AMD_LINK_INFO_TYPE_INFINBAND: hsa_amd_link_info_type_t = 3;
#[doc = " xGMI link type."]
pub const hsa_amd_link_info_type_t_HSA_AMD_LINK_INFO_TYPE_XGMI: hsa_amd_link_info_type_t = 4;
#[doc = " @brief Properties of the relationship between an agent a memory pool."]
pub type hsa_amd_link_info_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Link properties when accessing the memory pool from the specified\n agent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_memory_pool_link_info_s {
    #[doc = " Minimum transfer latency (rounded to ns)."]
    pub min_latency: u32,
    #[doc = " Maximum transfer latency (rounded to ns)."]
    pub max_latency: u32,
    #[doc = " Minimum link interface bandwidth in MB/s."]
    pub min_bandwidth: u32,
    #[doc = " Maximum link interface bandwidth in MB/s."]
    pub max_bandwidth: u32,
    #[doc = " Support for 32-bit atomic transactions."]
    pub atomic_support_32bit: bool,
    #[doc = " Support for 64-bit atomic transactions."]
    pub atomic_support_64bit: bool,
    #[doc = " Support for cache coherent transactions."]
    pub coherent_support: bool,
    #[doc = " The type of bus/link."]
    pub link_type: hsa_amd_link_info_type_t,
    #[doc = " NUMA distance of memory pool relative to querying agent"]
    pub numa_distance: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_memory_pool_link_info_s"]
        [::std::mem::size_of::<hsa_amd_memory_pool_link_info_s>() - 28usize];
    ["Alignment of hsa_amd_memory_pool_link_info_s"]
        [::std::mem::align_of::<hsa_amd_memory_pool_link_info_s>() - 4usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::min_latency"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, min_latency) - 0usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::max_latency"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, max_latency) - 4usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::min_bandwidth"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, min_bandwidth) - 8usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::max_bandwidth"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, max_bandwidth) - 12usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::atomic_support_32bit"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, atomic_support_32bit) - 16usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::atomic_support_64bit"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, atomic_support_64bit) - 17usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::coherent_support"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, coherent_support) - 18usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::link_type"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, link_type) - 20usize];
    ["Offset of field: hsa_amd_memory_pool_link_info_s::numa_distance"]
        [::std::mem::offset_of!(hsa_amd_memory_pool_link_info_s, numa_distance) - 24usize];
};
#[doc = " @brief Link properties when accessing the memory pool from the specified\n agent."]
pub type hsa_amd_memory_pool_link_info_t = hsa_amd_memory_pool_link_info_s;
#[doc = " Access to buffers located in the memory pool. The type of this attribute\n is ::hsa_amd_memory_pool_access_t.\n\n An agent can always directly access buffers currently located in a memory\n pool that is associated (the memory_pool is one of the values returned by\n ::hsa_amd_agent_iterate_memory_pools on the agent) with that agent. If the\n buffer is currently located in a memory pool that is not associated with\n the agent, and the value returned by this function for the given\n combination of agent and memory pool is not\n HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED, the application still needs to invoke\n ::hsa_amd_agents_allow_access in order to gain direct access to the buffer.\n\n If the given agent can directly access buffers the pool, the result is not\n HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. If the memory pool is associated with\n the agent, or it is of fined-grained type, the result must not be\n HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. If the memory pool is not associated\n with the agent, and does not reside in the global segment, the result must\n be HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED."]
pub const hsa_amd_agent_memory_pool_info_t_HSA_AMD_AGENT_MEMORY_POOL_INFO_ACCESS:
    hsa_amd_agent_memory_pool_info_t = 0;
#[doc = " Number of links to hop when accessing the memory pool from the specified\n agent. The value of this attribute is zero if the memory pool is associated\n with the agent, or if the access type is\n HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. The type of this attribute is\n uint32_t."]
pub const hsa_amd_agent_memory_pool_info_t_HSA_AMD_AGENT_MEMORY_POOL_INFO_NUM_LINK_HOPS:
    hsa_amd_agent_memory_pool_info_t = 1;
#[doc = " Details of each link hop when accessing the memory pool starting from the\n specified agent. The type of this attribute is an array size of\n HSA_AMD_AGENT_MEMORY_POOL_INFO_NUM_LINK_HOPS with each element containing\n ::hsa_amd_memory_pool_link_info_t."]
pub const hsa_amd_agent_memory_pool_info_t_HSA_AMD_AGENT_MEMORY_POOL_INFO_LINK_INFO:
    hsa_amd_agent_memory_pool_info_t = 2;
#[doc = " @brief Properties of the relationship between an agent a memory pool."]
pub type hsa_amd_agent_memory_pool_info_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Get the current value of an attribute of the relationship between an\n agent and a memory pool.\n\n @param[in] agent Agent.\n\n @param[in] memory_pool Memory pool.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to a application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of @p attribute, the behavior is undefined.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n"]
    pub fn hsa_amd_agent_memory_pool_get_info(
        agent: hsa_agent_t,
        memory_pool: hsa_amd_memory_pool_t,
        attribute: hsa_amd_agent_memory_pool_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable direct access to a buffer from a given set of agents.\n\n @details\n\n Upon return, only the listed agents and the agent associated with the\n buffer's memory pool have direct access to the @p ptr.\n\n Any agent that has access to the buffer before and after the call to\n ::hsa_amd_agents_allow_access will also have access while\n ::hsa_amd_agents_allow_access is in progress.\n\n The caller is responsible for ensuring that each agent in the list\n must be able to access the memory pool containing @p ptr\n (using ::hsa_amd_agent_memory_pool_get_info with ::HSA_AMD_AGENT_MEMORY_POOL_INFO_ACCESS attribute),\n otherwise error code is returned.\n\n @param[in] num_agents Size of @p agents.\n\n @param[in] agents List of agents. If @p num_agents is 0, this argument is\n ignored.\n\n @param[in] flags A list of bit-field that is used to specify access\n information in a per-agent basis. This is currently reserved and must be NULL.\n\n @param[in] ptr A buffer previously allocated using ::hsa_amd_memory_pool_allocate.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_agents is 0, or @p agents\n is NULL, @p flags is not NULL, or attempting to enable access to agent(s)\n because @p ptr is allocated from an inaccessible pool.\n"]
    pub fn hsa_amd_agents_allow_access(
        num_agents: u32,
        agents: *const hsa_agent_t,
        flags: *const u32,
        ptr: *const ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Query if buffers currently located in some memory pool can be\n relocated to a destination memory pool.\n\n @details If the returned value is non-zero, a migration of a buffer to @p\n dst_memory_pool using ::hsa_amd_memory_migrate may nevertheless fail due to\n resource limitations.\n\n @param[in] src_memory_pool Source memory pool.\n\n @param[in] dst_memory_pool Destination memory pool.\n\n @param[out] result Pointer to a memory location where the result of the query\n is stored. Must not be NULL. If buffers currently located in @p\n src_memory_pool can be relocated to @p dst_memory_pool, the result is\n true.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL One of the memory pools is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p result is NULL."]
    pub fn hsa_amd_memory_pool_can_migrate(
        src_memory_pool: hsa_amd_memory_pool_t,
        dst_memory_pool: hsa_amd_memory_pool_t,
        result: *mut bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Relocate a buffer to a new memory pool.\n\n @details When a buffer is migrated, its virtual address remains the same but\n its physical contents are moved to the indicated memory pool.\n\n After migration, only the agent associated with the destination pool will have access.\n\n The caller is also responsible for ensuring that the allocation in the\n source memory pool where the buffer is currently located can be migrated to the\n specified destination memory pool (using ::hsa_amd_memory_pool_can_migrate returns a value of true\n for the source and destination memory pools), otherwise behavior is undefined.\n\n The caller must ensure that the buffer is not accessed while it is migrated.\n\n @param[in] ptr Buffer to be relocated. The buffer must have been released to system\n prior to call this API.  The buffer will be released to system upon completion.\n\n @param[in] memory_pool Memory pool where to place the buffer.\n\n @param[in] flags A bit-field that is used to specify migration\n information. Must be zero.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL The destination memory pool is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n allocating the necessary resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p flags is not 0."]
    pub fn hsa_amd_memory_migrate(
        ptr: *const ::std::os::raw::c_void,
        memory_pool: hsa_amd_memory_pool_t,
        flags: u32,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Pin a host pointer allocated by C/C++ or OS allocator (i.e. ordinary system DRAM) and\n return a new pointer accessible by the @p agents. If the @p host_ptr overlaps with previously\n locked memory, then the overlap area is kept locked (i.e multiple mappings are permitted). In\n this case, the same input @p host_ptr may give different locked @p agent_ptr and when it does,\n they are not necessarily coherent (i.e. accessing either @p agent_ptr is not equivalent).\n Accesses to @p agent_ptr are coarse grained.\n\n @param[in] host_ptr A buffer allocated by C/C++ or OS allocator.\n\n @param[in] size The size to be locked.\n\n @param[in] agents Array of agent handle to gain access to the @p host_ptr.\n If this parameter is NULL and the @p num_agent is 0, all agents\n in the platform will gain access to the @p host_ptr.\n\n @param[out] agent_ptr Pointer to the location where to store the new address.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n allocating the necessary resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT One or more agent in @p agents is\n invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is 0 or @p host_ptr or\n @p agent_ptr is NULL or @p agents not NULL but @p num_agent is 0 or @p agents\n is NULL but @p num_agent is not 0."]
    pub fn hsa_amd_memory_lock(
        host_ptr: *mut ::std::os::raw::c_void,
        size: usize,
        agents: *mut hsa_agent_t,
        num_agent: ::std::os::raw::c_int,
        agent_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Pin a host pointer allocated by C/C++ or OS allocator (i.e. ordinary system DRAM) and\n return a new pointer accessible by the @p agents. If the @p host_ptr overlaps with previously\n locked memory, then the overlap area is kept locked (i.e. multiple mappings are permitted).\n In this case, the same input @p host_ptr may give different locked @p agent_ptr and when it\n does, they are not necessarily coherent (i.e. accessing either @p agent_ptr is not equivalent).\n Acesses to the memory via @p agent_ptr have the same access properties as memory allocated from\n @p pool as determined by ::hsa_amd_memory_pool_get_info and ::hsa_amd_agent_memory_pool_get_info\n (ex. coarse/fine grain, platform atomic support, link info).  Physical composition and placement\n of the memory (ex. page size, NUMA binding) is not changed.\n\n @param[in] host_ptr A buffer allocated by C/C++ or OS allocator.\n\n @param[in] size The size to be locked.\n\n @param[in] agents Array of agent handle to gain access to the @p host_ptr.\n If this parameter is NULL and the @p num_agent is 0, all agents\n in the platform will gain access to the @p host_ptr.\n\n @param[in] pool Global memory pool owned by a CPU agent.\n\n @param[in] flags A bit-field that is used to specify allocation\n directives. Reserved parameter, must be 0.\n\n @param[out] agent_ptr Pointer to the location where to store the new address.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n allocating the necessary resources.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT One or more agent in @p agents is\n invalid or can not access @p pool.\n\n @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL @p pool is invalid or not owned\n by a CPU agent.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is 0 or @p host_ptr or\n @p agent_ptr is NULL or @p agents not NULL but @p num_agent is 0 or @p agents\n is NULL but @p num_agent is not 0 or flags is not 0."]
    pub fn hsa_amd_memory_lock_to_pool(
        host_ptr: *mut ::std::os::raw::c_void,
        size: usize,
        agents: *mut hsa_agent_t,
        num_agent: ::std::os::raw::c_int,
        pool: hsa_amd_memory_pool_t,
        flags: u32,
        agent_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Unpin the host pointer previously pinned via ::hsa_amd_memory_lock or\n ::hsa_amd_memory_lock_to_pool.\n\n @details The behavior is undefined if the host pointer being unpinned does not\n match previous pinned address or if the host pointer was already deallocated.\n\n @param[in] host_ptr A buffer allocated by C/C++ or OS allocator that was\n pinned previously via ::hsa_amd_memory_lock or ::hsa_amd_memory_lock_to_pool.\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized."]
    pub fn hsa_amd_memory_unlock(host_ptr: *mut ::std::os::raw::c_void) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the first @p count of uint32_t of the block of memory pointed by\n @p ptr to the specified @p value.\n\n @param[in] ptr Pointer to the block of memory to fill.\n\n @param[in] value Value to be set.\n\n @param[in] count Number of uint32_t element to be set to the value.\n\n @retval HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL or\n not 4 bytes aligned\n\n @retval HSA_STATUS_ERROR_INVALID_ALLOCATION if the given memory\n region was not allocated with HSA runtime APIs.\n"]
    pub fn hsa_amd_memory_fill(
        ptr: *mut ::std::os::raw::c_void,
        value: u32,
        count: usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Maps an interop object into the HSA flat address space and establishes\n memory residency.  The metadata pointer is valid during the lifetime of the\n map (until hsa_amd_interop_unmap_buffer is called).\n Multiple calls to hsa_amd_interop_map_buffer with the same interop_handle\n result in multiple mappings with potentially different addresses and\n different metadata pointers.  Concurrent operations on these addresses are\n not coherent.  Memory must be fenced to system scope to ensure consistency,\n between mappings and with any views of this buffer in the originating\n software stack.\n\n @param[in] num_agents Number of agents which require access to the memory\n\n @param[in] agents List of accessing agents.\n\n @param[in] interop_handle Handle of interop buffer (dmabuf handle in Linux)\n\n @param [in] flags Reserved, must be 0\n\n @param[out] size Size in bytes of the mapped object\n\n @param[out] ptr Base address of the mapped object\n\n @param[out] metadata_size Size of metadata in bytes, may be NULL\n\n @param[out] metadata Pointer to metadata, may be NULL\n\n @retval HSA_STATUS_SUCCESS if successfully mapped\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT all other errors"]
    pub fn hsa_amd_interop_map_buffer(
        num_agents: u32,
        agents: *mut hsa_agent_t,
        interop_handle: ::std::os::raw::c_int,
        flags: u32,
        size: *mut usize,
        ptr: *mut *mut ::std::os::raw::c_void,
        metadata_size: *mut usize,
        metadata: *mut *const ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Removes a previously mapped interop object from HSA's flat address space.\n Ends lifetime for the mapping's associated metadata pointer."]
    pub fn hsa_amd_interop_unmap_buffer(ptr: *mut ::std::os::raw::c_void) -> hsa_status_t;
}
#[doc = " @brief Encodes an opaque vendor specific image format.  The length of data\n depends on the underlying format.  This structure must not be copied as its\n true length can not be determined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_image_descriptor_s {
    pub version: u32,
    pub deviceID: u32,
    pub data: [u32; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_image_descriptor_s"]
        [::std::mem::size_of::<hsa_amd_image_descriptor_s>() - 12usize];
    ["Alignment of hsa_amd_image_descriptor_s"]
        [::std::mem::align_of::<hsa_amd_image_descriptor_s>() - 4usize];
    ["Offset of field: hsa_amd_image_descriptor_s::version"]
        [::std::mem::offset_of!(hsa_amd_image_descriptor_s, version) - 0usize];
    ["Offset of field: hsa_amd_image_descriptor_s::deviceID"]
        [::std::mem::offset_of!(hsa_amd_image_descriptor_s, deviceID) - 4usize];
    ["Offset of field: hsa_amd_image_descriptor_s::data"]
        [::std::mem::offset_of!(hsa_amd_image_descriptor_s, data) - 8usize];
};
#[doc = " @brief Encodes an opaque vendor specific image format.  The length of data\n depends on the underlying format.  This structure must not be copied as its\n true length can not be determined."]
pub type hsa_amd_image_descriptor_t = hsa_amd_image_descriptor_s;
unsafe extern "C" {
    #[doc = " @brief Creates an image from an opaque vendor specific image format.\n Does not modify data at image_data.  Intended initially for\n accessing interop images.\n\n @param agent[in] Agent on which to create the image\n\n @param[in] image_descriptor[in] Vendor specific image format\n\n @param[in] image_data Pointer to image backing store\n\n @param[in] access_permission Access permissions for the image object\n\n @param[out] image Created image object.\n\n @retval HSA_STATUS_SUCCESS Image created successfully\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT Bad or mismatched descriptor,\n null image_data, or mismatched access_permission."]
    pub fn hsa_amd_image_create(
        agent: hsa_agent_t,
        image_descriptor: *const hsa_ext_image_descriptor_t,
        image_layout: *const hsa_amd_image_descriptor_t,
        image_data: *const ::std::os::raw::c_void,
        access_permission: hsa_access_permission_t,
        image: *mut hsa_ext_image_t,
    ) -> hsa_status_t;
}
pub const hsa_amd_pointer_type_t_HSA_EXT_POINTER_TYPE_UNKNOWN: hsa_amd_pointer_type_t = 0;
pub const hsa_amd_pointer_type_t_HSA_EXT_POINTER_TYPE_HSA: hsa_amd_pointer_type_t = 1;
pub const hsa_amd_pointer_type_t_HSA_EXT_POINTER_TYPE_LOCKED: hsa_amd_pointer_type_t = 2;
pub const hsa_amd_pointer_type_t_HSA_EXT_POINTER_TYPE_GRAPHICS: hsa_amd_pointer_type_t = 3;
pub const hsa_amd_pointer_type_t_HSA_EXT_POINTER_TYPE_IPC: hsa_amd_pointer_type_t = 4;
#[doc = " @brief Denotes the type of memory in a pointer info query."]
pub type hsa_amd_pointer_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Describes a memory allocation known to ROCr.\n Within a ROCr major version this structure can only grow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_pointer_info_s {
    pub size: u32,
    pub type_: hsa_amd_pointer_type_t,
    pub agentBaseAddress: *mut ::std::os::raw::c_void,
    pub hostBaseAddress: *mut ::std::os::raw::c_void,
    pub sizeInBytes: usize,
    pub userData: *mut ::std::os::raw::c_void,
    pub agentOwner: hsa_agent_t,
    pub global_flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_pointer_info_s"][::std::mem::size_of::<hsa_amd_pointer_info_s>() - 56usize];
    ["Alignment of hsa_amd_pointer_info_s"]
        [::std::mem::align_of::<hsa_amd_pointer_info_s>() - 8usize];
    ["Offset of field: hsa_amd_pointer_info_s::size"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, size) - 0usize];
    ["Offset of field: hsa_amd_pointer_info_s::type_"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, type_) - 4usize];
    ["Offset of field: hsa_amd_pointer_info_s::agentBaseAddress"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, agentBaseAddress) - 8usize];
    ["Offset of field: hsa_amd_pointer_info_s::hostBaseAddress"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, hostBaseAddress) - 16usize];
    ["Offset of field: hsa_amd_pointer_info_s::sizeInBytes"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, sizeInBytes) - 24usize];
    ["Offset of field: hsa_amd_pointer_info_s::userData"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, userData) - 32usize];
    ["Offset of field: hsa_amd_pointer_info_s::agentOwner"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, agentOwner) - 40usize];
    ["Offset of field: hsa_amd_pointer_info_s::global_flags"]
        [::std::mem::offset_of!(hsa_amd_pointer_info_s, global_flags) - 48usize];
};
#[doc = " @brief Describes a memory allocation known to ROCr.\n Within a ROCr major version this structure can only grow."]
pub type hsa_amd_pointer_info_t = hsa_amd_pointer_info_s;
unsafe extern "C" {
    #[doc = " @brief Retrieves information about the allocation referenced by the given\n pointer.  Optionally returns the number and list of agents which can\n directly access the allocation. In case this virtual address is unknown, the\n pointer type returned will be HSA_EXT_POINTER_TYPE_UNKNOWN and the only fields\n that are valid after hsa_amd_pointer_info returns are size and type.\n\n @param[in] ptr Pointer which references the allocation to retrieve info for.\n\n @param[in, out] info Pointer to structure to be filled with allocation info.\n Data member size must be set to the size of the structure prior to calling\n hsa_amd_pointer_info.  On return size will be set to the size of the\n pointer info structure supported by the runtime, if smaller.  Members\n beyond the returned value of size will not be updated by the API.\n Must not be NULL.\n\n @param[in] alloc Function pointer to an allocator used to allocate the\n @p accessible array.  If NULL @p accessible will not be returned.\n\n @param[out] num_agents_accessible Recieves the count of agents in\n @p accessible.  If NULL @p accessible will not be returned.\n\n @param[out] accessible Recieves a pointer to the array, allocated by @p alloc,\n holding the list of agents which may directly access the allocation.\n May be NULL.\n\n @retval HSA_STATUS_SUCCESS Info retrieved successfully\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT NULL in @p ptr or @p info."]
    pub fn hsa_amd_pointer_info(
        ptr: *const ::std::os::raw::c_void,
        info: *mut hsa_amd_pointer_info_t,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        num_agents_accessible: *mut u32,
        accessible: *mut *mut hsa_agent_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Associates an arbitrary pointer with an allocation known to ROCr.\n The pointer can be fetched by hsa_amd_pointer_info in the userData field.\n\n @param[in] ptr Pointer to the first byte of an allocation known to ROCr\n with which to associate @p userdata.\n\n @param[in] userdata Abitrary pointer to associate with the allocation.\n\n @retval HSA_STATUS_SUCCESS @p userdata successfully stored.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is not known to ROCr."]
    pub fn hsa_amd_pointer_info_set_userdata(
        ptr: *const ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
#[doc = " @brief 256-bit process independent identifier for a ROCr shared memory\n allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_ipc_memory_s {
    pub handle: [u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_ipc_memory_s"][::std::mem::size_of::<hsa_amd_ipc_memory_s>() - 32usize];
    ["Alignment of hsa_amd_ipc_memory_s"][::std::mem::align_of::<hsa_amd_ipc_memory_s>() - 4usize];
    ["Offset of field: hsa_amd_ipc_memory_s::handle"]
        [::std::mem::offset_of!(hsa_amd_ipc_memory_s, handle) - 0usize];
};
#[doc = " @brief 256-bit process independent identifier for a ROCr shared memory\n allocation."]
pub type hsa_amd_ipc_memory_t = hsa_amd_ipc_memory_s;
unsafe extern "C" {
    #[doc = " @brief Prepares an allocation for interprocess sharing and creates a\n handle of type hsa_amd_ipc_memory_t uniquely identifying the allocation.  A\n handle is valid while the allocation it references remains accessible in\n any process.  In general applications should confirm that a shared memory\n region has been attached (via hsa_amd_ipc_memory_attach) in the remote\n process prior to releasing that memory in the local process.\n Repeated calls for the same allocation may, but are not required to, return\n unique handles. The allocation needs to be on memory on an agent of type\n HSA_DEVICE_TYPE_GPU.\n\n @param[in] ptr Pointer to device memory allocated via ROCr APIs to prepare for\n sharing.\n\n @param[in] len Length in bytes of the allocation to share.\n\n @param[out] handle Process independent identifier referencing the shared\n allocation.\n\n @retval HSA_STATUS_SUCCESS allocation is prepared for interprocess sharing.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr does not point to the\n first byte of an allocation made through ROCr, or len is not the full length\n of the allocation or handle is NULL."]
    pub fn hsa_amd_ipc_memory_create(
        ptr: *mut ::std::os::raw::c_void,
        len: usize,
        handle: *mut hsa_amd_ipc_memory_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Imports shared memory into the local process and makes it accessible\n by the given agents.  If a shared memory handle is attached multiple times\n in a process each attach may return a different address.  Each returned\n address is refcounted and requires a matching number of calls to\n hsa_amd_ipc_memory_detach to release the shared memory mapping.\n\n @param[in] handle Pointer to the identifier for the shared memory.\n\n @param[in] len Length of the shared memory to import.\n Reserved.  Must be the full length of the shared allocation in this version.\n\n @param[in] num_agents Count of agents in @p mapping_agents.\n May be zero if all agents are to be allowed access.\n\n @param[in] mapping_agents List of agents to access the shared memory.\n Ignored if @p num_agents is zero.\n\n @param[out] mapped_ptr Recieves a process local pointer to the shared memory.\n\n @retval HSA_STATUS_SUCCESS if memory is successfully imported.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p handle is not valid, @p len is\n incorrect, @p mapped_ptr is NULL, or some agent for which access was\n requested can not access the shared memory."]
    pub fn hsa_amd_ipc_memory_attach(
        handle: *const hsa_amd_ipc_memory_t,
        len: usize,
        num_agents: u32,
        mapping_agents: *const hsa_agent_t,
        mapped_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Decrements the reference count for the shared memory mapping and\n releases access to shared memory imported with hsa_amd_ipc_memory_attach.\n\n @param[in] mapped_ptr Pointer to the first byte of a shared allocation\n imported with hsa_amd_ipc_memory_attach.\n\n @retval HSA_STATUS_SUCCESS if @p mapped_ptr was imported with\n hsa_amd_ipc_memory_attach.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p mapped_ptr was not imported\n with hsa_amd_ipc_memory_attach."]
    pub fn hsa_amd_ipc_memory_detach(mapped_ptr: *mut ::std::os::raw::c_void) -> hsa_status_t;
}
#[doc = " @brief 256-bit process independent identifier for a ROCr IPC signal."]
pub type hsa_amd_ipc_signal_t = hsa_amd_ipc_memory_t;
unsafe extern "C" {
    #[doc = " @brief Obtains an interprocess sharing handle for a signal.  The handle is\n valid while the signal it references remains valid in any process.  In\n general applications should confirm that the signal has been attached (via\n hsa_amd_ipc_signal_attach) in the remote process prior to destroying that\n signal in the local process.\n Repeated calls for the same signal may, but are not required to, return\n unique handles.\n\n @param[in] signal Signal created with attribute HSA_AMD_SIGNAL_IPC.\n\n @param[out] handle Process independent identifier referencing the shared\n signal.\n\n @retval HSA_STATUS_SUCCESS @p handle is ready to use for interprocess sharing.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p signal is not a valid signal\n created with attribute HSA_AMD_SIGNAL_IPC or handle is NULL."]
    pub fn hsa_amd_ipc_signal_create(
        signal: hsa_signal_t,
        handle: *mut hsa_amd_ipc_signal_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Imports an IPC capable signal into the local process.  If an IPC\n signal handle is attached multiple times in a process each attach may return\n a different signal handle.  Each returned signal handle is refcounted and\n requires a matching number of calls to hsa_signal_destroy to release the\n shared signal.\n\n @param[in] handle Pointer to the identifier for the shared signal.\n\n @param[out] signal Recieves a process local signal handle to the shared signal.\n\n @retval HSA_STATUS_SUCCESS if the signal is successfully imported.\n\n @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n\n @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p handle is not valid."]
    pub fn hsa_amd_ipc_signal_attach(
        handle: *const hsa_amd_ipc_signal_t,
        signal: *mut hsa_signal_t,
    ) -> hsa_status_t;
}
pub const hsa_amd_event_type_s_HSA_AMD_GPU_MEMORY_FAULT_EVENT: hsa_amd_event_type_s = 0;
pub const hsa_amd_event_type_s_HSA_AMD_GPU_HW_EXCEPTION_EVENT: hsa_amd_event_type_s = 1;
#[doc = " @brief GPU system event type."]
pub type hsa_amd_event_type_s = ::std::os::raw::c_uint;
#[doc = " @brief GPU system event type."]
pub use self::hsa_amd_event_type_s as hsa_amd_event_type_t;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_PAGE_NOT_PRESENT:
    hsa_amd_memory_fault_reason_t = 1;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_READ_ONLY:
    hsa_amd_memory_fault_reason_t = 2;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_NX: hsa_amd_memory_fault_reason_t = 4;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_HOST_ONLY:
    hsa_amd_memory_fault_reason_t = 8;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_DRAMECC:
    hsa_amd_memory_fault_reason_t = 16;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_IMPRECISE:
    hsa_amd_memory_fault_reason_t = 32;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_SRAMECC:
    hsa_amd_memory_fault_reason_t = 64;
pub const hsa_amd_memory_fault_reason_t_HSA_AMD_MEMORY_FAULT_HANG: hsa_amd_memory_fault_reason_t =
    2147483648;
#[doc = " @brief Flags denoting the cause of a memory fault."]
pub type hsa_amd_memory_fault_reason_t = ::std::os::raw::c_uint;
#[doc = " @brief AMD GPU memory fault event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_gpu_memory_fault_info_s {
    pub agent: hsa_agent_t,
    pub virtual_address: u64,
    pub fault_reason_mask: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_gpu_memory_fault_info_s"]
        [::std::mem::size_of::<hsa_amd_gpu_memory_fault_info_s>() - 24usize];
    ["Alignment of hsa_amd_gpu_memory_fault_info_s"]
        [::std::mem::align_of::<hsa_amd_gpu_memory_fault_info_s>() - 8usize];
    ["Offset of field: hsa_amd_gpu_memory_fault_info_s::agent"]
        [::std::mem::offset_of!(hsa_amd_gpu_memory_fault_info_s, agent) - 0usize];
    ["Offset of field: hsa_amd_gpu_memory_fault_info_s::virtual_address"]
        [::std::mem::offset_of!(hsa_amd_gpu_memory_fault_info_s, virtual_address) - 8usize];
    ["Offset of field: hsa_amd_gpu_memory_fault_info_s::fault_reason_mask"]
        [::std::mem::offset_of!(hsa_amd_gpu_memory_fault_info_s, fault_reason_mask) - 16usize];
};
#[doc = " @brief AMD GPU memory fault event data."]
pub type hsa_amd_gpu_memory_fault_info_t = hsa_amd_gpu_memory_fault_info_s;
pub const hsa_amd_hw_exception_reset_type_t_HSA_AMD_HW_EXCEPTION_RESET_TYPE_OTHER:
    hsa_amd_hw_exception_reset_type_t = 1;
#[doc = " @brief Flags denoting the type of a HW exception"]
pub type hsa_amd_hw_exception_reset_type_t = ::std::os::raw::c_uint;
pub const hsa_amd_hw_exception_reset_cause_t_HSA_AMD_HW_EXCEPTION_CAUSE_GPU_HANG:
    hsa_amd_hw_exception_reset_cause_t = 1;
pub const hsa_amd_hw_exception_reset_cause_t_HSA_AMD_HW_EXCEPTION_CAUSE_ECC:
    hsa_amd_hw_exception_reset_cause_t = 2;
#[doc = " @brief Flags denoting the cause of a HW exception"]
pub type hsa_amd_hw_exception_reset_cause_t = ::std::os::raw::c_uint;
#[doc = " @brief AMD GPU HW Exception event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_gpu_hw_exception_info_s {
    pub agent: hsa_agent_t,
    pub reset_type: hsa_amd_hw_exception_reset_type_t,
    pub reset_cause: hsa_amd_hw_exception_reset_cause_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_gpu_hw_exception_info_s"]
        [::std::mem::size_of::<hsa_amd_gpu_hw_exception_info_s>() - 16usize];
    ["Alignment of hsa_amd_gpu_hw_exception_info_s"]
        [::std::mem::align_of::<hsa_amd_gpu_hw_exception_info_s>() - 8usize];
    ["Offset of field: hsa_amd_gpu_hw_exception_info_s::agent"]
        [::std::mem::offset_of!(hsa_amd_gpu_hw_exception_info_s, agent) - 0usize];
    ["Offset of field: hsa_amd_gpu_hw_exception_info_s::reset_type"]
        [::std::mem::offset_of!(hsa_amd_gpu_hw_exception_info_s, reset_type) - 8usize];
    ["Offset of field: hsa_amd_gpu_hw_exception_info_s::reset_cause"]
        [::std::mem::offset_of!(hsa_amd_gpu_hw_exception_info_s, reset_cause) - 12usize];
};
#[doc = " @brief AMD GPU HW Exception event data."]
pub type hsa_amd_gpu_hw_exception_info_t = hsa_amd_gpu_hw_exception_info_s;
#[doc = " @brief AMD GPU event data passed to event handler."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hsa_amd_event_s {
    pub event_type: hsa_amd_event_type_t,
    pub __bindgen_anon_1: hsa_amd_event_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hsa_amd_event_s__bindgen_ty_1 {
    pub memory_fault: hsa_amd_gpu_memory_fault_info_t,
    pub hw_exception: hsa_amd_gpu_hw_exception_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_event_s__bindgen_ty_1"]
        [::std::mem::size_of::<hsa_amd_event_s__bindgen_ty_1>() - 24usize];
    ["Alignment of hsa_amd_event_s__bindgen_ty_1"]
        [::std::mem::align_of::<hsa_amd_event_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: hsa_amd_event_s__bindgen_ty_1::memory_fault"]
        [::std::mem::offset_of!(hsa_amd_event_s__bindgen_ty_1, memory_fault) - 0usize];
    ["Offset of field: hsa_amd_event_s__bindgen_ty_1::hw_exception"]
        [::std::mem::offset_of!(hsa_amd_event_s__bindgen_ty_1, hw_exception) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_event_s"][::std::mem::size_of::<hsa_amd_event_s>() - 32usize];
    ["Alignment of hsa_amd_event_s"][::std::mem::align_of::<hsa_amd_event_s>() - 8usize];
    ["Offset of field: hsa_amd_event_s::event_type"]
        [::std::mem::offset_of!(hsa_amd_event_s, event_type) - 0usize];
};
#[doc = " @brief AMD GPU event data passed to event handler."]
pub type hsa_amd_event_t = hsa_amd_event_s;
pub type hsa_amd_system_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event: *const hsa_amd_event_t,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t,
>;
unsafe extern "C" {
    #[doc = " @brief Register AMD GPU event handler.\n\n @param[in] callback Callback to be invoked when an event is triggered.\n The HSA runtime passes two arguments to the callback: @p event\n is defined per event by the HSA runtime, and @p data is the user data.\n\n @param[in] data User data that is passed to @p callback. May be NULL.\n\n @retval HSA_STATUS_SUCCESS The handler has been registered successfully.\n\n @retval HSA_STATUS_ERROR An event handler has already been registered.\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p event is invalid."]
    pub fn hsa_amd_register_system_event_handler(
        callback: hsa_amd_system_event_callback_t,
        data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
pub const hsa_amd_queue_priority_s_HSA_AMD_QUEUE_PRIORITY_LOW: hsa_amd_queue_priority_s = 0;
pub const hsa_amd_queue_priority_s_HSA_AMD_QUEUE_PRIORITY_NORMAL: hsa_amd_queue_priority_s = 1;
pub const hsa_amd_queue_priority_s_HSA_AMD_QUEUE_PRIORITY_HIGH: hsa_amd_queue_priority_s = 2;
#[doc = " @brief Per-queue dispatch and wavefront scheduling priority."]
pub type hsa_amd_queue_priority_s = ::std::os::raw::c_uint;
#[doc = " @brief Per-queue dispatch and wavefront scheduling priority."]
pub use self::hsa_amd_queue_priority_s as hsa_amd_queue_priority_t;
unsafe extern "C" {
    #[doc = " @brief Modifies the dispatch and wavefront scheduling prioirty for a\n given compute queue. The default is HSA_AMD_QUEUE_PRIORITY_NORMAL.\n\n @param[in] queue Compute queue to apply new priority to.\n\n @param[in] priority Priority to associate with queue.\n\n @retval HSA_STATUS_SUCCESS if priority was changed successfully.\n\n @retval HSA_STATUS_ERROR_INVALID_QUEUE if queue is not a valid\n compute queue handle.\n\n @retval HSA_STATUS_ERROR_INVALID_ARGUMENT if priority is not a valid\n value from hsa_amd_queue_priority_t."]
    pub fn hsa_amd_queue_set_priority(
        queue: *mut hsa_queue_t,
        priority: hsa_amd_queue_priority_t,
    ) -> hsa_status_t;
}
#[doc = " @brief Deallocation notifier function type."]
pub type hsa_amd_deallocation_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, user_data: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " @brief Registers a deallocation notifier monitoring for release of agent\n accessible address @p ptr.  If successful, @p callback will be invoked when\n @p ptr is removed from accessibility from all agents.\n\n Notification callbacks are automatically deregistered when they are invoked.\n\n Note: The current version supports notifications of address release\n originating from ::hsa_amd_memory_pool_free.  Support for other address\n release APIs will follow.\n\n @param[in] ptr Agent accessible address to monitor for deallocation.  Passed\n to @p callback.\n\n @param[in] callback Notifier to be invoked when @p ptr is released from\n agent accessibility.\n\n @param[in] user_data User provided value passed to @p callback.  May be NULL.\n\n @retval ::HSA_STATUS_SUCCESS The notifier registered successfully\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION @p ptr does not refer to a valid agent accessible\n address.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL or @p ptr is NULL.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n necessary resources"]
    pub fn hsa_amd_register_deallocation_callback(
        ptr: *mut ::std::os::raw::c_void,
        callback: hsa_amd_deallocation_callback_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Removes a deallocation notifier previously registered with\n ::hsa_amd_register_deallocation_callback.  Arguments must be identical to\n those given in ::hsa_amd_register_deallocation_callback.\n\n @param[in] ptr Agent accessible address which was monitored for deallocation.\n\n @param[in] callback Notifier to be removed.\n\n @retval ::HSA_STATUS_SUCCESS The notifier has been removed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The given notifier was not registered."]
    pub fn hsa_amd_deregister_deallocation_callback(
        ptr: *mut ::std::os::raw::c_void,
        callback: hsa_amd_deallocation_callback_t,
    ) -> hsa_status_t;
}
#[doc = " Updates to memory with this attribute conform to HSA memory consistency\n model."]
pub const hsa_amd_svm_model_s_HSA_AMD_SVM_GLOBAL_FLAG_FINE_GRAINED: hsa_amd_svm_model_s = 0;
#[doc = " Writes to memory with this attribute can be performed by a single agent\n at a time."]
pub const hsa_amd_svm_model_s_HSA_AMD_SVM_GLOBAL_FLAG_COARSE_GRAINED: hsa_amd_svm_model_s = 1;
#[doc = " Memory region queried contains subregions with both\n HSA_AMD_SVM_GLOBAL_FLAG_COARSE_GRAINED and\n HSA_AMD_SVM_GLOBAL_FLAG_FINE_GRAINED attributes.\n\n This attribute can not be used in hsa_amd_svm_attributes_set.  It is a\n possible return from hsa_amd_svm_attributes_get indicating that the query\n region contains both coarse and fine grained memory."]
pub const hsa_amd_svm_model_s_HSA_AMD_SVM_GLOBAL_FLAG_INDETERMINATE: hsa_amd_svm_model_s = 2;
pub type hsa_amd_svm_model_s = ::std::os::raw::c_uint;
pub use self::hsa_amd_svm_model_s as hsa_amd_svm_model_t;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_GLOBAL_FLAG: hsa_amd_svm_attribute_s = 0;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_READ_ONLY: hsa_amd_svm_attribute_s = 1;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_HIVE_LOCAL: hsa_amd_svm_attribute_s = 2;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_MIGRATION_GRANULARITY:
    hsa_amd_svm_attribute_s = 3;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_PREFERRED_LOCATION: hsa_amd_svm_attribute_s =
    4;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_PREFETCH_LOCATION: hsa_amd_svm_attribute_s = 5;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_READ_MOSTLY: hsa_amd_svm_attribute_s = 6;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_GPU_EXEC: hsa_amd_svm_attribute_s = 7;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE: hsa_amd_svm_attribute_s =
    512;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE_IN_PLACE:
    hsa_amd_svm_attribute_s = 513;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_AGENT_NO_ACCESS: hsa_amd_svm_attribute_s = 514;
pub const hsa_amd_svm_attribute_s_HSA_AMD_SVM_ATTRIB_ACCESS_QUERY: hsa_amd_svm_attribute_s = 515;
pub type hsa_amd_svm_attribute_s = ::std::os::raw::c_uint;
pub use self::hsa_amd_svm_attribute_s as hsa_amd_svm_attribute_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_svm_attribute_pair_s {
    pub attribute: u64,
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_svm_attribute_pair_s"]
        [::std::mem::size_of::<hsa_amd_svm_attribute_pair_s>() - 16usize];
    ["Alignment of hsa_amd_svm_attribute_pair_s"]
        [::std::mem::align_of::<hsa_amd_svm_attribute_pair_s>() - 8usize];
    ["Offset of field: hsa_amd_svm_attribute_pair_s::attribute"]
        [::std::mem::offset_of!(hsa_amd_svm_attribute_pair_s, attribute) - 0usize];
    ["Offset of field: hsa_amd_svm_attribute_pair_s::value"]
        [::std::mem::offset_of!(hsa_amd_svm_attribute_pair_s, value) - 8usize];
};
pub type hsa_amd_svm_attribute_pair_t = hsa_amd_svm_attribute_pair_s;
unsafe extern "C" {
    #[doc = " @brief Sets SVM memory attributes.\n\n If HSA_AMD_SYSTEM_INFO_SVM_ACCESSIBLE_BY_DEFAULT returns false then enabling\n access to an Agent via this API (setting HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE\n or HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE_IN_PLACE) is required prior to SVM\n memory access by that Agent.\n\n Attributes HSA_AMD_SVM_ATTRIB_ACCESS_QUERY and HSA_AMD_SVM_ATTRIB_PREFETCH_LOCATION\n may not be used with this API.\n\n @param[in] ptr Will be aligned down to nearest page boundary.\n\n @param[in] size Will be aligned up to nearest page boundary.\n\n @param[in] attribute_list List of attributes to set for the address range.\n\n @param[in] attribute_count Length of @p attribute_list."]
    pub fn hsa_amd_svm_attributes_set(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        attribute_list: *mut hsa_amd_svm_attribute_pair_t,
        attribute_count: usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets SVM memory attributes.\n\n Attributes HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE,\n HSA_AMD_SVM_ATTRIB_AGENT_ACCESSIBLE_IN_PLACE and\n HSA_AMD_SVM_ATTRIB_PREFETCH_LOCATION may not be used with this API.\n\n Note that attribute HSA_AMD_SVM_ATTRIB_ACCESS_QUERY takes as input an\n hsa_agent_t and returns the current access type through its attribute field.\n\n @param[in] ptr Will be aligned down to nearest page boundary.\n\n @param[in] size Will be aligned up to nearest page boundary.\n\n @param[in] attribute_list List of attributes to set for the address range.\n\n @param[in] attribute_count Length of @p attribute_list."]
    pub fn hsa_amd_svm_attributes_get(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        attribute_list: *mut hsa_amd_svm_attribute_pair_t,
        attribute_count: usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Asynchronously migrates memory to an agent.\n\n Schedules memory migration to @p agent when @p dep_signals have been observed equal to zero.\n @p completion_signal will decrement when the migration is complete.\n\n @param[in] ptr Will be aligned down to nearest page boundary.\n\n @param[in] size Will be aligned up to nearest page boundary.\n\n @param[in] agent Agent to migrate to.\n\n @param[in] num_dep_signals Number of dependent signals. Can be 0.\n\n @param[in] dep_signals List of signals that must be waited on before the migration\n operation starts. The migration will start after every signal has been observed with\n the value 0. If @p num_dep_signals is 0, this argument is ignored.\n\n @param[in] completion_signal Signal used to indicate completion of the migration\n operation. When the migration operation is finished, the value of the signal is\n decremented. The runtime indicates that an error has occurred during the copy\n operation by setting the value of the completion signal to a negative\n number. If no completion signal is required this handle may be null."]
    pub fn hsa_amd_svm_prefetch_async(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        agent: hsa_agent_t,
        num_dep_signals: u32,
        dep_signals: *const hsa_signal_t,
        completion_signal: hsa_signal_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Acquire Stream Performance Monitor on an agent\n\n Acquire exclusive use of SPM on @p preferred_agent.\n See hsa_amd_spm_set_dest_buffer to provide a destination buffer to KFD to start recording and\n retrieve this data.\n @param[in] preferred_agent Agent on which to acquire SPM"]
    pub fn hsa_amd_spm_acquire(preferred_agent: hsa_agent_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Release Stream Performance Monitor on an agent\n\n Release exclusive use of SPM on @p preferred_agent. This will stop KFD writing SPM data.\n If a destination buffer is set, then data in the destination buffer is available to user\n when this function returns.\n\n @param[in] preferred_agent Agent on which to release SPM"]
    pub fn hsa_amd_spm_release(preferred_agent: hsa_agent_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief  Set up the current destination user mode buffer for stream performance\n counter data. KFD will start writing SPM data into the destination buffer. KFD will continue\n to copy data into the current destination buffer until any of the following functions are called\n - hsa_amd_spm_release\n - hsa_amd_spm_set_dest_buffer with dest set to NULL\n - hsa_amd_spm_set_dest_buffer with dest set to a new buffer\n\n if @p timeout is non-0, the call will wait for up to @p timeout ms for the previous\n buffer to be filled. If previous buffer to be filled before timeout, the @p timeout\n will be updated value with the time remaining. If the timeout is exceeded, the function\n copies any partial data available into the previous user buffer and returns success.\n User should not access destination data while KFD is copying data.\n If the previous destination buffer was full, then @p is_data_loss flag is set.\n @p dest is CPU accessible memory. It could be malloc'ed memory or host allocated memory\n\n @param[in] preferred_agent Agent on which to set the dest buffer\n\n @param[in] size_in_bytes size of the buffer\n\n @param[in/out] timeout timeout in milliseconds\n\n @param[out] size_copied number of bytes copied\n\n @param[in] dest destination address. Set to NULL to stop copy on previous buffer\n\n @param[out] is_data_loss true is data was lost"]
    pub fn hsa_amd_spm_set_dest_buffer(
        preferred_agent: hsa_agent_t,
        size_in_bytes: usize,
        timeout: *mut u32,
        size_copied: *mut u32,
        dest: *mut ::std::os::raw::c_void,
        is_data_loss: *mut bool,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Obtains an OS specific, vendor neutral, handle to a memory allocation.\n\n Obtains an OS specific handle to GPU agent memory.  The memory must be part\n of a single allocation from an hsa_amd_memory_pool_t exposed by a GPU Agent.\n The handle may be used with other APIs (e.g. Vulkan) to obtain shared access\n to the allocation.\n\n Shared access to the memory is not guaranteed to be fine grain coherent even\n if the allocation exported is from a fine grain pool.  The shared memory\n consistency model will be no stronger than the model exported from, consult\n the importing API to determine the final consistency model.\n\n The allocation's memory remains valid as long as the handle and any mapping\n of the handle remains valid.  When the handle and all mappings are closed\n the backing memory will be released for reuse.\n\n @param[in] ptr Pointer to the allocation being exported.\n\n @param[in] size Size in bytes to export following @p ptr.  The entire range\n being exported must be contained within a single allocation.\n\n @param[out] dmabuf Pointer to a dma-buf file descriptor holding a reference to the\n allocation.  Contents will not be altered in the event of failure.\n\n @param[out] offset Offset in bytes into the memory referenced by the dma-buf\n object at which @p ptr resides.  Contents will not be altered in the event\n of failure.\n\n @retval ::HSA_STATUS_SUCCESS Export completed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT One or more arguments is NULL.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION The address range described by\n @p ptr and @p size are not contained within a single allocation.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The allocation described by @p ptr\n and @p size was allocated on a device which can not export memory.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The return file descriptor,\n @p dmabuf, could not be created."]
    pub fn hsa_amd_portable_export_dmabuf(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        dmabuf: *mut ::std::os::raw::c_int,
        offset: *mut u64,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Closes an OS specific, vendor neutral, handle to a memory allocation.\n\n Closes an OS specific handle to GPU agent memory.\n\n Applications should close a handle after imports are complete.  The handle\n is not required to remain open for the lifetime of imported mappings.  The\n referenced allocation will remain valid until all handles and mappings\n are closed.\n\n @param[in] dmabuf Handle to be closed.\n\n @retval ::HSA_STATUS_SUCCESS Handle closed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_RESOURCE_FREE A generic error was encountered\n when closing the handle.  The handle may have been closed already or an\n async IO error may have occured."]
    pub fn hsa_amd_portable_close_dmabuf(dmabuf: ::std::os::raw::c_int) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a reserved address range\n\n Reserve a virtual address range. The size must be a multiple of the system page size.\n If it is not possible to allocate the address specified by @p address, then @p va will be\n a different address range.\n Address range should be released by calling hsa_amd_vmem_address_free.\n\n @param[out] va virtual address allocated\n @param[in] size of address range requested\n @param[in] address requested\n @param[in] flags currently unsupported\n\n @retval ::HSA_STATUS_SUCCESS Address range allocated successfully\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Insufficient resources to allocate an address\n range of this size.\n\n Note that this API will be deprecated in a future release and replaced by\n hsa_amd_vmem_address_reserve_align"]
    pub fn hsa_amd_vmem_address_reserve(
        va: *mut *mut ::std::os::raw::c_void,
        size: usize,
        address: u64,
        flags: u64,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a reserved address range\n\n Reserve a virtual address range. The size must be a multiple of the system page size.\n If it is not possible to allocate the address specified by @p address, then @p va will be\n a different address range.\n Address range should be released by calling hsa_amd_vmem_address_free.\n\n @param[out] va virtual address allocated\n @param[in] size of address range requested\n @param[in] address requested\n @param[in] alignment requested. 0 for default. Must be >= page-size and a power of 2\n @param[in] flags currently unsupported\n\n @retval ::HSA_STATUS_SUCCESS Address range allocated successfully\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Insufficient resources to allocate an address\n range of this size."]
    pub fn hsa_amd_vmem_address_reserve_align(
        va: *mut *mut ::std::os::raw::c_void,
        size: usize,
        address: u64,
        alignment: u64,
        flags: u64,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Free a reserved address range\n\n Free a previously allocated address range. The size must match the size of a previously\n allocated address range.\n\n @param[out] va virtual address to be freed\n @param[in] size of address range\n\n @retval ::HSA_STATUS_SUCCESS Address range released successfully\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid va specified\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid size specified\n @retval ::HSA_STATUS_ERROR_RESOURCE_FREE Address range is still in use\n @retval ::HSA_STATUS_ERROR Internal unexpected error"]
    pub fn hsa_amd_vmem_address_free(va: *mut ::std::os::raw::c_void, size: usize) -> hsa_status_t;
}
#[doc = " @brief Struct containing an opaque handle to a memory allocation handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_vmem_alloc_handle_s {
    #[doc = " Opaque handle. Two handles reference the same object of the enclosing type\n if and only if they are equal."]
    pub handle: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_vmem_alloc_handle_s"]
        [::std::mem::size_of::<hsa_amd_vmem_alloc_handle_s>() - 8usize];
    ["Alignment of hsa_amd_vmem_alloc_handle_s"]
        [::std::mem::align_of::<hsa_amd_vmem_alloc_handle_s>() - 8usize];
    ["Offset of field: hsa_amd_vmem_alloc_handle_s::handle"]
        [::std::mem::offset_of!(hsa_amd_vmem_alloc_handle_s, handle) - 0usize];
};
#[doc = " @brief Struct containing an opaque handle to a memory allocation handle"]
pub type hsa_amd_vmem_alloc_handle_t = hsa_amd_vmem_alloc_handle_s;
pub const hsa_amd_memory_type_t_MEMORY_TYPE_NONE: hsa_amd_memory_type_t = 0;
pub const hsa_amd_memory_type_t_MEMORY_TYPE_PINNED: hsa_amd_memory_type_t = 1;
pub type hsa_amd_memory_type_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Create a virtual memory handle\n\n Create a virtual memory handle within this pool\n @p size must be a aligned to allocation granule size for this memory pool, see\n HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_GRANULE\n To minimize internal memory fragmentation, align the size to the recommended allocation granule\n size, see HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_REC_GRANULE\n\n @param[in] pool memory to use\n @param[in] size of the memory allocation\n @param[in] type of memory\n @param[in] flags - currently unsupported\n @param[out] memory_handle - handle for the allocation\n\n @retval ::HSA_STATUS_SUCCESS memory allocated successfully\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT Invalid arguments\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION This memory pool does not support allocations\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Insufficient resources to allocate this memory"]
    pub fn hsa_amd_vmem_handle_create(
        pool: hsa_amd_memory_pool_t,
        size: usize,
        type_: hsa_amd_memory_type_t,
        flags: u64,
        memory_handle: *mut hsa_amd_vmem_alloc_handle_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Release a virtual memory handle\n\n @param[in] memory handle that was previously allocated\n\n @retval ::HSA_STATUS_SUCCESS Address range allocated successfully\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid memory handle"]
    pub fn hsa_amd_vmem_handle_release(memory_handle: hsa_amd_vmem_alloc_handle_t) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Map a virtual memory handle\n\n Map a virtual memory handle to a reserved address range. The virtual address requested must be\n within a previously reserved address range. @p va and (@p va + size) must be must be within\n (va + size) of the previous allocated address range.\n @p size must be equal to size of the @p memory_handle\n hsa_amd_vmem_set_access needs to be called to make the memory accessible to specific agents\n\n @param[in] va virtual address range where memory will be mapped\n @param[in] size of memory mapping\n @param[in] in_offset offset into memory. Currently unsupported\n @param[in] memory_handle virtual memory handle to be mapped\n @param[in] flags. Currently unsupported\n\n @retval ::HSA_STATUS_SUCCESS Memory mapped successfully\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT va, size or memory_handle are invalid\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Insufficient resources\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_map(
        va: *mut ::std::os::raw::c_void,
        size: usize,
        in_offset: usize,
        memory_handle: hsa_amd_vmem_alloc_handle_t,
        flags: u64,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Unmap a virtual memory handle\n\n Unmap previously mapped virtual address range\n\n @param[in] va virtual address range where memory will be mapped\n @param[in] size of memory mapping\n\n @retval ::HSA_STATUS_SUCCESS Memory backing unmapped successfully\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION memory_handle is invalid\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT size is invalid\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_unmap(va: *mut ::std::os::raw::c_void, size: usize) -> hsa_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hsa_amd_memory_access_desc_s {
    pub permissions: hsa_access_permission_t,
    pub agent_handle: hsa_agent_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hsa_amd_memory_access_desc_s"]
        [::std::mem::size_of::<hsa_amd_memory_access_desc_s>() - 16usize];
    ["Alignment of hsa_amd_memory_access_desc_s"]
        [::std::mem::align_of::<hsa_amd_memory_access_desc_s>() - 8usize];
    ["Offset of field: hsa_amd_memory_access_desc_s::permissions"]
        [::std::mem::offset_of!(hsa_amd_memory_access_desc_s, permissions) - 0usize];
    ["Offset of field: hsa_amd_memory_access_desc_s::agent_handle"]
        [::std::mem::offset_of!(hsa_amd_memory_access_desc_s, agent_handle) - 8usize];
};
pub type hsa_amd_memory_access_desc_t = hsa_amd_memory_access_desc_s;
unsafe extern "C" {
    #[doc = " @brief Make a memory mapping accessible\n\n Make previously mapped virtual address accessible to specific agents. @p size must be equal to\n size of previously mapped virtual memory handle.\n Calling hsa_amd_vmem_set_access multiple times on the same @p va will overwrite previous\n permissions for all agents\n\n @param[in] va previously mapped virtual address\n @param[in] size of memory mapping\n @param[in] desc list of access permissions for each agent\n @param[in] desc_cnt number of elements in desc\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT va, size or memory_handle are invalid\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION memory_handle is invalid\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Insufficient resources\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT Invalid agent in desc\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_set_access(
        va: *mut ::std::os::raw::c_void,
        size: usize,
        desc: *const hsa_amd_memory_access_desc_t,
        desc_cnt: usize,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Get current access permissions for memory mapping\n\n Get access permissions for memory mapping for specific agent.\n\n @param[in] va previously mapped virtual address\n @param[in] perms current permissions\n @param[in] agent_handle agent\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT Invalid agent\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION va is not mapped or permissions never set for this\n agent\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_get_access(
        va: *mut ::std::os::raw::c_void,
        perms: *mut hsa_access_permission_t,
        agent_handle: hsa_agent_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Get an exportable shareable handle\n\n Get an exportable shareable handle for a memory_handle. This shareabl handle can then be used to\n re-create a virtual memory handle using hsa_amd_vmem_import_shareable_handle. The shareable\n handle can be transferred using mechanisms that support posix file descriptors Once all shareable\n handles are closed, the memory_handle is released.\n\n @param[out] dmabuf_fd shareable handle\n @param[in] handle previously allocated virtual memory handle\n @param[in] flags Currently unsupported\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid memory handle\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Out of resources\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_export_shareable_handle(
        dmabuf_fd: *mut ::std::os::raw::c_int,
        handle: hsa_amd_vmem_alloc_handle_t,
        flags: u64,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Import a shareable handle\n\n Import a shareable handle for a memory handle. Importing a shareable handle that has been closed\n and released results in undefined behavior.\n\n @param[in] dmabuf_fd shareable handle exported with hsa_amd_vmem_export_shareable_handle\n @param[out] handle virtual memory handle\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid memory handle\n\n @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Out of resources\n\n @retval ::HSA_STATUS_ERROR Unexpected internal error"]
    pub fn hsa_amd_vmem_import_shareable_handle(
        dmabuf_fd: ::std::os::raw::c_int,
        handle: *mut hsa_amd_vmem_alloc_handle_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns memory handle for mapped memory\n\n Return a memory handle for previously mapped memory. The handle will be the same value of handle\n used to map the memory. The returned handle must be released with corresponding number of calls\n to hsa_amd_vmem_handle_release.\n\n @param[out] memory_handle memory handle for this mapped address\n @param[in] mapped address\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid address"]
    pub fn hsa_amd_vmem_retain_alloc_handle(
        memory_handle: *mut hsa_amd_vmem_alloc_handle_t,
        addr: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns the current allocation properties of a handle\n\n Returns the allocation properties of an existing handle\n\n @param[in] memory_handle memory handle to be queried\n @param[out] pool memory pool that owns this handle\n @param[out] memory type\n\n @retval ::HSA_STATUS_SUCCESS\n\n @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION Invalid memory_handle"]
    pub fn hsa_amd_vmem_get_alloc_properties_from_handle(
        memory_handle: hsa_amd_vmem_alloc_handle_t,
        pool: *mut hsa_amd_memory_pool_t,
        type_: *mut hsa_amd_memory_type_t,
    ) -> hsa_status_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the asynchronous scratch limit threshold on all the queues for this agent.\n Dispatches that are enqueued on HW queues on this agent that are smaller than threshold will not\n result in a scratch use-once method.\n\n Increasing this threshold will only increase the internal limit and not cause immediate allocation\n of additional scratch memory. Decreasing this threshold will result in a release in scratch memory\n on queues where the current amount of allocated scratch exceeds the new limit.\n\n This API is only supported on devices that support asynchronous scratch reclaim.\n\n @param[in] agent A valid agent.\n\n @param[in] threshold Threshold size in bytes\n\n @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n\n @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n initialized.\n\n @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n\n @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT This agent does not support asynchronous scratch\n reclaim"]
    pub fn hsa_amd_agent_set_async_scratch_limit(
        agent: hsa_agent_t,
        threshold: usize,
    ) -> hsa_status_t;
}
pub const hsa_queue_info_attribute_t_HSA_AMD_QUEUE_INFO_AGENT: hsa_queue_info_attribute_t = 0;
pub const hsa_queue_info_attribute_t_HSA_AMD_QUEUE_INFO_DOORBELL_ID: hsa_queue_info_attribute_t = 1;
pub type hsa_queue_info_attribute_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn hsa_amd_queue_get_info(
        queue: *mut hsa_queue_t,
        attribute: hsa_queue_info_attribute_t,
        value: *mut ::std::os::raw::c_void,
    ) -> hsa_status_t;
}
